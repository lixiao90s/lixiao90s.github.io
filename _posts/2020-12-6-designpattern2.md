---
title: 设计模式 - 设计模式的原则
author: 晓
date: 2020-12-6 9:36:00 +0800
categories: [设计模式]
tags: [设计模式的原则]
---

## 七大原则

### 单一职责原则

单一职责原则（Single Responsibility Principle, SRP）： 一个类只负责一个功能领域中的相 应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。

### 开闭原则

开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件 实体应尽量在不修改原有代码的情况下进行扩展。
在 Java、C#等 编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现 层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系 统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何 改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩 展系统的功能，达到开闭原则的要求。

### 里式替换原则

里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类 （父类）的地方必须能透明地使用其子类的对象。
里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任 何错误和异常，反过来则不成立。
里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对 象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用 子类对象来替换父类对象。
(1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代 换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在 子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。
(2) 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现 父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地 扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类 来实现。里氏代换原则是开闭原则的具体实现手段之一。

### 依赖倒转原则

依赖倒转原则(Dependency Inversion Principle, DIP)：抽象不应该依赖于细节，细节应 当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。
依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层 类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据 类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只 实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增 加的新方法。 在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体 类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改 配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭 原则的要求。 在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入 (DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发 生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注 入，设值注入（Setter 注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象， 设值注入是指通过 Setter 方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务 方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型 的对象，由子类对象来覆盖父类对象。

### 接口隔离原则

接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一 的总接口，即客户端不应该依赖那些它不需要的接口。

根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接 口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干 不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具 有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义， 有严格的定义和结构，比如 Java 语言中的 interface。对于这两种不同的含义，ISP 的表达方式以 及含义都有所不同： (1) 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概 念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角 色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。 (2) 如果把“接口”理解成狭义的特定语言的接口，那么 ISP 表达的意思是指接口仅仅提供客户端 需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口， 而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的 所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口 中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便， 并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只 包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即 为不同的客户端提供宽窄不同的接口。

### 合成复用原则

合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复 用的目的。

合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些 已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能 的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。

在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/ 聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低 类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使 用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂 度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继 承复用。 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实 现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白 箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是 静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用 （如类没有声明为不能被继承）。
由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新 对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现 细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对 较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用 成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型 相同的其他对象。

### 迪米特原则

迪米特法则(Law of Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。

迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等，在迪 米特法则中，对于一个对象，其朋友包括以下几类：

- (1) 当前对象本身(this)；
- (2) 以参数形式传入到当前对象方法中的对象；
- (3) 当前对象的成员对象；
- (4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；
- (5) 当前对象所创建的对象。
