<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://lixiao90s.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lixiao90s.github.io/" rel="alternate" type="text/html" hreflang="zh-CN" /><updated>2025-08-18T20:17:03+08:00</updated><id>https://lixiao90s.github.io/feed.xml</id><title type="html">晓的博客</title><subtitle>记录学习 工作。</subtitle><entry><title type="html">Grain官方文档的一些理解</title><link href="https://lixiao90s.github.io/post/some-understanding-of-grain-s-official-documentation-zcic9v.html" rel="alternate" type="text/html" title="Grain官方文档的一些理解" /><published>2025-08-08T14:31:29+08:00</published><updated>2025-08-08T14:31:29+08:00</updated><id>https://lixiao90s.github.io/post/some-understanding-of-grain-s-official-documentation-zcic9v</id><content type="html" xml:base="https://lixiao90s.github.io/post/some-understanding-of-grain-s-official-documentation-zcic9v.html"><![CDATA[<h2 id="灵活放置">灵活放置</h2>

<ul>
  <li>grain被激活时，由runtime决定 哪个silo激活</li>
  <li>
    <p>放置策略</p>

    <ul>
      <li>随机</li>
      <li>本地哟偶先</li>
      <li>负载均衡</li>
      <li>自定义</li>
    </ul>
  </li>
</ul>

<h2 id="持久化">持久化</h2>

<ul>
  <li>将grain状态保存到外部存储系统（一般是数据库或者云存储），当被停用时状态不丢失，激活时恢复到之前状态，这样业务将无感。</li>
  <li>
    <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">ShoppingCartGrain</span><span class="p">(</span>
    <span class="p">[</span><span class="nf">PersistentState</span><span class="p">(</span>
            <span class="n">stateName</span><span class="p">:</span> <span class="s">"ShoppingCart"</span><span class="p">,</span>
            <span class="n">storageName</span><span class="p">:</span> <span class="s">"shopping-cart"</span><span class="p">)]</span>
        <span class="n">IPersistentState</span><span class="p">&lt;</span><span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">CartItem</span><span class="p">&gt;&gt;</span> <span class="n">cart</span><span class="p">)</span> <span class="p">:</span> <span class="n">Grain</span><span class="p">,</span> <span class="n">IShoppingCartGrain</span>

<span class="c1">//配置地方</span>
<span class="k">if</span> <span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">Environment</span><span class="p">.</span><span class="nf">IsDevelopment</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">Host</span><span class="p">.</span><span class="nf">UseOrleans</span><span class="p">((</span><span class="n">_</span><span class="p">,</span> <span class="n">builder</span><span class="p">)</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">builder</span>
            <span class="p">.</span><span class="nf">UseLocalhostClustering</span><span class="p">()</span>
            <span class="p">.</span><span class="nf">AddMemoryGrainStorage</span><span class="p">(</span><span class="s">"shopping-cart"</span><span class="p">)</span> <span class="c1">// &lt;-- Here it is!</span>
            <span class="p">.</span><span class="n">AddStartupTask</span><span class="p">&lt;</span><span class="n">SeedProductStoreTask</span><span class="p">&gt;();</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>

<h2 id="无状态工作者stateless-workers">无状态工作者(Stateless workers)</h2>

<ul>
  <li>不存储任何需要持久化的状态，每次调用都是全新操作</li>
</ul>

<h2 id="grain-call-filters-调用筛选器">Grain call filters (调用筛选器)</h2>

<ul>
  <li>关注核心的业务逻辑，同时将日志、授权、错误处理等通用功能集中到可重用的筛选器组件中，极大地提高了代码的可维护性和可扩展性。</li>
  <li>您可以把它想象成 ASP.NET Core 中的中间件 (Middleware)，或者其他框架中的“拦截器” (Interceptor)。它的核心作用就是 在不修改 grain 本身代码的情况下，为 grain 的方法调用添加额外的通用逻辑 。</li>
  <li>面向切面编程 (AOP)</li>
  <li>
    <p>这是最经典的用例。您希望记录每个 grain 方法的调用情况，比如：哪个方法被调用了、参数是什么、执行了多长时间、是否成功等。如果没有筛选器，您就需要在每个 grain 的每个方法里都写重复的日志代码。</p>

    <ul>
      <li>
        <ul>
          <li>集中管理日志逻辑。</li>
          <li>轻松监控系统性能和瓶颈。</li>
          <li>调试和追踪问题。</li>
          <li>
            <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="rouge-code"><pre><span class="c1">// 1. 实现筛选器接口</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">LoggingGrainCallFilter</span> <span class="p">:</span> <span class="n">IIncomingGrainCallFilter</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">ILogger</span><span class="p">&lt;</span><span class="n">LoggingGrainCallFilter</span><span class="p">&gt;</span> <span class="n">_logger</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">LoggingGrainCallFilter</span><span class="p">(</span><span class="n">ILogger</span><span class="p">&lt;</span><span class="n">LoggingGrainCallFilter</span><span class="p">&gt;</span> <span class="n">logger</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_logger</span> <span class="p">=</span> <span class="n">logger</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">Invoke</span><span class="p">(</span><span class="n">IIncomingGrainCallContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">stopwatch</span> <span class="p">=</span> <span class="n">Stopwatch</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">();</span>
        <span class="n">_logger</span><span class="p">.</span><span class="nf">LogInformation</span><span class="p">(</span>
            <span class="s">"Grain Call Starting: {Grain}.{Method} with arguments {Arguments}"</span><span class="p">,</span>
            <span class="n">context</span><span class="p">.</span><span class="n">Grain</span><span class="p">.</span><span class="nf">GetType</span><span class="p">().</span><span class="n">Name</span><span class="p">,</span>
            <span class="n">context</span><span class="p">.</span><span class="n">ImplementationMethod</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span>
            <span class="n">context</span><span class="p">.</span><span class="n">Arguments</span><span class="p">);</span>

        <span class="k">try</span>
        <span class="p">{</span>
            <span class="c1">// 调用链中的下一个筛选器，或者直接调用 grain 方法</span>
            <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">();</span>

            <span class="n">stopwatch</span><span class="p">.</span><span class="nf">Stop</span><span class="p">();</span>
            <span class="n">_logger</span><span class="p">.</span><span class="nf">LogInformation</span><span class="p">(</span>
                <span class="s">"Grain Call Succeeded: {Grain}.{Method} executed in {ElapsedMilliseconds}ms"</span><span class="p">,</span>
                <span class="n">context</span><span class="p">.</span><span class="n">Grain</span><span class="p">.</span><span class="nf">GetType</span><span class="p">().</span><span class="n">Name</span><span class="p">,</span>
                <span class="n">context</span><span class="p">.</span><span class="n">ImplementationMethod</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span>
                <span class="n">stopwatch</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">stopwatch</span><span class="p">.</span><span class="nf">Stop</span><span class="p">();</span>
            <span class="n">_logger</span><span class="p">.</span><span class="nf">LogError</span><span class="p">(</span>
                <span class="n">ex</span><span class="p">,</span>
                <span class="s">"Grain Call Failed: {Grain}.{Method} executed in {ElapsedMilliseconds}ms"</span><span class="p">,</span>
                <span class="n">context</span><span class="p">.</span><span class="n">Grain</span><span class="p">.</span><span class="nf">GetType</span><span class="p">().</span><span class="n">Name</span><span class="p">,</span>
                <span class="n">context</span><span class="p">.</span><span class="n">ImplementationMethod</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span>
                <span class="n">stopwatch</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">);</span>
                  
            <span class="c1">// 必须重新抛出异常，否则调用方会认为调用成功了</span>
            <span class="k">throw</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 2. 在 Silo 中注册筛选器</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Host</span><span class="p">.</span><span class="nf">UseOrleans</span><span class="p">(</span><span class="n">siloBuilder</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="c1">// 将筛选器注册为全局筛选器，应用到所有 grain</span>
    <span class="n">siloBuilder</span><span class="p">.</span><span class="n">AddIncomingGrainCallFilter</span><span class="p">&lt;</span><span class="n">LoggingGrainCallFilter</span><span class="p">&gt;();</span>
<span class="p">});</span>
</pre></td></tr></tbody></table></code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>例子2 授权赛选器</p>

    <ul>
      <li>
        <p>‍</p>

        <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre><span class="c1">// 1. 定义一个特性，用来标记需要授权的方法</span>
<span class="p">[</span><span class="nf">AttributeUsage</span><span class="p">(</span><span class="n">AttributeTargets</span><span class="p">.</span><span class="n">Method</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">RequiresAdminRoleAttribute</span> <span class="p">:</span> <span class="n">Attribute</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="c1">// 2. 实现筛选器</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">AuthorizationGrainCallFilter</span> <span class="p">:</span> <span class="n">IIncomingGrainCallFilter</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">Invoke</span><span class="p">(</span><span class="n">IIncomingGrainCallContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 检查目标方法是否标记了我们的特性</span>
        <span class="kt">var</span> <span class="n">requiresAdmin</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">ImplementationMethod</span><span class="p">.</span><span class="n">GetCustomAttribute</span><span class="p">&lt;</span><span class="n">RequiresAdminRoleAttribute</span><span class="p">&gt;();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">requiresAdmin</span> <span class="k">is</span> <span class="n">not</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 从调用上下文中获取用户信息 (这通常需要您自己实现)</span>
            <span class="kt">var</span> <span class="n">userRole</span> <span class="p">=</span> <span class="n">RequestContext</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">"UserRole"</span><span class="p">)</span> <span class="k">as</span> <span class="kt">string</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">userRole</span> <span class="p">!=</span> <span class="s">"Admin"</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// 如果用户不是 Admin，则直接抛出异常，阻止方法调用</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">UnauthorizedAccessException</span><span class="p">(</span><span class="s">"User does not have the required 'Admin' role."</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 如果检查通过，则继续调用</span>
        <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 3. 在 Grain 方法上使用特性</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">SuperSecretGrain</span> <span class="p">:</span> <span class="n">Grain</span><span class="p">,</span> <span class="n">ISuperSecretGrain</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">RequiresAdminRole</span><span class="p">]</span>
    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">GetTheSecretCode</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="nf">FromResult</span><span class="p">(</span><span class="s">"12345"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">GetPublicInfo</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="nf">FromResult</span><span class="p">(</span><span class="s">"This is public info."</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 4. 别忘了在 Silo 中注册筛选器！</span>
<span class="n">siloBuilder</span><span class="p">.</span><span class="n">AddIncomingGrainCallFilter</span><span class="p">&lt;</span><span class="n">AuthorizationGrainCallFilter</span><span class="p">&gt;();</span>
</pre></td></tr></tbody></table></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <ol>
      <li>
        <p>统一的错误处理 (Error Handling)</p>

        <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre> <span class="k">public</span> <span class="k">class</span> <span class="nc">ErrorHandlingGrainCallFilter</span> <span class="p">:</span> <span class="n">IIncomingGrainCallFilter</span>
 <span class="p">{</span>
     <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">Invoke</span><span class="p">(</span><span class="n">IIncomingGrainCallContext</span> <span class="n">context</span><span class="p">)</span>
     <span class="p">{</span>
         <span class="k">try</span>
         <span class="p">{</span>
             <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">();</span>
         <span class="p">}</span>
         <span class="k">catch</span> <span class="p">(</span><span class="n">BusinessValidationException</span> <span class="n">ex</span><span class="p">)</span>
         <span class="p">{</span>
             <span class="c1">// 捕获我们自定义的业务逻辑异常</span>
             <span class="c1">// 并且将其转换为一个特定的结果，而不是让它冒泡到客户端</span>
             <span class="n">context</span><span class="p">.</span><span class="n">Result</span> <span class="p">=</span> <span class="k">new</span> <span class="p">{</span> <span class="n">ErrorCode</span> <span class="p">=</span> <span class="n">ex</span><span class="p">.</span><span class="n">ErrorCode</span><span class="p">,</span> <span class="n">Message</span> <span class="p">=</span> <span class="n">ex</span><span class="p">.</span><span class="n">Message</span> <span class="p">};</span>
         <span class="p">}</span>
         <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span><span class="p">)</span>
         <span class="p">{</span>
             <span class="c1">// 对于所有其他未知的异常，我们只返回一个通用的错误信息</span>
             <span class="c1">// 并且在服务器端记录详细日志（可以在日志筛选器中完成）</span>
             <span class="k">throw</span> <span class="k">new</span> <span class="nf">ApplicationException</span><span class="p">(</span><span class="s">"An unexpected error occurred. Please try again later."</span><span class="p">);</span>
         <span class="p">}</span>
     <span class="p">}</span>
 <span class="p">}</span>

 <span class="c1">// 注册筛选器</span>
 <span class="n">siloBuilder</span><span class="p">.</span><span class="n">AddIncomingGrainCallFilter</span><span class="p">&lt;</span><span class="n">ErrorHandlingGrainCallFilter</span><span class="p">&gt;();</span>
</pre></td></tr></tbody></table></code></pre></div>        </div>
      </li>
    </ol>
  </li>
</ul>

<p>##</p>

<h3 id="request-context">Request context</h3>

<p>它的主要作用是在一次完整的请求-响应生命周期中，共享那些 不属于 grain 本身状态 、但又对处理逻辑很重要的 临时性数据 。</p>

<p>1.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="c1">// 设置一个唯一的追踪 ID，用于追踪整个调用链</span>
<span class="n">RequestContext</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">"TraceId"</span><span class="p">,</span> <span class="n">Guid</span><span class="p">.</span><span class="nf">NewGuid</span><span class="p">());</span> 
<span class="c1">// 设置当前用户的 ID</span>
<span class="n">RequestContext</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">"UserId"</span><span class="p">,</span> <span class="s">"user-123"</span><span class="p">);</span>

<span class="c1">// 现在发起对第一个 grain 的调用</span>
<span class="kt">var</span> <span class="n">grainA</span> <span class="p">=</span> <span class="n">client</span><span class="p">.</span><span class="n">GetGrain</span><span class="p">&lt;</span><span class="n">IGrainA</span><span class="p">&gt;(</span><span class="m">0</span><span class="p">);</span>
<span class="k">await</span> <span class="n">grainA</span><span class="p">.</span><span class="nf">DoSomething</span><span class="p">();</span> 
</pre></td></tr></tbody></table></code></pre></div></div>

<p>2.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="k">public</span> <span class="k">class</span> <span class="nc">GrainB</span> <span class="p">:</span> <span class="n">Grain</span><span class="p">,</span> <span class="n">IGrainB</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DoWork</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 直接从 RequestContext 中读取数据</span>
        <span class="kt">var</span> <span class="n">traceId</span> <span class="p">=</span> <span class="n">RequestContext</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">"TraceId"</span><span class="p">);</span>
        <span class="kt">var</span> <span class="n">userId</span> <span class="p">=</span> <span class="n">RequestContext</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">"UserId"</span><span class="p">);</span>

        <span class="n">_logger</span><span class="p">.</span><span class="nf">LogInformation</span><span class="p">(</span><span class="s">"GrainB is doing work for user {UserId} with trace {TraceId}"</span><span class="p">,</span> <span class="n">userId</span><span class="p">,</span> <span class="n">traceId</span><span class="p">);</span>

        <span class="c1">// ... 业务逻辑 ...</span>

        <span class="c1">// 调用下一个 grain，RequestContext 中的数据会自动传递过去</span>
        <span class="kt">var</span> <span class="n">grainC</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">GrainFactory</span><span class="p">.</span><span class="n">GetGrain</span><span class="p">&lt;</span><span class="n">IGrainC</span><span class="p">&gt;(</span><span class="m">0</span><span class="p">);</span>
        <span class="k">await</span> <span class="n">grainC</span><span class="p">.</span><span class="nf">DoMoreWork</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="requestcontext-的主要应用场景">RequestContext 的主要应用场景</h3>

<ol>
  <li>
    <p>‍</p>

    <p>分布式追踪 (Distributed Tracing) ：这是最常见的用途。在请求的最开始生成一个唯一的 TraceId (或 CorrelationId )，并放入 RequestContext 。之后，在每个 grain 的日志中都带上这个 ID。当系统出现问题时，您就可以通过这个 TraceId 在日志系统中（如 ELK, Splunk, Datadog）串联起一次完整请求经过的所有路径，极大地简化了分布式环境下的问题排查。</p>
  </li>
  <li>
    <p>‍</p>

    <p>传递用户身份或租户信息 ：在多租户的应用中，您可以在请求入口处将用户的身份令牌 (token)、用户ID或租户ID放入 RequestContext 。这样，调用链中的任何一个 grain 都可以知道当前操作属于哪个用户或租户，而无需在每个方法签名中都传递这些信息。这对于实现授权逻辑（如我们之前讨论的调用筛选器）尤其有用。</p>
  </li>
  <li>
    <p>‍</p>

    <p>传递客户端信息 ：例如客户端的设备类型 ( “iOS” , “Android” , “Web” )、IP 地址或者语言偏好 ( “en-US” , “zh-CN” )。这可以让 grain 根据不同的客户端环境返回不同的数据或执行不同的逻辑。</p>
  </li>
  <li>
    <p>‍</p>

    <p>功能开关或 A/B 测试 ：您可以将一些功能开关的标志位放入 RequestContext ，来控制在本次请求中是否启用某个新功能，从而实现灰度发布或 A/B 测试。</p>
  </li>
</ol>

<h3 id="需要注意的关键点">需要注意的关键点</h3>

<ul>
  <li>线程安全 ： RequestContext 是基于 AsyncLocal<T> 实现的，这意味着它存储的数据是与当前的异步控制流（async control flow）绑定的，是线程安全的。</T></li>
  <li>非持久化 ： RequestContext 中的数据是 临时的、非持久的 。它只在一次请求的生命周期内有效。它 不是 用来替代 grain 的持久化状态的。</li>
  <li>数据大小 ：由于 RequestContext 的数据需要在每次 grain 间调用时进行序列化和网络传输，所以不应该在里面存放大量的数据。只应存放少量的、关键的元数据。</li>
</ul>

<p>‍</p>

<h2 id="分布式-acid-事务distributed-acid-transactions">分布式 ACID 事务(Distributed ACID transactions)</h2>

<ul>
  <li>原子性 (Atomicity) ：一个事务中的所有操作，要么 全部成功 ，要么 全部失败 回滚。不会出现“钱扣了，但对方没收到”的中间状态。</li>
  <li>一致性 (Consistency) ：事务必须使系统从一个有效的状态转移到另一个有效的状态。例如，转账前后，银行系统所有账户的总金额应该是不变的。</li>
  <li>隔离性 (Isolation) ：并发执行的事务之间互不干扰。Orleans 提供了 可串行化 (Serializable) 的隔离级别，这是最严格的隔离级别，它保证了并发事务的最终结果与某个顺序执行它们的结果完全相同。</li>
  <li>持久性 (Durability) ：一旦事务成功提交，其结果就是永久性的，即使系统发生故障也不会丢失。</li>
  <li>
    <p>分布式 （Distributed ）：这意味着一个 ACID 事务可以跨越 多个不同的 grain ，而这些 grain 可能位于集群中 不同的物理服务器 (Silo) 上</p>
  </li>
  <li>官方例子关键代码</li>
  <li>
    <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
</pre></td><td class="rouge-code"><pre><span class="c1">// (这是 BankAccount 示例中的代码结构)</span>

<span class="k">public</span> <span class="k">interface</span> <span class="nc">IAccountGrain</span> <span class="p">:</span> <span class="n">IGrainWithIntegerKey</span>
<span class="p">{</span>
    <span class="c1">// [Transaction] 特性指明这个方法必须在一个事务中执行</span>
    <span class="p">[</span><span class="nf">Transaction</span><span class="p">(</span><span class="n">TransactionOption</span><span class="p">.</span><span class="n">Join</span><span class="p">)]</span>
    <span class="n">Task</span> <span class="nf">Withdraw</span><span class="p">(</span><span class="kt">uint</span> <span class="n">amount</span><span class="p">);</span>

    <span class="p">[</span><span class="nf">Transaction</span><span class="p">(</span><span class="n">TransactionOption</span><span class="p">.</span><span class="n">Join</span><span class="p">)]</span>
    <span class="n">Task</span> <span class="nf">Deposit</span><span class="p">(</span><span class="kt">uint</span> <span class="n">amount</span><span class="p">);</span>

    <span class="p">[</span><span class="nf">Transaction</span><span class="p">(</span><span class="n">TransactionOption</span><span class="p">.</span><span class="n">CreateOrJoin</span><span class="p">)]</span>
    <span class="n">Task</span><span class="p">&lt;</span><span class="kt">uint</span><span class="p">&gt;</span> <span class="nf">GetBalance</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// (这是 BankAccount 示例中的代码结构)</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">AccountGrain</span> <span class="p">:</span> <span class="n">Grain</span><span class="p">,</span> <span class="n">IAccountGrain</span>
<span class="p">{</span>
    <span class="c1">// 使用 ITransactionalState 来存储账户余额,前面有个IPersistState</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">ITransactionalState</span><span class="p">&lt;</span><span class="n">Balance</span><span class="p">&gt;</span> <span class="n">_balance</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">AccountGrain</span><span class="p">(</span>
        <span class="p">[</span><span class="nf">TransactionalState</span><span class="p">(</span><span class="s">"balance"</span><span class="p">)]</span> <span class="n">ITransactionalState</span><span class="p">&lt;</span><span class="n">Balance</span><span class="p">&gt;</span> <span class="n">balance</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_balance</span> <span class="p">=</span> <span class="n">balance</span> <span class="p">??</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentNullException</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">balance</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="c1">// 在方法中，我们就像操作普通对象一样修改状态</span>
    <span class="k">public</span> <span class="n">Task</span> <span class="nf">Withdraw</span><span class="p">(</span><span class="kt">uint</span> <span class="n">amount</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">_balance</span><span class="p">.</span><span class="nf">PerformUpdate</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Value</span> <span class="p">-=</span> <span class="n">amount</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">Task</span> <span class="nf">Deposit</span><span class="p">(</span><span class="kt">uint</span> <span class="n">amount</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">_balance</span><span class="p">.</span><span class="nf">PerformUpdate</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Value</span> <span class="p">+=</span> <span class="n">amount</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">uint</span><span class="p">&gt;</span> <span class="nf">GetBalance</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">_balance</span><span class="p">.</span><span class="nf">PerformRead</span><span class="p">(</span><span class="n">b</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//执行事务</span>
<span class="c1">// (这是 BankAccount 示例中的代码结构)</span>

<span class="c1">// 注入 ITransactionClient</span>
<span class="k">private</span> <span class="k">readonly</span> <span class="n">ITransactionClient</span> <span class="n">_transactionClient</span><span class="p">;</span>

<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">Transfer</span><span class="p">(</span><span class="n">IAccountGrain</span> <span class="n">fromAccount</span><span class="p">,</span> <span class="n">IAccountGrain</span> <span class="n">toAccount</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">amountToTransfer</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="c1">// 使用 TransactionClient 来执行一个事务性的 lambda 表达式</span>
        <span class="c1">// 在这个 lambda 表达式中进行的所有 grain 调用，都会被自动包含在同一个事务里</span>
        <span class="k">await</span> <span class="n">_transactionClient</span><span class="p">.</span><span class="nf">RunTransaction</span><span class="p">(</span>
            <span class="n">TransactionOption</span><span class="p">.</span><span class="n">Create</span><span class="p">,</span> <span class="c1">// 创建一个新事务</span>
            <span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="c1">// 1. 从 fromAccount 取款</span>
                <span class="k">await</span> <span class="n">fromAccount</span><span class="p">.</span><span class="nf">Withdraw</span><span class="p">(</span><span class="n">amountToTransfer</span><span class="p">);</span>

                <span class="c1">// 2. 向 toAccount 存款</span>
                <span class="k">await</span> <span class="n">toAccount</span><span class="p">.</span><span class="nf">Deposit</span><span class="p">(</span><span class="n">amountToTransfer</span><span class="p">);</span>
            <span class="p">});</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 如果在执行过程中发生任何错误 (比如 fromAccount 余额不足抛出异常)</span>
        <span class="c1">// 整个事务会自动回滚。</span>
        <span class="c1">// fromAccount 的取款操作会被撤销，toAccount 的存款操作也根本不会发生。</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Transaction failed: </span><span class="p">{</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>

<h3 id="itransactionalstatet-与-ipersistentstatet-的关键区别"><code class="language-plaintext highlighter-rouge">ITransactionalState&lt;T&gt;</code>​ 与 <code class="language-plaintext highlighter-rouge">IPersistentState&lt;T&gt;</code>​ 的关键区别</h3>

<p>为了更好地理解它，我们可以将它与我们之前讨论过的标准持久化组件 <code class="language-plaintext highlighter-rouge">IPersistentState&lt;T&gt;</code>​ 进行对比：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">特性</th>
      <th style="text-align: left">​<code class="language-plaintext highlighter-rouge">IPersistentState&lt;T&gt;</code>​ (标准持久化)</th>
      <th style="text-align: left">​<code class="language-plaintext highlighter-rouge">ITransactionalState&lt;T&gt;</code>​ (事务性状态)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>核心关注点</strong></td>
      <td style="text-align: left">单个 Grain 状态的<strong>持久化（Durability）</strong> 。确保 Grain 失活或服务器重启后，状态能从存储中恢复。</td>
      <td style="text-align: left">跨多个 Grain 操作的<strong>原子性（Atomicity）</strong> 和<strong>隔离性（Isolation）</strong> 。确保一组操作要么全部成功，要么全部失败。</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>操作方式</strong></td>
      <td style="text-align: left">通过 <code class="language-plaintext highlighter-rouge">.State</code>​ 属性直接访问和修改内存中的状态，然后显式调用 <code class="language-plaintext highlighter-rouge">.WriteStateAsync()</code>​ 将其写入存储。</td>
      <td style="text-align: left">通过 <code class="language-plaintext highlighter-rouge">.PerformUpdate()</code>​ 和 <code class="language-plaintext highlighter-rouge">.PerformRead()</code>​ 方法来“请求”对状态进行修改或读取。</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>谁来控制写入</strong></td>
      <td style="text-align: left"><strong>开发者</strong>。您需要自己决定何时调用 <code class="language-plaintext highlighter-rouge">WriteStateAsync()</code>​。</td>
      <td style="text-align: left"><strong>Orleans 事务管理器</strong>。开发者从不直接调用写入方法。状态的最终提交或回滚由事务协调器自动处理。</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>适用场景</strong></td>
      <td style="text-align: left">适用于绝大多数不需要跨 Grain 协调的、独立的有状态服务。例如，保存用户的购物车、个人资料等。</td>
      <td style="text-align: left">必须用于需要多个 Grain 协同完成一个业务逻辑的场景。最典型的例子就是银行转账，涉及两个账户 Grain 的状态同步更新。</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="itransactionalstatet-的工作机制"><code class="language-plaintext highlighter-rouge">ITransactionalState&lt;T&gt;</code>​ 的工作机制</h3>

<p>​<code class="language-plaintext highlighter-rouge">ITransactionalState&lt;T&gt;</code>​ 通过两个核心方法来运作：</p>

<ol>
  <li>
    <p>​<strong>​<code class="language-plaintext highlighter-rouge">Task&lt;TResult&gt; PerformRead(Func&lt;T, TResult&gt; readFunc)</code>​</strong> ​</p>

    <ul>
      <li><strong>作用</strong>：以事务安全的方式读取状态。</li>
      <li><strong>解释</strong>：当你调用此方法时，Orleans 会确保你读取到的数据在当前事务的隔离级别（通常是“可串行化”）下是一致的。这意味着你不会读到其他并发事务尚未提交的“脏数据”。</li>
      <li>
        <p><strong>示例</strong>：在 <code class="language-plaintext highlighter-rouge">AccountGrain</code>​ 中获取余额。</p>

        <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">decimal</span><span class="p">&gt;</span> <span class="nf">GetBalance</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">_balance</span><span class="p">.</span><span class="nf">PerformRead</span><span class="p">(</span><span class="n">balance</span> <span class="p">=&gt;</span> <span class="n">balance</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>​<strong>​<code class="language-plaintext highlighter-rouge">Task PerformUpdate(Action&lt;T&gt; updateAction)</code>​</strong> ​</p>

    <ul>
      <li><strong>作用</strong>：以事务安全的方式更新状态。</li>
      <li><strong>解释</strong>：这是最关键的部分。当你调用此方法时，你并不是立即修改了状态。相反，你是在向当前事务提交一个“意图”——“我计划对状态进行这样的修改”。这个修改操作会被记录下来，但<strong>不会立即持久化</strong>。</li>
      <li>
        <p><strong>示例</strong>：在 <code class="language-plaintext highlighter-rouge">AccountGrain</code>​ 中存款。</p>

        <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">public</span> <span class="n">Task</span> <span class="nf">Deposit</span><span class="p">(</span><span class="kt">decimal</span> <span class="n">amount</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">_balance</span><span class="p">.</span><span class="nf">PerformUpdate</span><span class="p">(</span><span class="n">balance</span> <span class="p">=&gt;</span> <span class="n">balance</span><span class="p">.</span><span class="n">Value</span> <span class="p">+=</span> <span class="n">amount</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<p>‍</p>

<p>##</p>

<h3 id="orleans-streams-的核心概念">Orleans Streams 的核心概念</h3>

<p>Orleans Streams 是一个强大的流式处理框架，它将流处理的复杂性与 Grain 模型无缝集成。您可以把它想象成一个内置于 Orleans 的、 为 Grain “量身定做” 的、虚拟化的发布/订阅（Pub/Sub）系统 。</p>

<p>‍</p>

<p>1.虚拟化（Virtualization） ：与 Grain 一样，流也是虚拟的。这意味着您不需要显式地创建或销毁一个流。流永远存在，就像 Grain 一样。您只需通过一个唯一的标识符（ StreamId ）就可以向它发布消息或订阅它。</p>

<p>2.生产者与消费者解耦 ：生产者向一个流发布消息，而不需要知道谁在监听这个流，有多少个监听者，或者它们当前是否处于激活状态。同样，消费者订阅一个流，而不需要知道谁在发布消息。</p>

<p>3.可靠性与持久性 ：Orleans Streams 通过<strong>流提供程序（Stream Provider）</strong> 来支持不同的底层消息队列技术。这意味着流中的消息可以是持久化的（例如，使用 Azure Event Hubs 或 RabbitMQ），确保了即使在消费者离线或系统重启后，消息也不会丢失。</p>

<p>4.自动化的生命周期管理 ：Orleans 负责管理消费者的订阅生命周期。当一个订阅流的 Grain 被激活时，Orleans 会自动为其恢复订阅。如果消费者处理消息失败，Orleans 还提供了内置的重试和错误处理机制。</p>

<p>5.背压（Backpressure） ：系统会自动监测消费者的处理速度。如果消费者跟不上消息产生的速度，流提供程序会减慢或暂停向其递送消息，防止消费者被压垮。</p>

<p>‍</p>

<p>Stream (流)</p>

<ul>
  <li>它是一个逻辑上的 通道 ，用于传输一系列有序的事件。</li>
  <li>每个流都有一个唯一的标识符（一个 Guid 和一个 string 类型的命名空间），例如 StreamId.Create(“my-namespace”, someGuid) 。</li>
  <li>流是 虚拟的、持久的 。即使没有任何生产者或消费者连接到它，流也“存在”。数据可以发布到一个流中，即使当时没有消费者；当消费者稍后订阅时，它可以从流的特定点开始接收数据。</li>
</ul>

<p>2.Stream Producer (流生产者)</p>

<ul>
  <li>任何可以将事件发布到流中的实体。通常是一个 Grain，但也可以是 Orleans 集群外部的客户端。</li>
  <li>生产者获取一个流的句柄 ( IAsyncStream<T> )，然后调用 .OnNextAsync(event) 来发布事件。</T></li>
  <li>示例 : 在 Streaming\Simple\Grains\ProducerGrain.cs 中， ProducerGrain 就是一个生产者。它会定期向一个流中发送 int 型的事件。</li>
</ul>

<p>3.Stream Consumer (流消费者)</p>

<ul>
  <li>订阅流并处理事件的实体，通常也是一个 Grain。</li>
  <li>消费者通过订阅一个流来接收事件。当新事件到达时，Orleans 运行时会调用消费者 Grain 中预定义的处理方法（例如 OnNextAsync ）。</li>
  <li>
    <p>隐式订阅 vs. 显式订阅 :</p>

    <ul>
      <li>隐式订阅 ( [ImplicitStreamSubscription(“MyStreamNamespace”)] ) : 这是最常见的方式。您可以在 Grain 类上使用此特性。Orleans 会自动为具有相同 Guid 的 Grain 订阅相应命名空间下的流。例如，一个 ConsumerGrain 被激活并传入一个 Guid，它会自动订阅到 StreamId.Create(“MyStreamNamespace”, thatSameGuid) 。</li>
      <li>显式订阅 : 消费者可以动态地获取流的句柄，并调用 .SubscribeAsync(IAsyncObserver<T>) 来手动订阅或退订。</T></li>
    </ul>
  </li>
  <li>示例 : 在 Streaming\Simple\Grains\ConsumerGrain.cs 中， ConsumerGrain 就是一个消费者。它隐式地订阅流，并在收到事件时将其打印出来。</li>
</ul>

<p>4.Stream Provider (流提供程序)</p>

<ul>
  <li>这是流的物理实现。它负责事件的传输、持久化和传递保证。</li>
  <li>
    <p>Orleans 提供了多种内置的流提供程序：</p>

    <ul>
      <li>MemoryStreamProvider : 用于测试和开发。事件存储在内存中，Silo 重启后会丢失。</li>
      <li>AzureQueueStreamProvider : 使用 Azure Queue Storage 作为传输媒介。</li>
      <li>EventHubStreamProvider : 使用 Azure Event Hubs，适用于大规模、高吞吐量的场景。</li>
      <li>AWSSQSStreamProvider : 使用 Amazon SQS。</li>
    </ul>
  </li>
  <li>官方例子 Streaming\CustomDataAdapter 示例那样，创建自己的提供程序来对接任何消息系统（如 RabbitMQ, Kafka 等）。</li>
</ul>]]></content><author><name></name></author><category term="orleans" /><category term="服务器" /><category term=".Net" /><category term="c#" /><summary type="html"><![CDATA[灵活放置]]></summary></entry><entry><title type="html">Orleans框架</title><link href="https://lixiao90s.github.io/post/orleans-framework-z1wuwgn.html" rel="alternate" type="text/html" title="Orleans框架" /><published>2025-08-08T14:31:23+08:00</published><updated>2025-08-08T14:31:23+08:00</updated><id>https://lixiao90s.github.io/post/orleans-framework-z1wuwgn</id><content type="html" xml:base="https://lixiao90s.github.io/post/orleans-framework-z1wuwgn.html"><![CDATA[<p>基本概念理解</p>

<h2 id="virtual-actor核心机制">Virtual Actor核心机制</h2>

<ul>
  <li>自动管理生命周期</li>
  <li>
    <p><strong>自动实例化</strong></p>

    <ul>
      <li><strong>触发条件</strong>：消息发送至未激活Actor时，运行时自动创建Grain实例并调用<code class="language-plaintext highlighter-rouge">ActivateAsync()</code>​</li>
      <li><strong>资源回收</strong>：闲置实例触发<code class="language-plaintext highlighter-rouge">DeactivateAsync()</code>​清理，内存释放</li>
    </ul>
  </li>
  <li>
    <p><strong>故障恢复</strong></p>

    <ul>
      <li><strong>服务器宕机</strong>：运行时在下一请求时自动在新节点重建Grain，无需应用层监控</li>
    </ul>
  </li>
  <li>
    <p><strong>位置透明</strong></p>

    <ul>
      <li><strong>调用抽象</strong>：通过Grain ID调用Actor，物理位置由运行时目录服务动态映射，缓存命中率&gt;90%</li>
    </ul>
  </li>
  <li>
    <p><strong>扩展模式</strong></p>

    <ul>
      <li><strong>无状态Worker</strong>：同一Grain多实例并行处理请求，适用无状态场景（如只读缓存）</li>
    </ul>
  </li>
</ul>

<h2 id="grain">Grain</h2>

<p>Grain是Orleans中的<strong>虚拟Actor</strong>，代表一个独立的状态实体或计算单元（如玩家、订单、房间）。每个Grain拥有唯一的标识符（Grain ID），通过接口定义其行为</p>

<p><img src="/assets/images/image-20250808153128-2szytyr.png" alt="image" />在基于Orleans框架的游戏开发中，<strong>Grains作为分布式Actor模型的核心单元</strong>，将<strong>需要独立状态、并发安全、生命周期管理</strong>的实体抽象为Grains（如玩家、房间、全局服务）</p>

<h3 id="2-单线程执行的技术实现"><strong>2. 单线程执行的技术实现</strong></h3>

<p>Orleans通过以下机制实现Grain的单线程执行：</p>

<p>Orleans运行时确保<strong>每个激活的Grain在任何时刻仅在一个线程上执行</strong>。这意味着对Grain内部状态的访问天然无需锁或其他同步机制</p>

<p><strong>异步消息队列</strong>：<br />
所有对Grain的调用（即使代码表现为方法调用）均被转化为<strong>异步消息</strong>，存入该Grain专属的<code class="language-plaintext highlighter-rouge">WorkItemGroup</code>​队列</p>

<p><strong>协作式调度</strong>：<br />
运行时使用<strong>少量线程（通常等于CPU核心数）</strong>  处理所有Grain的消息队列。消息按顺序从队列中取出，由同一线程<strong>连续执行直至完成</strong>（无抢占）</p>

<p><strong>状态隔离性</strong>：<br />
Grain的状态（如玩家血量、位置）仅能通过消息修改，外部无法直接访问，从物理上杜绝共享内存冲</p>

<p>‍</p>

<h2 id="silo">Silo</h2>

<p>Silo是<strong>物理资源单位</strong>（如一台服务器）</p>

<p><img src="/assets/images/image-20250808154654-6l2blxd.png" alt="image" /></p>

<p>‍</p>

<h2 id="调用机制本质消息传递">调用机制本质：消息传递</h2>

<ol>
  <li><strong>调用方</strong>（如<code class="language-plaintext highlighter-rouge">PlayerGrain</code>​）向<code class="language-plaintext highlighter-rouge">RoomGrain</code>​发送请求消息。</li>
  <li>
    <p><strong>运行时调度</strong>：</p>

    <ul>
      <li>
        <p>若<code class="language-plaintext highlighter-rouge">RoomGrain</code>​与调用方在<strong>同一Silo</strong>，消息通过<strong>本地队列</strong>直接传递，无网络开销</p>

        <ul>
          <li>若在<strong>不同Silo</strong>，消息经<strong>TCP连接</strong>（默认端口11111）路由至目标Silo的<code class="language-plaintext highlighter-rouge">RoomGrain</code>​</li>
        </ul>
      </li>
      <li>
        <p>​<code class="language-plaintext highlighter-rouge">RoomGrain</code>​处理 <strong>：消息进入其专属</strong>​<strong>​<code class="language-plaintext highlighter-rouge">WorkItemGroup</code>​</strong>​<strong>队列，</strong> 单线程串行执行（即使多个请求并发到达）</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>单线程执行模型</strong>：</p>

    <ul>
      <li>
        <p>每个Grain（包括<code class="language-plaintext highlighter-rouge">RoomGrain</code>​）绑定独立队列，请求<strong>严格串行处理</strong>，避免状态竞争</p>

        <ul>
          <li>例如：玩家A和B同时向<code class="language-plaintext highlighter-rouge">RoomGrain</code>​发送消息，消息按到达顺序依次处理。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>状态隔离性</strong>：</p>

    <ul>
      <li>​<code class="language-plaintext highlighter-rouge">RoomGrain</code>​封装房间状态（如玩家列表、位置），外部仅能通过消息修改，天然线程安全</li>
    </ul>
  </li>
  <li>
    <p><strong>消息顺序保障</strong>：</p>

    <ul>
      <li>同一发送方的消息默认按序传递（除非标记<code class="language-plaintext highlighter-rouge">[Unordered]</code>​）</li>
    </ul>
  </li>
</ol>

<p><strong>所有Grain交互均为消息驱动</strong>，所谓“直接调用”只是语法糖，底层仍由Orleans消息系统保障顺序性，这样可以避免资源竞争等问题，也是实现无锁编程的关键</p>

<p>‍</p>

<h2 id="直接调用消息转化位异步消息的实现">直接调用消息转化位异步消息的实现</h2>

<ol>
  <li>
    <p><strong>Grain引用抽象</strong><br />
 当开发者调用<code class="language-plaintext highlighter-rouge">GrainFactory.GetGrain&lt;T&gt;()</code>​时，Orleans运行时<strong>动态生成代理对象</strong>（如<code class="language-plaintext highlighter-rouge">PlayerGrainReference</code>​），而非真实Grain实例</p>

    <ul>
      <li>代理对象实现与Grain接口相同的公开方法（如<code class="language-plaintext highlighter-rouge">Move()</code>​、<code class="language-plaintext highlighter-rouge">Attack()</code>​）。</li>
      <li>调用代理方法时，实际触发消息封装流程。</li>
    </ul>
  </li>
  <li>
    <p><strong>透明代理技术</strong><br />
 基于.NET的<code class="language-plaintext highlighter-rouge">RealProxy</code>​或<code class="language-plaintext highlighter-rouge">DispatchProxy</code>​，在方法调用时拦截参数并构造消息体</p>

    <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre> <span class="c1">// 示例：代理对象拦截方法调用</span>
 <span class="k">public</span> <span class="k">class</span> <span class="nc">GrainReferenceProxy</span> <span class="p">:</span> <span class="n">DispatchProxy</span> <span class="p">{</span>
     <span class="k">protected</span> <span class="k">override</span> <span class="kt">object</span> <span class="nf">Invoke</span><span class="p">(</span><span class="n">MethodInfo</span> <span class="n">method</span><span class="p">,</span> <span class="kt">object</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
         <span class="kt">var</span> <span class="n">request</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">InvokeMethodRequest</span><span class="p">(</span><span class="n">method</span><span class="p">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span> <span class="c1">// 封装方法名和参数</span>
         <span class="k">return</span> <span class="nf">SendMessage</span><span class="p">(</span><span class="n">request</span><span class="p">);</span> <span class="c1">// 转入消息发送</span>
     <span class="p">}</span>
 <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p><strong>消息结构定义</strong><br />
 每个方法调用被封装为<code class="language-plaintext highlighter-rouge">InvokeMethodRequest</code>​对象，包含：</p>
  </li>
</ol>

<ul>
  <li>
    <p><strong>目标Grain标识</strong>（Grain ID）</p>
  </li>
  <li><strong>方法签名</strong>（方法名、参数类型）</li>
  <li><strong>参数值</strong>（序列化后的二进制数据）<br />
。</li>
</ul>

<ol>
  <li><strong>高效序列化</strong></li>
</ol>

<ul>
  <li>默认使用<code class="language-plaintext highlighter-rouge">Bond</code>​或<code class="language-plaintext highlighter-rouge">MessagePack</code>​二进制序列化，压缩数据体积</li>
  <li>若方法标记<code class="language-plaintext highlighter-rouge">[Immutable]</code>​，参数按值传递；否则按引用传递（需生成Grain引用）。</li>
</ul>

<p><strong>远程调用路径（跨Silo）</strong></p>

<table>
  <thead>
    <tr>
      <th><strong>步骤</strong></th>
      <th><strong>技术实现</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>网关路由</strong></td>
      <td>客户端通过配置的Gateway端口（默认30000）发送消息至Silo集群<br />。</td>
    </tr>
    <tr>
      <td><strong>一致性哈希定位</strong></td>
      <td>根据Grain ID哈希值确定目标Silo，路由表缓存于本地目录服务（<code class="language-plaintext highlighter-rouge">LocalGrainDirectory</code>​）<br />。</td>
    </tr>
    <tr>
      <td><strong>Silo间通信</strong></td>
      <td>使用自定义二进制协议（或gRPC）经TCP端口（默认11111）传输</td>
    </tr>
  </tbody>
</table>

<p>‍</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>是对于Orleans中基本概念的理解，喜欢这套框架的很大原因是无锁开发，高并发的天然优势，以及方便扩展集群，再加上本身又在从事unity开发，对于C#用起来也更得心应手。
</pre></td></tr></tbody></table></code></pre></div></div>

<p>具体API和开发手册可以查看https://learn.microsoft.com/zh-cn/dotnet/orleans/</p>

<p>‍</p>]]></content><author><name></name></author><category term="服务器" /><category term=".Net" /><category term="c#" /><summary type="html"><![CDATA[基本概念理解]]></summary></entry><entry><title type="html">Unity Shader 参考文档 - 第四部分</title><link href="https://lixiao90s.github.io/post/unity-shader-reference-document-part-4-z28zd5r.html" rel="alternate" type="text/html" title="Unity Shader 参考文档 - 第四部分" /><published>2025-07-31T09:07:01+08:00</published><updated>2025-07-31T09:07:01+08:00</updated><id>https://lixiao90s.github.io/post/unity-shader-reference-document-part-4-z28zd5r</id><content type="html" xml:base="https://lixiao90s.github.io/post/unity-shader-reference-document-part-4-z28zd5r.html"><![CDATA[<hr />

<h2 id="pipeline渲染管线">Pipeline（渲染管线）</h2>

<h3 id="应用程序阶段application-stage">应用程序阶段（Application Stage）</h3>

<table>
  <thead>
    <tr>
      <th>阶段</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">0.Application Stage</code>​</td>
      <td>此阶段一般由CPU将需要在屏幕上绘制的几何体、摄像机位置、光照纹理等输出到管线的几何阶段</td>
    </tr>
  </tbody>
</table>

<h3 id="几何阶段geometry-stage">几何阶段（Geometry Stage）</h3>

<table>
  <thead>
    <tr>
      <th>阶段</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">1.模型和视图变换（Model and View Transform）</code>​</td>
      <td>模型和视图变换阶段分为模型变换和视图变换。模型变换的目的是将模型从本地空间变换到世界空间当中，而视图变换的目的是将摄像机放置于坐标原点（以使裁剪和投影操作更简单高效），将模型从世界空间变换到相机空间(观察空间)，以便后续步骤的操作</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">2.顶点着色（Vertex Shading）</code>​</td>
      <td>顶点着色阶段的目的在于确定模型上顶点处的光照效果，其输出结果（颜色、向量、纹理坐标等）会被发送到光栅化阶段以进行插值操作</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">3.几何、曲面细分着色器</code>​</td>
      <td>【可选项】分为几何着色器(Geometry Shader)和曲面细分着色器(Tessellation Shader)，主要是对顶点进行增加与删除修改等操作</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">4.投影（Projection）</code>​</td>
      <td>投影阶段分为正交投影与透视投影，将上面的观察空间变换到齐次裁剪空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">5.裁剪（Clipping）</code>​</td>
      <td>齐次裁剪空间会通过透视除法变换到归一化的设备坐标NDC中，然后再根据图元在视体的位置分为三种裁剪情况：<br />1.当图元完全位于视体内部，那么它可以直接进行下一个阶段<br />2.当图元完全位于视体外部，则不会进入下一个阶段，直接丢弃<br />3.当图元部分位于视体内部，则需要对位于视体内的图元进行裁剪处理</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">6.屏幕映射（Screen Mapping）</code>​</td>
      <td>屏幕映射阶段的主要目的，是将之前步骤得到的坐标映射到对应的屏幕坐标系上</td>
    </tr>
  </tbody>
</table>

<h3 id="光栅化阶段rasterizer-stage">光栅化阶段（Rasterizer Stage）</h3>

<table>
  <thead>
    <tr>
      <th>阶段</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">7.三角形设定（Triangle Setup）</code>​</td>
      <td>此阶段主要是将从几何阶段得到的一个个顶点通过计算来得到一个个三角形网格</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">8.三角形遍历（Triangle Traversal）</code>​</td>
      <td>此阶段将进行逐像素遍历检查操作，以检查出该像素是否被上一步得到的三角形所覆盖，这个查找过程被称为三角形遍历</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">9.像素着色(Pixel Shading)</code>​</td>
      <td>对应于ShaderLab中的frag函数，主要目的是定义像素的最终输出颜色</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">10.混合（Merging）</code>​</td>
      <td>主要任务是合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色。此阶段还负责可见性问题（深度测试、模版测试等）的处理</td>
    </tr>
  </tbody>
</table>

<h3 id="shader-lab">Shader Lab</h3>

<table>
  <thead>
    <tr>
      <th>阶段</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">1.appdata</code>​</td>
      <td>将应用程序阶段的内容传递到顶点着色器中</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">2.vertex(顶点着色器)</code>​</td>
      <td>本地空间&gt;(本地到世界空间矩阵)&gt;世界空间&gt;(世界到观察空间矩阵)&gt;观察空间&gt;(投影矩阵)&gt;齐次裁剪空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">3.透视除法</code>​</td>
      <td>齐次裁剪空间作透视除法(clip.xyzw/clip.w)，变换到归一化设备坐标NDC</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">4.视口变换</code>​</td>
      <td>从NDC坐标变换到屏幕坐标</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">5.fragment(片断着色器)</code>​</td>
      <td>用从顶点着色器的输出来当输入进行逐片断的颜色计算并输出</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="platform-differences平台差异">Platform Differences（平台差异）</h2>

<h3 id="裁剪空间规范化立方体">裁剪空间(规范化立方体)</h3>

<table>
  <thead>
    <tr>
      <th>平台</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">OpenGL</code>​</td>
      <td>裁剪空间下坐标范围(-1,1)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">DirectX</code>​</td>
      <td>裁剪空间下坐标范围(1,0)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_NEAR_CLIP_VALUE</code>​</td>
      <td>裁剪空间下的近剪裁值，(DX为1,OpenGL为-1)</td>
    </tr>
  </tbody>
</table>

<h3 id="reversedz">ReversedZ</h3>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Reversed direction(反向方向)</code>​</td>
      <td>DirectX 11、DirectX 12、PS4、Xbox One、Metal这些平台都属于反向方向<br />深度值从近裁剪面到远裁剪面的值为[1 ~ 0]<br />裁剪空间下的Z轴范围为[near,0]</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Traditional direction(传统方向)</code>​</td>
      <td>除以上反向方向的平台以外都属于传统方向<br />深度值从近裁剪面到远裁剪面的值为[0 ~ 1]<br />裁剪空间下的Z轴范围为：<br />DX平台=[0,far]<br />OpenGL平台=[-near,far]</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_REVERSED_Z</code>​</td>
      <td>判断当前平台是否开启ReversedZ</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SystemInfo.usesReversedZBuffer</code>​</td>
      <td>利用C#判断当前平台是否支持ReversedZ</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="computer-shader计算着色器">Computer Shader（计算着色器）</h2>

<table>
  <thead>
    <tr>
      <th>内容</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SystemInfo.supportsComputeShaders</code>​</td>
      <td>C#中检测硬件是否支持Computer Shader。OpenGLES 3.1及以上支持Compute Shader</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma kernel CSMain SOME_DEFINE DEFINE_WITH_VALUE=1337</code>​</td>
      <td>声明执行函数为CSMain，可通过多行声明多个函数。SOME_DEFINE和DEFINE_WITH_VALUE是预定义宏，此项为可选项</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">ComputerShader.Dispatch(k,X,Y,Z)</code>​</td>
      <td>k表示要执行的核函数索引，XYZ表示开启X<em>Y</em>Z个线程组，注意是组(每个组中会有具体的线程)!</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[numthreads(x,y,z)]</code>​</td>
      <td>每个线程组中的总线程数(x<em>y</em>z)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SV_GroupID</code>​</td>
      <td>当前线程所在的线程组ID。[(0,0,0)~(X-1,Y-1,Z-1)]</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SV_GroupThreadID</code>​</td>
      <td>当前线程在所在线程组内的ID。[(0,0,0)~(x-1,y-1,z-1)]</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SV_DispatchThreadID</code>​</td>
      <td>当前线程的全局唯一ID。值为线程组*线程数+当前线程，是个三维坐标</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SV_GroupIndex</code>​</td>
      <td>当前线程在所在线程内的下标，int类型。[0~X<em>Y</em>Z-1]</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="glslopengl着色语言">GLSL（OpenGL着色语言）</h2>

<h3 id="基本类型">基本类型</h3>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">void</code>​</td>
      <td>空类型，即不返回任何值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">bool</code>​</td>
      <td>布尔类型，即真或者假，true false</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">int</code>​</td>
      <td>带符号的整数</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float</code>​</td>
      <td>带符号的浮点数</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">vec2,vec3,vec4</code>​</td>
      <td>n维浮点数向量</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">bvec2,bvec3,bvec4</code>​</td>
      <td>n维布尔向量</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">ivec2,ivec3,ivec4</code>​</td>
      <td>n维向整数向量</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">mat2,mat3,mat4</code>​</td>
      <td>2x2,3x3,4x4浮点数矩阵</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">clamp(a,min,max)</code>​</td>
      <td>将a限制在min和max之间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">sampler2D</code>​</td>
      <td>2D纹理</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">samplerCube</code>​</td>
      <td>立方体纹理</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="other其他语法">Other（其他语法）</h2>

<h3 id="内置渲染管线">内置渲染管线</h3>

<table>
  <thead>
    <tr>
      <th>语法</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">CGPROGRAM/ENDCG</code>​</td>
      <td>cg代码的开始与结束</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">CGINCLUDE/ENDCG</code>​</td>
      <td>通常用于定义多段vert/frag函数，然后这段CG代码会插入到所有Pass的CG中，根据当前Pass的设置来选择加载</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Fallback "name"</code>​</td>
      <td>备胎，当Shader中没有任何SubShader可执行时，则执行FallBack。默认值为Off，表示没有备胎。示例:FallBack “Diffuse”</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">GrabPass</code>​</td>
      <td>GrabPass{} 抓取当前屏幕存储到_GrabTexture中，每个有此命令的Shader都会每帧执行<br />GrabPass { “TextureName” } 抓取当前屏幕存储到自定义的TextureName中，每帧中只有第一个拥有此命令的Shader执行一次<br />GrabPass也支持Name与Tags</td>
    </tr>
  </tbody>
</table>

<h3 id="urp渲染管线">URP渲染管线</h3>

<table>
  <thead>
    <tr>
      <th>语法</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">include</code>​</td>
      <td>​<code class="language-plaintext highlighter-rouge">#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl"#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"</code>​</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">CBUFFER_START(UnityPerMaterial)/CBUFFER_END</code>​</td>
      <td>将材质属性面板中的变量定义在这个常量缓冲区中，用于支持SRP Batcher</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">HLSLPROGRAM/ENDHLSL</code>​</td>
      <td>HLSL代码的开始与结束</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">HLSLINCLUDE/ENDHLSL</code>​</td>
      <td>通常用于定义多段vert/frag函数，然后这段CG代码会插入到所有Pass的CG中，根据当前Pass的设置来选择加载</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Fallback "name"</code>​</td>
      <td>备胎，当Shader中没有任何SubShader可执行时，则执行FallBack。默认值为Off，表示没有备胎。比如URP下默认的紫色报错Shader:Fallback “Hidden/Universal Render Pipeline/FallbackError”</td>
    </tr>
  </tbody>
</table>

<h3 id="通用语法">通用语法</h3>

<table>
  <thead>
    <tr>
      <th>语法</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">LOD</code>​</td>
      <td>Shader LOD，可利用脚本来控制LOD级别，通常用于不同配置显示不同的SubShader。注意SubShader要从高往低写，要不然会无法生效</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Category{}</code>​</td>
      <td>定义一组所有SubShader共享的命令，位于SubShader外面</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">CustomEditor "name"</code>​</td>
      <td>自定义材质面板，name为自定义的脚本名称。可利用此功能对材质面板进行个性化自定义</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Name "MyPassName"</code>​</td>
      <td>给当前Pass指定名称，以便利用UsePass进行调用</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UsePass "Shader/NAME"</code>​</td>
      <td>调用其它Shader中的Pass，注意Pass的名称要全部大写！Shader的路径也要写全，以便能找到具体是哪个Shader的哪个Pass。另外加了UsePass后，也要注意相应的Properties要自行添加</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="substance-painter材质绘制">Substance Painter（材质绘制）</h2>

<h3 id="参考网址">参考网址</h3>

<table>
  <thead>
    <tr>
      <th>内容</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">URL</code>​</td>
      <td>https://substance3d.adobe.com/documentation/spdoc/shader-api-89686018.html</td>
    </tr>
  </tbody>
</table>

<h3 id="材质参数">材质参数</h3>

<h4 id="颜色rgb">颜色(RGB)</h4>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="c1">//: param custom {"default":[1,0.9568,0.8392],"label":"灯光颜色(RGB)","widget":"color","group":"灯光","description":"tooltip在这里"}</span>
<span class="k">uniform</span> <span class="kt">vec3</span> <span class="n">_LightColor</span><span class="p">;</span>
<span class="k">uniform</span> <span class="kt">vec4</span> <span class="n">_BaseColor</span><span class="p">;(</span><span class="err">当为</span><span class="mi">4</span><span class="err">维颜色时</span><span class="p">,</span><span class="n">alpha</span><span class="err">会变成滑条</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="整型">整型</h4>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="c1">//: param custom { "default": 0, "label": "Int","min": 0, "max": 10,"step": 1,"group":"Int" }</span>
<span class="k">uniform</span> <span class="kt">int</span> <span class="n">u_int1</span><span class="p">;</span>
<span class="k">uniform</span> <span class="kt">ivec2</span> <span class="n">u_int2</span><span class="p">;</span>
<span class="k">uniform</span> <span class="kt">ivec3</span> <span class="n">u_int3</span><span class="p">;</span>
<span class="k">uniform</span> <span class="kt">ivec4</span> <span class="n">u_int4</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="浮点值">浮点值</h4>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="c1">//: param custom { "default": 1, "label": "Float", "min": 0, "max": 2,"step": 0.1,"group":"Float" }</span>
<span class="k">uniform</span> <span class="kt">float</span> <span class="n">u_float1</span><span class="p">;</span>
<span class="k">uniform</span> <span class="kt">vec2</span> <span class="n">u_float2</span><span class="p">;</span>
<span class="k">uniform</span> <span class="kt">vec3</span> <span class="n">u_float3</span><span class="p">;</span>
<span class="k">uniform</span> <span class="kt">vec4</span> <span class="n">u_float4</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="开关">开关</h4>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="c1">//: param custom { "default": false, "label": "Boolean","group":"Toogle" }</span>
<span class="k">uniform</span> <span class="kt">bool</span> <span class="n">u_bool</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="枚举">枚举</h4>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="c1">//: param custom {</span>
<span class="c1">//:   "default": -1,</span>
<span class="c1">//:   "label": "Combobox",</span>
<span class="c1">//:   "widget": "combobox",</span>
<span class="c1">//:   "values": {</span>
<span class="c1">//:     "Value -1": -1,</span>
<span class="c1">//:     "Value 0": 0,</span>
<span class="c1">//:     "Value 10": 10</span>
<span class="c1">//:   },</span>
<span class="c1">//:   "group":"Enum"</span>
<span class="c1">//: }</span>
<span class="k">uniform</span> <span class="kt">int</span> <span class="n">u_combobox</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="自定义纹理">自定义纹理</h4>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="c1">//: param custom { "default": "", "default_color": [1.0, 1.0, 1.0, 1.0], "label": "Texture","usage": "texture","group":"Texture" }</span>
<span class="c1">//: param custom { "default": "", "label": "Texture","usage": "environment","group":"Texture" }</span>
<span class="k">uniform</span> <span class="kt">sampler2D</span> <span class="n">u_sampler1</span><span class="p">;</span>
<span class="kt">vec4</span> <span class="n">tex</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">u_sampler1</span><span class="p">,</span> <span class="n">inputs</span><span class="p">.</span><span class="n">tex_coord</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="内置通道图">内置通道图</h4>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre><span class="c1">//: param auto channel_basecolor</span>
<span class="c1">//: param auto channel_ambientocclusion</span>
<span class="c1">//: param auto channel_anisotropyangle</span>
<span class="c1">//: param auto channel_anisotropylevel</span>
<span class="c1">//: param auto channel_blendingmask</span>
<span class="c1">//: param auto channel_diffuse</span>
<span class="c1">//: param auto channel_displacement</span>
<span class="c1">//: param auto channel_emissive</span>
<span class="c1">//: param auto channel_glossiness</span>
<span class="c1">//: param auto channel_height</span>
<span class="c1">//: param auto channel_ior</span>
<span class="c1">//: param auto channel_metallic</span>
<span class="c1">//: param auto channel_normal</span>
<span class="c1">//: param auto channel_opacity</span>
<span class="c1">//: param auto channel_reflection</span>
<span class="c1">//: param auto channel_roughness</span>
<span class="c1">//: param auto channel_scattering</span>
<span class="c1">//: param auto channel_specular</span>
<span class="c1">//: param auto channel_specularlevel</span>
<span class="c1">//: param auto channel_transmissive</span>
<span class="k">uniform</span> <span class="n">SamplerSparse</span> <span class="n">channel_tex</span><span class="p">;</span>
<span class="kt">vec4</span> <span class="n">tex</span> <span class="o">=</span> <span class="n">textureSparse</span><span class="p">(</span><span class="n">channel_basecolor</span><span class="p">,</span><span class="n">i</span><span class="p">.</span><span class="n">sparse_coord</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="用户自定义通道图">用户自定义通道图</h4>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="c1">//: param auto channel_user0</span>
<span class="c1">//: param auto channel_user1</span>
<span class="c1">//: param auto channel_user2</span>
<span class="c1">//: param auto channel_user3</span>
<span class="c1">//: param auto channel_user4</span>
<span class="c1">//: param auto channel_user5</span>
<span class="c1">//: param auto channel_user6</span>
<span class="c1">//: param auto channel_user7</span>
<span class="k">uniform</span> <span class="n">SamplerSparse</span> <span class="n">channel_userTex</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="模型纹理">模型纹理</h4>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="c1">//: param auto texture_ambientocclusion (AO)</span>
<span class="c1">//: param auto texture_curvature (曲率)</span>
<span class="c1">//: param auto texture_id (ID图)</span>
<span class="c1">//: param auto texture_normal (切线空间下的法线纹理)</span>
<span class="c1">//: param auto texture_normal_ws (世界空间下的法线纹理)</span>
<span class="c1">//: param auto texture_position (世界空间下的位置纹理)</span>
<span class="c1">//: param auto texture_thickness (厚度纹理)</span>
<span class="k">uniform</span> <span class="kt">sampler2D</span> <span class="n">u_meshTexture</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="片断输出">片断输出</h3>

<table>
  <thead>
    <tr>
      <th>输出</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">最终输出(emissiveColorOutput + albedoOutput * diffuseShadingOutput + specularShadingOutput)</code>​</td>
      <td>​<code class="language-plaintext highlighter-rouge">void alphaOutput(1);diffuseShadingOutput(vec3(0,0,0));specularShadingOutput(vec3(0,0,0));emissiveColorOutput(vec3(0,0,0));albedoOutput(vec3(1,1,1));sssCoefficientsOutput(vec4(0,0,0,0));</code>​</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="experience经验总结">Experience（经验总结）</h2>

<table>
  <thead>
    <tr>
      <th>经验</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">分支</code>​</td>
      <td>尽量不要使用if或者switch去做大量的分支，否则在部分机型上会卡到怀疑人生!</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Stencil</code>​</td>
      <td>红米9C上开启深度图同时Shader中启用Stencil时会导致资源显示不可见，关闭任一个即可解决</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="miscellaneous杂项技巧">Miscellaneous（杂项技巧）</h2>

<h3 id="ps中的混合公式ab为图层">PS中的混合公式（A、B为图层）</h3>

<table>
  <thead>
    <tr>
      <th>混合模式</th>
      <th>公式</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>正常</td>
      <td>​<code class="language-plaintext highlighter-rouge">A*(1-B.a)+B*(B.a)</code>​</td>
    </tr>
    <tr>
      <td>变暗</td>
      <td>​<code class="language-plaintext highlighter-rouge">min(A,B)</code>​</td>
    </tr>
    <tr>
      <td>变亮</td>
      <td>​<code class="language-plaintext highlighter-rouge">max(A,B)</code>​</td>
    </tr>
    <tr>
      <td>正片叠底</td>
      <td>​<code class="language-plaintext highlighter-rouge">A*B</code>​</td>
    </tr>
    <tr>
      <td>滤色</td>
      <td>​<code class="language-plaintext highlighter-rouge">1-((1-A)*(1-B))</code>​</td>
    </tr>
    <tr>
      <td>颜色加深</td>
      <td>​<code class="language-plaintext highlighter-rouge">A-((1-A)*(1-B))/B</code>​</td>
    </tr>
    <tr>
      <td>颜色减淡</td>
      <td>​<code class="language-plaintext highlighter-rouge">A+(A*B)/(1-B)</code>​</td>
    </tr>
    <tr>
      <td>线性加深</td>
      <td>​<code class="language-plaintext highlighter-rouge">A+B-1</code>​</td>
    </tr>
    <tr>
      <td>线性减淡</td>
      <td>​<code class="language-plaintext highlighter-rouge">A+B</code>​</td>
    </tr>
    <tr>
      <td>叠加</td>
      <td>​<code class="language-plaintext highlighter-rouge">half4 a = step(A,0.5);half4 c = a*A*B*2+(1-a)*(1-(1-A)*(1-B)*2);</code>​</td>
    </tr>
    <tr>
      <td>强光</td>
      <td>​<code class="language-plaintext highlighter-rouge">half4 a = step(B,0.5);half4 c =a*A*B*2+(1-a)*(1-(1-A)*(1-B)*2);</code>​</td>
    </tr>
    <tr>
      <td>柔光</td>
      <td>​<code class="language-plaintext highlighter-rouge">half4 a = step(B,0.5);half4 c =a*(A*B*2+A*A*(1-B*2))+(1-a)*(A*(1-B)*2+sqrt(A)*(2*B-1)</code>​</td>
    </tr>
    <tr>
      <td>亮光</td>
      <td>​<code class="language-plaintext highlighter-rouge">half4 a = step(B,0.5);half4 c =a*(A-(1-A)*(1-2*B)/(2*B))+(1-a)*(A+A*(2*B-1)/(2*(1-B)));</code>​</td>
    </tr>
    <tr>
      <td>点光</td>
      <td>​<code class="language-plaintext highlighter-rouge">half4 a = step(B,0.5);half4 c =a*(min(A,2*B))+(1-a)*(max(A,( B*2-1)));</code>​</td>
    </tr>
    <tr>
      <td>线性光</td>
      <td>​<code class="language-plaintext highlighter-rouge">A+2*B-1</code>​</td>
    </tr>
    <tr>
      <td>排除</td>
      <td>​<code class="language-plaintext highlighter-rouge">A+B-A*B*2</code>​</td>
    </tr>
    <tr>
      <td>差值</td>
      <td>​<code class="language-plaintext highlighter-rouge">abs(A-B)</code>​</td>
    </tr>
    <tr>
      <td>深色</td>
      <td>​<code class="language-plaintext highlighter-rouge">half4 a = step(B.r+B.g+B.b,A.r+A.g+A.b);half4 c =a*(B)+(1-a)*(A);</code>​</td>
    </tr>
    <tr>
      <td>浅色</td>
      <td>​<code class="language-plaintext highlighter-rouge">half4 a = step(B.r+B.g+B.b,A.r+A.g+A.b);half4 c =a*(A)+(1-a)*(B);</code>​</td>
    </tr>
    <tr>
      <td>减去</td>
      <td>​<code class="language-plaintext highlighter-rouge">A-B</code>​</td>
    </tr>
    <tr>
      <td>划分</td>
      <td>​<code class="language-plaintext highlighter-rouge">A/B</code>​</td>
    </tr>
  </tbody>
</table>

<h3 id="uv技巧">UV技巧</h3>

<table>
  <thead>
    <tr>
      <th>技巧</th>
      <th>代码</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>UV重映射到中心位置</td>
      <td>​<code class="language-plaintext highlighter-rouge">float2 centerUV = uv * 2 - 1</code>​</td>
    </tr>
    <tr>
      <td>画圆</td>
      <td>​<code class="language-plaintext highlighter-rouge">float circle = smoothstep(_Radius, (_Radius + _CircleFade), length(uv * 2 - 1));</code>​</td>
    </tr>
    <tr>
      <td>画矩形</td>
      <td>​<code class="language-plaintext highlighter-rouge">float2 centerUV = abs(i.uv.xy * 2 - 1);float rectangleX = smoothstep(_Width, (_Width + _RectangleFade), centerUV.x);float rectangleY = smoothstep(_Heigth, (_Heigth + _RectangleFade), centerUV.y);float rectangleClamp = clamp((rectangleX + rectangleY), 0.0, 1.0);</code>​</td>
    </tr>
    <tr>
      <td>黑白棋盘格</td>
      <td>​<code class="language-plaintext highlighter-rouge">float2 uv = i.uv * 格子密度;uv = floor(uv) * 0.5;float c = frac(uv.x + uv.y) * 2;return c;</code>​</td>
    </tr>
    <tr>
      <td>蜂窝格</td>
      <td>​<code class="language-plaintext highlighter-rouge">float2 uv = i.uv * 格子密度;uv.y += floor(uv.x) * 0.5;uv = fmod(uv,1);uv = uv*2-1;uv = abs(uv);float d = max((uv.x*0.9+uv.y*0.5),uv.y);d = step(d,_Size);return d;</code>​</td>
    </tr>
    <tr>
      <td>极坐标</td>
      <td>​<code class="language-plaintext highlighter-rouge">float2 centerUV = (i.uv * 2 - 1);float atan2UV = 1 - abs(atan2(centerUV.g, centerUV.r) / 3.14);</code>​</td>
    </tr>
    <tr>
      <td>将0-1的值控制在某个自定义的区间内</td>
      <td>​<code class="language-plaintext highlighter-rouge">frac(x*n+n);</code>​</td>
    </tr>
    <tr>
      <td>旋转</td>
      <td>​<code class="language-plaintext highlighter-rouge">fixed t=_Time.y;float2 rot= cos(t)*i.uv+sin(t)*float2(i.uv.y,-i.uv.x);</code>​</td>
    </tr>
    <tr>
      <td>从中心缩放纹理</td>
      <td>​<code class="language-plaintext highlighter-rouge">half2 offset = (0.5-i.uv.xy)*_Offset;half4 baseMap = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv.xy + offset);</code>​</td>
    </tr>
    <tr>
      <td>序列图</td>
      <td>​<code class="language-plaintext highlighter-rouge">float2 splitUV = uv * (1/_Sequence.xy) + float2(0,_Sequence.y - 1/_Sequence.y);float time = _Time.y * _Sequence.z;uv = splitUV + float2(floor(time *_Sequence.x)/_Sequence.x,1-floor(time)/_Sequence.y);</code>​</td>
    </tr>
  </tbody>
</table>

<h3 id="顶点技巧">顶点技巧</h3>

<table>
  <thead>
    <tr>
      <th>技巧</th>
      <th>代码</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>模型中心点坐标</td>
      <td>​<code class="language-plaintext highlighter-rouge">float3 objCenterPos = mul( unity_ObjectToWorld, float4( 0, 0, 0, 1 ) ).xyz;</code>​</td>
    </tr>
    <tr>
      <td>获取模型的旋转角度(Y轴)</td>
      <td>​<code class="language-plaintext highlighter-rouge">float cosA = unity_ObjectToWorld._11;float sinA = unity_ObjectToWorld._13;float angle = atan2(sinA, cosA);angle *= 180 / 3.1415926;if (angle &lt; 0) angle += 360;</code>​</td>
    </tr>
    <tr>
      <td>BillBoard</td>
      <td>在顶点着色器中添加相机空间转换代码</td>
    </tr>
    <tr>
      <td>网格阴影</td>
      <td>​<code class="language-plaintext highlighter-rouge">half4 worldPos = mul(unity_ObjectToWorld, v.vertex);worldPos.y = 2.47;worldPos.xz += fixed2(阴影X方向,阴影Z方向)*v.vertex.y;o.pos = mul(UNITY_MATRIX_VP,worldPos);</code>​</td>
    </tr>
  </tbody>
</table>

<h3 id="颜色技巧">颜色技巧</h3>

<table>
  <thead>
    <tr>
      <th>技巧</th>
      <th>代码</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>去色</td>
      <td>​<code class="language-plaintext highlighter-rouge">dot(rgb,fixed3(0.22,0.707,0.071))</code>​</td>
    </tr>
    <tr>
      <td>RGB2HSV</td>
      <td>使用专门的转换函数</td>
    </tr>
    <tr>
      <td>HSV2RGB</td>
      <td>使用专门的转换函数</td>
    </tr>
    <tr>
      <td>利用HSV对颜色进行调整</td>
      <td>​<code class="language-plaintext highlighter-rouge">half3 hsv = RGB2HSV(baseMap.rgb);baseMap.rgb = HSV2RGB(float3((hsv.x + _HSVValue.x), (hsv.y * _HSVValue.y), (hsv.z * _HSVValue.z)));</code>​</td>
    </tr>
    <tr>
      <td>随机(单通道)</td>
      <td>​<code class="language-plaintext highlighter-rouge">frac(sin(dot(uv, float2(127.1, 311.7))) * 43758.5453);</code>​</td>
    </tr>
    <tr>
      <td>随机(三通道)</td>
      <td>​<code class="language-plaintext highlighter-rouge">float3 q = float3(dot(p,float2(127.1,311.7)),dot(p,float2(269.5,183.3)),dot(p,float2(419.2,371.9)));return frac(sin(q)*43758.5453);</code>​</td>
    </tr>
  </tbody>
</table>

<h3 id="深度技巧">深度技巧</h3>

<table>
  <thead>
    <tr>
      <th>技巧</th>
      <th>代码</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>从深度重建世界坐标</td>
      <td>​<code class="language-plaintext highlighter-rouge">float2 screenUV = i.positionCS/_ScreenParams.xy;half depthMap = SAMPLE_TEXTURE2D(_CameraDepthTexture, sampler_CameraDepthTexture, screenUV).r;float3 positionWS = ComputeWorldSpacePosition(screenUV, depth, UNITY_MATRIX_I_VP);</code>​</td>
    </tr>
  </tbody>
</table>

<h3 id="光照技巧">光照技巧</h3>

<table>
  <thead>
    <tr>
      <th>技巧</th>
      <th>代码</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Matcap</td>
      <td>​<code class="language-plaintext highlighter-rouge">o.normalWS = TransformObjectToWorldNormal(v.normalOS);o.uv.zw = mul(UNITY_MATRIX_V, float4(o.normalWS, 0.0)).xy * 0.5 + 0.5;</code>​</td>
    </tr>
  </tbody>
</table>

<h3 id="其他技巧">其他技巧</h3>

<table>
  <thead>
    <tr>
      <th>技巧</th>
      <th>代码</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>菲涅尔</td>
      <td>​<code class="language-plaintext highlighter-rouge">half3 worldViewDir = normalize (UnityWorldSpaceViewDir (i.worldPos));float ndotv = dot (i.normal, worldViewDir);float fresnel = (0.2 + 2.0 * pow (1.0 - ndotv, 2.0));</code>​</td>
    </tr>
    <tr>
      <td>XRay射线</td>
      <td>新建一个Pass，设置Blend，Zwrite Off关闭深度写入，Ztest greater深度测试设置为大于</td>
    </tr>
    <tr>
      <td>Dither</td>
      <td>使用专门的Dither函数（2x2、4x4、8x8）</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="总结">总结</h2>

<p>这个完整的Unity Shader参考文档涵盖了：</p>

<ol>
  <li><strong>Semantics（语义）</strong>  - 数据传递的关键字</li>
  <li><strong>Properties（属性）</strong>  - 材质面板中的可调参数</li>
  <li><strong>Math（数学运算）</strong>  - 常用的数学函数和运算</li>
  <li><strong>BuildIn Variables（内置变量）</strong>  - Unity提供的内置变量和函数</li>
  <li><strong>BuildIn Transformation（内置变换）</strong>  - 空间变换矩阵和方法</li>
  <li><strong>Lighting（光照）</strong>  - 各种光照模型和实现</li>
  <li><strong>Tags（标签）</strong>  - 渲染管线和队列控制</li>
  <li><strong>Pragma（编译指令）</strong>  - 编译控制和变体管理</li>
  <li><strong>Render State（渲染状态）</strong>  - 渲染状态设置</li>
  <li><strong>Transformation（空间变换）</strong>  - 详细的变换矩阵和方法</li>
  <li><strong>Predefined Macros（预定义宏）</strong>  - Unity预定义的宏</li>
  <li><strong>Pipeline（渲染管线）</strong>  - 渲染管线流程</li>
  <li><strong>Platform Differences（平台差异）</strong>  - 不同平台的差异</li>
  <li><strong>Computer Shader（计算着色器）</strong>  - 计算着色器相关内容</li>
  <li><strong>GLSL（OpenGL着色语言）</strong>  - GLSL语法</li>
  <li><strong>Other（其他语法）</strong>  - 其他shader语法</li>
  <li><strong>Substance Painter（材质绘制）</strong>  - Substance Painter中的shader语法</li>
  <li><strong>Experience（经验总结）</strong>  - 实际开发中的经验</li>
  <li><strong>Miscellaneous（杂项技巧）</strong>  - 实用的shader技巧和算法</li>
</ol>

<p>这个文档可以作为Unity Shader开发的完整参考手册，帮助开发者快速查找和使用各种shader功能。</p>]]></content><author><name></name></author><category term="shader" /><category term="unity" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Unity Shader 参考文档 - 第三部分</title><link href="https://lixiao90s.github.io/post/unity-shader-reference-document-part-3-z2bufyb.html" rel="alternate" type="text/html" title="Unity Shader 参考文档 - 第三部分" /><published>2025-07-31T09:06:46+08:00</published><updated>2025-07-31T09:06:46+08:00</updated><id>https://lixiao90s.github.io/post/unity-shader-reference-document-part-3-z2bufyb</id><content type="html" xml:base="https://lixiao90s.github.io/post/unity-shader-reference-document-part-3-z2bufyb.html"><![CDATA[<hr />

<h2 id="pragma编译指令">Pragma（编译指令）</h2>

<h3 id="基础编译指令">基础编译指令</h3>

<table>
  <thead>
    <tr>
      <th>指令</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma target 2.0</code>​</td>
      <td>Shader编绎目标级别，默认值为2.5<br />• 2.0: 基础功能<br />• 2.5: derivatives<br />• 3.0: 2.5 + interpolators10 + samplelod + fragcoord<br />• 3.5: 3.0 + interpolators15 + mrt4 + integers + 2darray + instancing<br />• 4.0: 3.5 + geometry<br />• 4.5: 3.5 + compute + randomwrite<br />• 4.6: 4.0 + cubearray + tesshw + tessellation<br />• 5.0: 4.0 + compute + randomwrite + tesshw + tessellation</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma require xxx</code>​</td>
      <td>表明shader需要的特性功能<br />• interpolators10: 至少支持10个插值器<br />• interpolators15: 至少支持15个插值器<br />• interpolators32: 至少支持32个插值器<br />• mrt4: 至少支持4个Multiple Render Targets<br />• mrt8: 至少支持8个Multiple Render Targets<br />• derivatives: 片断着色器支持偏导函数(ddx/ddy)<br />• samplelod: 纹理LOD采样<br />• fragcoord: 将像素的位置传入到片断着色器中<br />• integers: 支持真正的整数类型<br />• 2darray: 2D纹理数组<br />• cubearray: Cubemap纹理数组<br />• instancing: GPU实例化<br />• geometry: 几何着色器<br />• compute: Compute Shader<br />• randomwrite: 可以编写任意位置的一些纹理和缓冲区</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma shader_feature</code>​</td>
      <td>变体声明，常用于不需要程序控制开关的关键字，在编缉器的材质上设置，打包时会自动过滤</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma shader_feature_local</code>​</td>
      <td>声明本地变体(shader_feature)，unity2019才支持的功能，每个Shader最多可以有64个本地变体</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma multi_compile</code>​</td>
      <td>变体声明，在打包时会把所有变体都打包进去，这是它与feature的区别</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma multi_compile_local</code>​</td>
      <td>声明本地变体(multi_compile)，unity2019才支持的功能</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma multi_compile_fog</code>​</td>
      <td>雾类型定义：FOG_EXP FOG_EXP2 FOG_LINEAR</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma skip_variants XXX01 XXX02...</code>​</td>
      <td>剔除指定的变体，可同时剔除多个</td>
    </tr>
  </tbody>
</table>

<h3 id="内置渲染管线特定指令">内置渲染管线特定指令</h3>

<table>
  <thead>
    <tr>
      <th>指令</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma multi_compile_fwdbase</code>​</td>
      <td>定义在LightMode = ForwardBase的Pass中，生成Unity在ForwardBase中需要的各种内置宏</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma multi_compile_fwdadd</code>​</td>
      <td>定义在LightMode=ForwardAdd的Pass中，生成Unity在ForwardAdd中需要的各种内置宏</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma multi_compile_shadowcaster</code>​</td>
      <td>定义在LightMode=ShadowCaster的Pass中，会自动生成SHADOWS_DEPTH和SHADOW_CUBE宏</td>
    </tr>
  </tbody>
</table>

<h3 id="urp特定指令">URP特定指令</h3>

<table>
  <thead>
    <tr>
      <th>指令</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma prefer_hlslcc gles</code>​</td>
      <td>将HLSL代码转换为GLSL代码时，优先使用HLSLcc转换器</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#include "XXX.hlsl"</code>​</td>
      <td>引入hlsl文件</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#include_with_pragmas "XXX.hlsl"</code>​</td>
      <td>引入hlsl文件，同时也会使用hlsl文件中的#pragma指令</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma editor_sync_compilation</code>​</td>
      <td>强制某个Shader以同步的方式进行编绎</td>
    </tr>
  </tbody>
</table>

<h3 id="平台相关指令">平台相关指令</h3>

<table>
  <thead>
    <tr>
      <th>指令</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma only_renderers</code>​</td>
      <td>仅编译指定平台的Shader<br />• d3d11 - Direct3D 11/12<br />• glcore - OpenGL 3.x/4.x<br />• gles - OpenGL ES 2.0<br />• gles3 - OpenGL ES 3.x<br />• metal - iOS/Mac Metal<br />• vulkan - Vulkan<br />• d3d11_9x - Direct3D 11 9.x功能级别<br />• xboxone - Xbox One<br />• ps4 - PlayStation 4<br />• psp2 - PlayStation Vita<br />• n3ds - Nintendo 3DS<br />• wiiu - Nintendo Wii U</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma exclude_renderers</code>​</td>
      <td>剔除掉指定平台的相关代码</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma once</code>​</td>
      <td>通常添加在通用的.hlsl文件中，以此来避免多次或者重复引用和编绎</td>
    </tr>
  </tbody>
</table>

<h3 id="其他指令">其他指令</h3>

<table>
  <thead>
    <tr>
      <th>指令</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#define NAME</code>​</td>
      <td>定义一个叫NAME的字段</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#define NAME 1</code>​</td>
      <td>定义一个叫NAME的字段并且它的值为1</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#error xxx</code>​</td>
      <td>多用于分支的判断中，利用此语句可直接输出一条报错信息</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma fragmentoption ARB_precision_hint_fastest</code>​</td>
      <td>最快的，意思就是会用低精度</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma fragmentoption ARB_precision_hint_nicest</code>​</td>
      <td>最佳的，会用高精度</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma enable_d3d11_debug_symbols</code>​</td>
      <td>开启调试，便于在调试工具中进行查看分析</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma skip_optimizations &lt;gles/vulkan...&gt;</code>​</td>
      <td>调试用，禁用某平台的优化</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#pragma shader_feature EDITOR_VISUALIZATION</code>​</td>
      <td>开启Material Validation，Scene视图中的模式</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="render-state渲染状态">Render State（渲染状态）</h2>

<h3 id="cull背面剔除">Cull（背面剔除）</h3>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">Cull</span> <span class="n">Back</span> <span class="o">|</span> <span class="n">Front</span> <span class="o">|</span> <span class="n">Off</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><strong>Back</strong>: 表示剔除背面，也就是显示正面，这也是最常用的设置</li>
  <li><strong>Front</strong>: 表示剔除前面，只显示背面</li>
  <li><strong>Off</strong>: 表示关闭剔除，也就是正反面都渲染</li>
</ul>

<h3 id="模版测试stencil">模版测试（Stencil）</h3>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="n">Stencil</span>
<span class="p">{</span>
    <span class="n">Ref</span> <span class="p">[</span><span class="n">_Stencil</span><span class="p">]</span>
    <span class="n">ReadMask</span> <span class="p">[</span><span class="n">_StencilReadMask</span><span class="p">]</span>
    <span class="n">WriteMask</span> <span class="p">[</span><span class="n">_StencilWriteMask</span><span class="p">]</span>
    <span class="n">Comp</span> <span class="p">[</span><span class="n">_StencilComp</span><span class="p">]</span>
    <span class="n">Pass</span> <span class="p">[</span><span class="n">_StencilOp</span><span class="p">]</span>
    <span class="n">Fail</span> <span class="p">[</span><span class="n">_Fail</span><span class="p">]</span>
    <span class="n">ZFail</span> <span class="p">[</span><span class="n">_ZFail</span><span class="p">]</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="comp比较操作">Comp（比较操作）</h4>

<table>
  <thead>
    <tr>
      <th>操作</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Less</code>​</td>
      <td>相当于”&lt;”操作，即仅当左边&lt;右边，模板测试通过，渲染像素</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Greater</code>​</td>
      <td>相当于”&gt;”操作，即仅当左边&gt;右边，模板测试通过，渲染像素</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Lequal</code>​</td>
      <td>相当于”&lt;=”操作，即仅当左边&lt;=右边，模板测试通过，渲染像素</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Gequal</code>​</td>
      <td>相当于”&gt;=”操作，即仅当左边&gt;=右边，模板测试通过，渲染像素</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Equal</code>​</td>
      <td>相当于”=”操作，即仅当左边=右边，模板测试通过，渲染像素</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">NotEqual</code>​</td>
      <td>相当于”!=”操作，即仅当左边!=右边，模板测试通过，渲染像素</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Always</code>​</td>
      <td>不管公式两边为何值，模板测试总是通过，渲染像素</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Never</code>​</td>
      <td>不管公式两边为何值，模板测试总是失败，像素被抛弃</td>
    </tr>
  </tbody>
</table>

<h4 id="模版缓冲区的更新">模版缓冲区的更新</h4>

<table>
  <thead>
    <tr>
      <th>操作</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Keep</code>​</td>
      <td>保留当前缓冲中的内容，即stencilBufferValue不变</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Zero</code>​</td>
      <td>将0写入缓冲，即stencilBufferValue值变为0</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Replace</code>​</td>
      <td>将参考值写入缓冲，即将referenceValue赋值给stencilBufferValue</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">IncrSat</code>​</td>
      <td>将当前模板缓冲值加1，如果stencilBufferValue超过255了，那么保留为255</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">DecrSat</code>​</td>
      <td>将当前模板缓冲值减1，如果stencilBufferValue超过为0，那么保留为0</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Invert</code>​</td>
      <td>将当前模板缓冲值（stencilBufferValue）按位取反</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">IncrWrap</code>​</td>
      <td>当前缓冲的值加1，如果缓冲值超过255了，那么变成0</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">DecrWrap</code>​</td>
      <td>当前缓冲的值减1，如果缓冲值已经为0，那么变成255</td>
    </tr>
  </tbody>
</table>

<h3 id="深度缓冲">深度缓冲</h3>

<p>|设置|描述|
| ————–| ———————————————————————————————|
|<code class="language-plaintext highlighter-rouge">ZTest (Less|Greater|
|​</code>ZTest[unity_GUIZTestMode]<code class="language-plaintext highlighter-rouge">​|unity_GUIZTestMode用于UI材质中，此值默认为LEqual，仅当UI中Canvas模式为Overlay时，值为Always|
|</code>ZWrite On|Off<code class="language-plaintext highlighter-rouge">|
|</code>ZClip True|False<code class="language-plaintext highlighter-rouge">|
|​</code>Offset Factor, Units`​|深度偏移，offset = (m * factor) + (r * units)，默认值为0,0|</p>

<h3 id="颜色遮罩">颜色遮罩</h3>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">ColorMask</span> <span class="n">RGB</span> <span class="o">|</span> <span class="n">A</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">|</span> <span class="n">R</span><span class="err">、</span><span class="n">G</span><span class="err">、</span><span class="n">B</span><span class="err">、</span><span class="n">A</span><span class="err">的任意组合</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>颜色遮罩，默认值为：RGBA，表示写入RGBA四个通道。</p>

<h3 id="混合blend">混合（Blend）</h3>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="err">源颜色</span><span class="o">*</span><span class="n">SrcFactor</span> <span class="o">+</span> <span class="err">目标颜色</span><span class="o">*</span><span class="n">DstFactor</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="混合因子">混合因子</h4>

<table>
  <thead>
    <tr>
      <th>因子</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">One</code>​</td>
      <td>源或目标的完整值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Zero</code>​</td>
      <td>0</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SrcColor</code>​</td>
      <td>源的颜色值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SrcAlpha</code>​</td>
      <td>源的Alpha值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">DstColor</code>​</td>
      <td>目标的颜色值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">DstAlpha</code>​</td>
      <td>目标的Alpha值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">OneMinusSrcColor</code>​</td>
      <td>1-源颜色得到的值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">OneMinusSrcAlpha</code>​</td>
      <td>1-源Alpha得到的值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">OneMinusDstColor</code>​</td>
      <td>1-目标颜色得到的值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">OneMinusDstAlpha</code>​</td>
      <td>1-目标Alpha得到的值</td>
    </tr>
  </tbody>
</table>

<h4 id="常用的几种混合类型">常用的几种混合类型</h4>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="n">Blend</span> <span class="n">SrcAlpha</span> <span class="n">OneMinusSrcAlpha</span>  <span class="c1">// Traditional transparency</span>
<span class="n">Blend</span> <span class="n">One</span> <span class="n">OneMinusSrcAlpha</span>       <span class="c1">// Premultiplied transparency</span>
<span class="n">Blend</span> <span class="n">One</span> <span class="n">One</span>                     <span class="c1">// Additive</span>
<span class="n">Blend</span> <span class="n">OneMinusDstColor</span> <span class="n">One</span>       <span class="c1">// Soft Additive</span>
<span class="n">Blend</span> <span class="n">DstColor</span> <span class="n">Zero</span>              <span class="c1">// Multiplicative</span>
<span class="n">Blend</span> <span class="n">DstColor</span> <span class="n">SrcColor</span>          <span class="c1">// 2x Multiplicative</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="混合操作的具体运算符">混合操作的具体运算符</h4>

<table>
  <thead>
    <tr>
      <th>操作</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Add</code>​</td>
      <td>源+目标</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Sub</code>​</td>
      <td>源-目标</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">RevSub</code>​</td>
      <td>目标-源</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Min</code>​</td>
      <td>源与目标中最小值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Max</code>​</td>
      <td>源与目标中最大值</td>
    </tr>
  </tbody>
</table>

<h3 id="其他">其他</h3>

<table>
  <thead>
    <tr>
      <th>设置</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">AlphaToMask On|Off</code></td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Conservative True|False</code></td>
      <td> </td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="transformation空间变换">Transformation（空间变换）</h2>

<h3 id="空间变换矩阵">空间变换(矩阵)</h3>

<table>
  <thead>
    <tr>
      <th>矩阵</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_M</code>​</td>
      <td>模型变换矩阵:unity_ObjectToWorld</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_I_M</code>​</td>
      <td>模型变换逆矩阵:unity_WorldToObject</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_V</code>​</td>
      <td>视图变换矩阵:unity_MatrixV</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_I_V</code>​</td>
      <td>视图变换逆矩阵:unity_MatrixInvV</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_P</code>​</td>
      <td>投影变换矩阵:OptimizeProjectionMatrix(glstate_matrix_projection)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_I_P</code>​</td>
      <td>投影变换逆矩阵:ERROR_UNITY_MATRIX_I_P_IS_NOT_DEFINED</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_VP</code>​</td>
      <td>视图投影变换矩阵:unity_MatrixVP</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_I_VP</code>​</td>
      <td>视图投影变换逆矩阵:_InvCameraViewProj</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_MV</code>​</td>
      <td>模型视图变换矩阵:mul(UNITY_MATRIX_V, UNITY_MATRIX_M)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_T_MV</code>​</td>
      <td>模型视图变换转置矩阵:transpose(UNITY_MATRIX_MV)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_IT_MV</code>​</td>
      <td>模型视图变换转置逆矩阵:transpose(mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V))</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_MVP</code>​</td>
      <td>模型视图投影变换矩阵:mul(UNITY_MATRIX_VP, UNITY_MATRIX_M)</td>
    </tr>
  </tbody>
</table>

<h3 id="空间变换方法">空间变换(方法)</h3>

<h4 id="内置渲染管线">内置渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UnityObjectToClipPos(v.vertex)</code>​</td>
      <td>将模型空间下的顶点转换到齐次裁剪空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UnityObjectToWorldNormal(v.normal)</code>​</td>
      <td>将模型空间下的法线转换到世界空间(已归一化)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UnityObjectToWorldDir (v.tangent)</code>​</td>
      <td>将模型空间下的切线转换到世界空间(已归一化)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UnityWorldSpaceLightDir (i.worldPos)</code>​</td>
      <td>世界空间下顶点到灯光方向的向量(未归一化)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UnityWorldSpaceViewDir (i.worldPos)</code>​</td>
      <td>世界空间下顶点到视线方向的向量(未归一化)</td>
    </tr>
  </tbody>
</table>

<h4 id="urp渲染管线">URP渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float3 TransformObjectToWorld(float3 positionOS)</code>​</td>
      <td>模型空间»世界空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float3 TransformWorldToObject(float3 positionWS)</code>​</td>
      <td>世界空间»模型空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float3 TransformWorldToView(float3 positionWS)</code>​</td>
      <td>世界空间»视图空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 TransformObjectToHClip(float3 positionOS)</code>​</td>
      <td>模型空间»齐次裁剪空间 (比MVP高效)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 TransformWorldToHClip(float3 positionWS)</code>​</td>
      <td>世界空间»齐次裁剪空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 TransformWViewToHClip(float3 positionVS)</code>​</td>
      <td>视图空间»齐次裁剪空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">real3 TransformObjectToWorldDir(real3 dirOS)</code>​</td>
      <td>(向量)模型空间»世界空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">real3 TransformWorldToObjectDir(real3 dirWS)</code>​</td>
      <td>(向量)世界空间»模型空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">real3 TransformWorldToViewDir(real3 dirWS)</code>​</td>
      <td>(向量)世界空间»视图空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">real3 TransformWorldToHClipDir(real3 directionWS)</code>​</td>
      <td>(向量)世界空间&gt;齐次裁剪空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float3 TransformObjectToWorldNormal(float3 normalOS)</code>​</td>
      <td>(法线)模型空间»世界空间(已归一化)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float3 TransformWorldToObjectNormal(float3 normalWS)</code>​</td>
      <td>(法线)世界空间»模型空间(已归一化)</td>
    </tr>
  </tbody>
</table>

<h3 id="基础变换矩阵">基础变换矩阵</h3>

<table>
  <thead>
    <tr>
      <th>矩阵类型</th>
      <th>矩阵定义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>平移矩阵</td>
      <td>​<code class="language-plaintext highlighter-rouge">float4x4 M_translate = float4x4(    1, 0, 0, T.x,    0, 1, 0, T.y,    0, 0, 1, T.z,    0, 0, 0, 1);</code>​</td>
    </tr>
    <tr>
      <td>缩放矩阵</td>
      <td>​<code class="language-plaintext highlighter-rouge">float4x4 M_scale = float4x4(    S.x, 0, 0, 0,    0, S.y, 0, 0,    0, 0, S.z, 0,    0, 0, 0, 1);</code>​</td>
    </tr>
    <tr>
      <td>旋转矩阵(X轴)</td>
      <td>​<code class="language-plaintext highlighter-rouge">float4x4 M_rotationX = float4x4(    1, 0, 0, 0,    0, cos(θ), -sin(θ), 0,    0, sin(θ), cos(θ), 0,    0, 0, 0, 1);</code>​</td>
    </tr>
    <tr>
      <td>旋转矩阵(Y轴)</td>
      <td>​<code class="language-plaintext highlighter-rouge">float4x4 M_rotationY = float4x4(    cos(θ), 0, sin(θ), 0,    0, 1, 0, 0,    -sin(θ), 0, cos(θ), 0,    0, 0, 0, 1);</code>​</td>
    </tr>
    <tr>
      <td>旋转矩阵(Z轴)</td>
      <td>​<code class="language-plaintext highlighter-rouge">float4x4 M_rotationZ = float4x4(    cos(θ), -sin(θ), 0, 0,    sin(θ), cos(θ), 0, 0,    0, 0, 1, 0,    0, 0, 0, 1);</code>​</td>
    </tr>
  </tbody>
</table>

<h3 id="变换规则">变换规则</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>将P点从A空间变换到B空间
P_B = M_AB * P_A
     = (M_BA)^-1 * P_A
     = (M_BA)^T * P_A
</pre></td></tr></tbody></table></code></pre></div></div>

<hr />

<h2 id="predefined-macros预定义宏">Predefined Macros（预定义宏）</h2>

<h3 id="target-platform">Target platform</h3>

<table>
  <thead>
    <tr>
      <th>宏</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SHADER_API_D3D11</code>​</td>
      <td>Direct3D 11</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SHADER_API_GLCORE</code>​</td>
      <td>桌面OpenGL核心(GL3/4)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SHADER_API_GLES</code>​</td>
      <td>OpenGl ES 2.0</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SHADER_API_GLES3</code>​</td>
      <td>OpenGl ES 3.0/3.1</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SHADER_API_METAL</code>​</td>
      <td>IOS/Mac Metal</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SHADER_API_VULKAN</code>​</td>
      <td>Vulkan</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SHADER_API_D3D11_9X</code>​</td>
      <td>Direct3D 11 9.x功能级别</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SHADER_API_PS4</code>​</td>
      <td>PS4平台，SHADER_API_PSSL同时也会被定义</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SHADER_API_XBOXONE</code>​</td>
      <td>Xbox One</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SHADER_API_MOBILE</code>​</td>
      <td>所有移动平台(GLES/GLES3/METAL)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SHADER_API_DESKTOP</code>​</td>
      <td>Window、Mac和Linux桌面平台</td>
    </tr>
  </tbody>
</table>

<h3 id="流程控制">流程控制</h3>

<table>
  <thead>
    <tr>
      <th>宏</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#define UNITY_BRANCH [branch]</code>​</td>
      <td>添加在if语句上面，表示此语句会根据判断只执行符合条件的代码，有跳转指令</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#define UNITY_FLATTEN [flatten]</code>​</td>
      <td>添加在if语句上面，表示此语句会执行全部代码，然后根据条件来选择某个具体的结果，没有跳转指令</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#define UNITY_UNROLL [unroll]</code>​</td>
      <td>添加在for语句上面，表示此循环在编绎时会展开所有循环代码</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#define UNITY_UNROLLX(_x) [unroll(_x)]</code>​</td>
      <td>添加在for语句上面，功能同上，同时可以指定具体的展开次数</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#define UNITY_LOOP [loop]</code>​</td>
      <td>添加在for语句上面，表示此循环不可展开，正常执行跳转</td>
    </tr>
  </tbody>
</table>

<h3 id="shader-target-model">Shader target model</h3>

<table>
  <thead>
    <tr>
      <th>宏</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#if SHADER_TARGET &lt; 30</code>​</td>
      <td>对应于#pragma target的值，2.0就是20，3.0就是30</td>
    </tr>
  </tbody>
</table>

<h3 id="unity-version">Unity version</h3>

<table>
  <thead>
    <tr>
      <th>宏</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">#if UNITY_VERSION &gt;= 500</code>​</td>
      <td>Unity版本号判断，500表示5.0.0</td>
    </tr>
  </tbody>
</table>

<h3 id="platform-difference-helpers">Platform difference helpers</h3>

<table>
  <thead>
    <tr>
      <th>宏</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_UV_STARTS_AT_TOP</code>​</td>
      <td>一般此判断当前平台是DX(UV原点在左上角)还是OpenGL(UV原点在左下角)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_NO_SCREENSPACE_SHADOWS</code>​</td>
      <td>定义移动平台不进行Cascaded ScreenSpace Shadow</td>
    </tr>
  </tbody>
</table>

<h3 id="ui">UI</h3>

<table>
  <thead>
    <tr>
      <th>宏</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_UI_CLIP_RECT</code>​</td>
      <td>当父级物体有Rect Mask 2D组件时激活<br />需要先手动定义此变体#pragma multi_compile _ UNITY_UI_CLIP_RECT<br />同时需要声明：_ClipRect(一个四维向量)<br />UnityGet2DClipping (float2 position, float4 clipRect)即可实现遮罩</td>
    </tr>
  </tbody>
</table>

<h3 id="lighting">Lighting</h3>

<table>
  <thead>
    <tr>
      <th>宏</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_SHOULD_SAMPLE_SH</code>​</td>
      <td>是否进行计算SH（光照探针与顶点着色）</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_SAMPLE_FULL_SH_PER_PIXEL</code>​</td>
      <td>光照贴图uv和来自SHL2的环境颜色在顶点和像素内插器中共享</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">HANDLE_SHADOWS_BLENDING_IN_GI</code>​</td>
      <td>当同时定义了SHADOWS_SCREEN与LIGHTMAP_ON时开启</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_SHADOW_COORDS(N)</code>​</td>
      <td>定义一个float4类型的变量_ShadowCoord，语义为第N个TEXCOORD</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">V2F_SHADOW_CASTER;</code>​</td>
      <td>用于”LightMode” = “ShadowCaster”中，相当于定义了float4 pos:SV_POSITION</td>
    </tr>
  </tbody>
</table>

<h3 id="other">Other</h3>

<table>
  <thead>
    <tr>
      <th>宏</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_SHADER_NO_UPGRADE</code>​</td>
      <td>另Shader不自动更新API，只需把语句用注释的形式写在shader中任意位置即可</td>
    </tr>
  </tbody>
</table>

<h3 id="urp特定宏">URP特定宏</h3>

<table>
  <thead>
    <tr>
      <th>宏</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_NO_DXT5nm</code>​</td>
      <td>法线纹理是否不采用DXT5压缩，移动平台是，非移动平台否</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_ASTC_NORMALMAP_ENCODING</code>​</td>
      <td>当在移动平台中，法线纹理采用类DXT5nm的压缩时启用</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SHADERGRAPH_PREVIEW</code>​</td>
      <td>在ShaderGraph中的Custom Function自义定节点上使用，用于判断是否处于SG面板预览中</td>
    </tr>
  </tbody>
</table>]]></content><author><name></name></author><category term="shader" /><category term="unity" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Unity Shader 参考文档 - 第二部分</title><link href="https://lixiao90s.github.io/post/unity-shader-reference-document-part-2-zv2tg1.html" rel="alternate" type="text/html" title="Unity Shader 参考文档 - 第二部分" /><published>2025-07-31T09:06:34+08:00</published><updated>2025-07-31T09:06:34+08:00</updated><id>https://lixiao90s.github.io/post/unity-shader-reference-document-part-2-zv2tg1</id><content type="html" xml:base="https://lixiao90s.github.io/post/unity-shader-reference-document-part-2-zv2tg1.html"><![CDATA[<hr />

<h2 id="buildin-variables内置变量">BuildIn Variables（内置变量）</h2>

<h3 id="基础函数">基础函数</h3>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_INITIALIZE_OUTPUT(type,name)</code>​</td>
      <td>由于HLSL编缉器不接受没有初始化的数据，所以为了支持所有平台，从而需要使用此方法进行初始化</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">TRANSFORM_TEX(i.uv,_MainTex)</code>​</td>
      <td>对UV进行Tiling与Offset变换</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float3 UnityWorldSpaceLightDir( float3 worldPos )</code>​</td>
      <td>返回顶点到灯光的向量</td>
    </tr>
  </tbody>
</table>

<h3 id="camera-and-screen">Camera and Screen</h3>

<h4 id="内置渲染管线">内置渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>变量</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_WorldSpaceCameraPos</code>​</td>
      <td>主相机的世界坐标位置，类型：float3</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UnityWorldSpaceViewDir(i.worldPos)</code>​</td>
      <td>世界空间下的相机方向(顶点到主相机)，类型：float3</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_CameraDepthTexture</code>​</td>
      <td>深度纹理，需要在脚本中开启相机的深度：Camera.main.depthTextureMode = DepthTextureMode.Depth</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">ComputeScreenPos(float4 pos)</code>​</td>
      <td>pos为裁剪空间下的坐标位置，返回的是某个投影点下的屏幕坐标位置</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_ScreenParams</code>​</td>
      <td>屏幕的相关参数，单位为像素。x表示屏幕的宽度，y表示屏幕的高度，z表示1+1/屏幕宽度，w表示1+1/屏幕高度</td>
    </tr>
  </tbody>
</table>

<h4 id="urp渲染管线">URP渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>变量</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_WorldSpaceCameraPos</code>​</td>
      <td>相机在世界空间下的位置坐标(xyz)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_ZBufferParams</code>​</td>
      <td>Z Buffer参数，包含近远裁剪面信息</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_CameraDepthTexture</code>​</td>
      <td>深度纹理，在PipelineAsset中勾选DepthTexture</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_CameraOpaqueTexture</code>​</td>
      <td>抓屏纹理，在PipelineAsset中勾选OpaqueTexture</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_ScreenParams</code>​</td>
      <td>屏幕的相关参数，单位为像素</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_ScaledScreenParams</code>​</td>
      <td>同上，但是有考虑到RenderScale的影响</td>
    </tr>
  </tbody>
</table>

<h3 id="time">Time</h3>

<table>
  <thead>
    <tr>
      <th>变量</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_Time</code>​</td>
      <td>时间，主要用于在Shader做动画，类型：float4<br />x = t/20<br />y = t<br />z = t<em>2w = t</em>3</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_SinTime</code>​</td>
      <td>t是时间的正弦值，返回值(-1~1)<br />x = t/8<br />y = t/4<br />z = t/2<br />w = t</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_CosTime</code>​</td>
      <td>t是时间的余弦值，返回值(-1~1)<br />x = t/8<br />y = t/4<br />z = t/2<br />w = t</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">unity_DeltaTime</code>​</td>
      <td>dt是时间增量，smoothDt是平滑时间<br />x = dt<br />y = 1/dt<br />z = smoothDt<br />w = 1/smoothDt</td>
    </tr>
  </tbody>
</table>

<h3 id="lighting-内置渲染管线">Lighting (内置渲染管线)</h3>

<table>
  <thead>
    <tr>
      <th>变量</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_LightColor0</code>​</td>
      <td>主平行灯的颜色值，rgb = 颜色x亮度；a = 亮度</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_WorldSpaceLightPos0</code>​</td>
      <td>平行灯：(xyz=位置,z=0)，已归一化<br />其它类型灯：(xyz=位置,z=1)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">unity_WorldToLight</code>​</td>
      <td>从世界空间转换到灯光空间下，等同于旧版的_LightMatrix0</td>
    </tr>
  </tbody>
</table>

<h3 id="fog-and-ambient-内置渲染管线">Fog and Ambient (内置渲染管线)</h3>

<table>
  <thead>
    <tr>
      <th>变量</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">unity_AmbientSky</code>​</td>
      <td>环境光（Gradient）中的Sky Color</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">unity_AmbientEquator</code>​</td>
      <td>环境光（Gradient）中的Equator Color</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">unity_AmbientGround</code>​</td>
      <td>环境光（Gradient）中的Ground Color</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_LIGHTMODEL_AMBIENT</code>​</td>
      <td>环境光(Color)中的颜色，等同于环境光（Gradient）中的Sky Color</td>
    </tr>
  </tbody>
</table>

<h3 id="gpu-instancing">GPU Instancing</h3>

<table>
  <thead>
    <tr>
      <th>内容</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>实现步骤</td>
      <td>用于对多个对象(网格一样，材质一样，但是材质属性不一样)合批，单个合批最大上限为511个对象<br />1. #pragma multi_compile_instancing 添加此指令后会使材质面板上曝露Instaning开关<br />2. UNITY_VERTEX_INPUT_INSTANCE_ID 在顶点着色器的输入(appdata)和输出(v2f可选)中添加(uint instanceID : SV_InstanceID)<br />3. 构建需要实例化的额外数据<br />4. UNITY_SETUP_INSTANCE_ID(v) 放在顶点着色器/片断着色器(可选)中最开始的地方<br />5. UNITY_TRANSFER_INSTANCE_ID(v, o) 当需要将实例化ID传到片断着色器时，在顶点着色器中添加<br />6. UNITY_ACCESS_INSTANCED_PROP(arrayName, propName) 在片断着色器中访问具体的实例化变量</td>
    </tr>
    <tr>
      <td>Instancing选项</td>
      <td>对GPU Instancing进行一些设置<br />• #pragma instancing_options forcemaxcount:batchSize 强制设置单个批次内Instancing的最大数量<br />• #pragma instancing_options maxcount:batchSize 设置单个批次内Instancing的最大数量</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="buildin-transformation内置变换">BuildIn Transformation（内置变换）</h2>

<h3 id="空间变换矩阵">空间变换(矩阵)</h3>

<h4 id="内置渲染管线-1">内置渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>矩阵</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_MVP</code>​</td>
      <td>模型空间»投影空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_MV</code>​</td>
      <td>模型空间»观察空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_V</code>​</td>
      <td>视图空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_P</code>​</td>
      <td>投影空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_VP</code>​</td>
      <td>视图空间&gt;投影空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">unity_ObjectToWorld</code>​</td>
      <td>本地空间»世界空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">unity_WorldToObject</code>​</td>
      <td>世界空间&gt;本地空间</td>
    </tr>
  </tbody>
</table>

<h4 id="urp渲染管线-1">URP渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">GetObjectToWorldMatrix()</code>​</td>
      <td>本地空间到世界空间的矩阵</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">GetWorldToObjectMatrix()</code>​</td>
      <td>世界空间到本地空间的矩阵</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">GetWorldToViewMatrix()</code>​</td>
      <td>世界空间到观察空间的矩阵</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">GetWorldToHClipMatrix()</code>​</td>
      <td>世界空间到齐次裁剪空间的矩阵</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">GetViewToHClipMatrix()</code>​</td>
      <td>观察空间到齐次裁剪空间的矩阵</td>
    </tr>
  </tbody>
</table>

<h3 id="空间变换方法">空间变换(方法)</h3>

<h4 id="内置渲染管线-2">内置渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UnityObjectToClipPos(v.vertex)</code>​</td>
      <td>将模型空间下的顶点转换到齐次裁剪空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UnityObjectToWorldNormal(v.normal)</code>​</td>
      <td>将模型空间下的法线转换到世界空间(已归一化)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UnityObjectToWorldDir (v.tangent)</code>​</td>
      <td>将模型空间下的切线转换到世界空间(已归一化)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UnityWorldSpaceLightDir (i.worldPos)</code>​</td>
      <td>世界空间下顶点到灯光方向的向量(未归一化)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UnityWorldSpaceViewDir (i.worldPos)</code>​</td>
      <td>世界空间下顶点到视线方向的向量(未归一化)</td>
    </tr>
  </tbody>
</table>

<h4 id="urp渲染管线-2">URP渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float3 TransformObjectToWorld (float3 positionOS)</code>​</td>
      <td>从本地空间变换到世界空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float3 TransformWorldToObject (float3 positionWS)</code>​</td>
      <td>从世界空间变换到本地空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float3 TransformWorldToView(float3 positionWS)</code>​</td>
      <td>从世界空间变换到视图空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 TransformObjectToHClip(float3 positionOS)</code>​</td>
      <td>将模型空间下的顶点变换到齐次裁剪空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 TransformWorldToHClip(float3 positionWS)</code>​</td>
      <td>将世界空间下的顶点变换到齐次裁剪空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 TransformWViewToHClip (float3 positionVS)</code>​</td>
      <td>将视图空间下的顶点变换到齐次裁剪空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float3 TransformObjectToWorldNormal (float3 normalOS)</code>​</td>
      <td>将法线从本地空间变换到世界空间(已归一化)</td>
    </tr>
  </tbody>
</table>

<h3 id="基础变换矩阵">基础变换矩阵</h3>

<table>
  <thead>
    <tr>
      <th>矩阵类型</th>
      <th>矩阵定义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>平移矩阵</td>
      <td>​<code class="language-plaintext highlighter-rouge">float4x4 M_translate = float4x4(    1, 0, 0, T.x,    0, 1, 0, T.y,    0, 0, 1, T.z,    0, 0, 0, 1);</code>​</td>
    </tr>
    <tr>
      <td>缩放矩阵</td>
      <td>​<code class="language-plaintext highlighter-rouge">float4x4 M_scale = float4x4(    S.x, 0, 0, 0,    0, S.y, 0, 0,    0, 0, S.z, 0,    0, 0, 0, 1);</code>​</td>
    </tr>
    <tr>
      <td>旋转矩阵(X轴)</td>
      <td>​<code class="language-plaintext highlighter-rouge">float4x4 M_rotationX = float4x4(    1, 0, 0, 0,    0, cos(θ), sin(θ), 0,    0, -sin(θ), cos(θ), 0,    0, 0, 0, 1);</code>​</td>
    </tr>
    <tr>
      <td>旋转矩阵(Y轴)</td>
      <td>​<code class="language-plaintext highlighter-rouge">float4x4 M_rotationY = float4x4(    cos(θ), 0, sin(θ), 0,    0, 1, 0, 0,    -sin(θy), 0, cos(θ), 0,    0, 0, 0, 1);</code>​</td>
    </tr>
    <tr>
      <td>旋转矩阵(Z轴)</td>
      <td>​<code class="language-plaintext highlighter-rouge">float4x4 M_rotationZ = float4x4(    cos(θ), sin(θ), 0, 0,    -sin(θ), cos(θ), 0, 0,    0, 0, 1, 0,    0, 0, 0, 1);</code>​</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="lighting光照">Lighting（光照）</h2>

<h3 id="光照模型">光照模型</h3>

<h4 id="lambertian">Lambertian</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>Diffuse = Ambient + Kd * LightColor * max(0,dot(N,L))
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><strong>Diffuse</strong>: 最终物体上的漫反射光强</li>
  <li><strong>Ambient</strong>: 环境光强度，为了简化计算，环境光强采用一个常数表示</li>
  <li><strong>Kd</strong>: 物体材质对光的反射系数</li>
  <li><strong>LightColor</strong>: 光源的强度</li>
  <li><strong>N</strong>: 顶点的单位法线向量</li>
  <li><strong>L</strong>: 顶点指向光源的单位向量</li>
</ul>

<h4 id="phong">Phong</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>Specular = SpecularColor * Ks * pow(max(0,dot(R,V)), Shininess)
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><strong>Specular</strong>: 最终物体上的反射高光光强</li>
  <li><strong>SpecularColor</strong>: 反射光的颜色</li>
  <li><strong>Ks</strong>: 反射强度系数</li>
  <li><strong>R</strong>: 反射向量，可使用2 * N * dot(N,L) - L或者reflect(-L,N)获得</li>
  <li><strong>V</strong>: 观察方向</li>
  <li><strong>N</strong>: 顶点的单位法线向量</li>
  <li><strong>L</strong>: 顶点指向光源的单位向量</li>
  <li><strong>Shininess</strong>: 乘方运算来模拟高光的变化</li>
</ul>

<h4 id="blinn-phong">Blinn-Phong</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>Specular = SpecularColor * Ks * pow(max(0,dot(N,H)), Shininess)
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><strong>H</strong>: 入射光线L与视线V的中间向量，也称为半角向量H = normalize(L+V)</li>
</ul>

<h4 id="disney-principled-brdf">Disney Principled BRDF</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>f(l,v) = diffuse + D(h)F(v,h)G(l,v,h)/4cos(n·l)cos(n·v)
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li><strong>f(l,v)</strong> : 双向反射分布函数的最终值，l表示光的方向，v表示视线的方向</li>
  <li><strong>diffuse</strong>: 漫反射</li>
  <li><strong>D(h)</strong> : 法线分布函数(Normal Distribution Function)</li>
  <li><strong>F(v,h)</strong> : 菲涅尔方程(Fresnel Equation)</li>
  <li><strong>G(l,v,h)</strong> : 几何函数(Geometry Function)</li>
</ul>

<h3 id="法线贴图">法线贴图</h3>

<h4 id="内置渲染管线-3">内置渲染管线</h4>

<ol>
  <li>appdata中定义NORMAL与TANGENT语义</li>
  <li>v2f中声明三个变量用于组成成切线空间下的旋转矩阵</li>
  <li>在顶点着色器中执行切线空间转换</li>
  <li>在片断着色器中计算出世界空间下的法线</li>
</ol>

<h4 id="urp渲染管线-3">URP渲染管线</h4>

<ol>
  <li>Attributes中定义NORMAL与TANGENT语义</li>
  <li>Varyings中声明三个变量用于组成成切线空间下的旋转矩阵</li>
  <li>在顶点着色器中执行切线空间转换</li>
  <li>在片断着色器中计算出世界空间下的法线</li>
</ol>

<h3 id="阴影">阴影</h3>

<h4 id="内置渲染管线-4">内置渲染管线</h4>

<ul>
  <li><strong>生成阴影</strong>: 添加”LightMode” = “ShadowCaster”的Pass</li>
  <li><strong>采样阴影</strong>: 使用UNITY_SHADOW_COORDS、TRANSFER_SHADOW、UNITY_LIGHT_ATTENUATION</li>
</ul>

<h4 id="urp渲染管线-4">URP渲染管线</h4>

<ul>
  <li><strong>投射阴影</strong>: 添加LightMode=ShadowCaster的pass即可渲染进lightmap产生投影</li>
  <li><strong>接收阴影</strong>: 使用相关宏定义来控制阴影接收</li>
</ul>

<h3 id="雾效">雾效</h3>

<h4 id="内置渲染管线-5">内置渲染管线</h4>

<ul>
  <li><strong>方案一</strong>: 常规方案，使用UNITY_FOG_COORDS、UNITY_TRANSFER_FOG、UNITY_APPLY_FOG</li>
  <li><strong>方案二</strong>: 当在v2f中有定义worldPos时，可以把worldPos.w利用起来做为雾效值</li>
</ul>

<h4 id="urp渲染管线-5">URP渲染管线</h4>

<ul>
  <li>使用#pragma multi_compile_fog</li>
  <li>在Varyings中定义fogCoord</li>
  <li>在顶点着色器中添加ComputeFogFactor</li>
  <li>在片断着色器中添加MixFog</li>
</ul>

<hr />

<h2 id="tags标签">Tags（标签）</h2>

<h3 id="基础语法">基础语法</h3>

<div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">Tags</span> <span class="p">{</span> <span class="s">"TagName1"</span> <span class="o">=</span> <span class="s">"Value1"</span> <span class="s">"TagName2"</span> <span class="o">=</span> <span class="s">"Value2"</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="renderpipelineurp">RenderPipeline（URP）</h3>

<table>
  <thead>
    <tr>
      <th>标签</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"RenderPipeline" = "UniversalPipeline"</code>​</td>
      <td>渲染管线标记，对应的管线C#代码UniversalRenderPipeline.cs中的Shader.globalRenderPipeline = UniversalPipeline,LightweightPipeline</td>
    </tr>
  </tbody>
</table>

<h3 id="queue渲染队列">Queue（渲染队列）</h3>

<table>
  <thead>
    <tr>
      <th>队列</th>
      <th>值</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"Queue" = "Background"</code>​</td>
      <td>1000</td>
      <td>此队列的对象最先进行渲染</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"Queue" = "Geometry"</code>​</td>
      <td>2000</td>
      <td>默认值，通常用于不透明对象，比如场景中的物件与角色等</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"Queue" = "AlphaTest"</code>​</td>
      <td>2450</td>
      <td>要么完全透明要么完全不透明，多用于利用贴图来实现边缘透明的效果</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"Queue" = "Transparent"</code>​</td>
      <td>3000</td>
      <td>常用于半透明对象，渲染时从后往前进行渲染</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"Queue" = "Overlay"</code>​</td>
      <td>4000</td>
      <td>此渲染队列用于叠加效果，最后渲染的东西应该放在这里</td>
    </tr>
  </tbody>
</table>

<h3 id="lightmodepass中">LightMode（Pass中）</h3>

<h4 id="内置渲染管线-6">内置渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>模式</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">ForwardBase</code>​</td>
      <td>用于前向渲染路径，支持环境光、主像素光、球谐光照与烘焙光照</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">ForwardAdd</code>​</td>
      <td>用于前向渲染路径，支持额外的逐像素光照，每盏灯一个Pass</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Deferred</code>​</td>
      <td>用于延迟渲染</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">ShadowCaster</code>​</td>
      <td>深度渲染与Shadowmap</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">MotionVectors</code>​</td>
      <td>运动矢量</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">Always</code>​</td>
      <td>永远渲染</td>
    </tr>
  </tbody>
</table>

<h4 id="urp渲染管线-6">URP渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>模式</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"LightMode" = "UniversalForward"</code>​</td>
      <td>用于前向渲染路径，所有的灯光都在这一个pass中执行</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"LightMode" = "SRPDefaultUnlit"</code>​</td>
      <td>用于在额外需要一个pass时使用</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"LightMode" = "ShadowCaster"</code>​</td>
      <td>用于生成阴影贴图ShadowMap</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"LightMode" = "DepthOnly"</code>​</td>
      <td>用于生成相机下的深度信息</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"LightMode" = "DepthNormals"</code>​</td>
      <td>用于生成相机下的深度法线信息</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"LightMode" = "Meta"</code>​</td>
      <td>仅在光照烘焙时才会使用此Pass</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"LightMode" = "Universal2D"</code>​</td>
      <td>用于URP使用2D渲染器时绘制物体的Pass</td>
    </tr>
  </tbody>
</table>

<h3 id="rendertype">RenderType</h3>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"RenderType" = "Opaque"</code>​</td>
      <td>大多数不透明着色器</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"RenderType" = "Transparent"</code>​</td>
      <td>大多数半透明着色器，比如粒子、特效、字体等</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"RenderType" = "TransparentCutout"</code>​</td>
      <td>透贴着色器，多用于植被等</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"RenderType" = "Background"</code>​</td>
      <td>多用于天空盒着色器</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"RenderType" = "Overlay"</code>​</td>
      <td>GUI、光晕着色器等</td>
    </tr>
  </tbody>
</table>

<h3 id="其他标签">其他标签</h3>

<table>
  <thead>
    <tr>
      <th>标签</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"DisableBatching" = "True"</code>​</td>
      <td>禁用批处理</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"ForceNoShadowCasting" = "True"</code>​</td>
      <td>强制关闭阴影投射</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"IgnoreProjector" = "True"</code>​</td>
      <td>不受投影器影响</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"CanUseSpriteAtlas" = "True"</code>​</td>
      <td>支持精灵打包图集</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"PreviewType" = "Plane"</code>​</td>
      <td>材质面板中的预览模型显示为平面</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">"PerformanceChecks" = "True"</code>​</td>
      <td>开启性能检测提示</td>
    </tr>
  </tbody>
</table>]]></content><author><name></name></author><category term="shader" /><category term="unity" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Unity Shader 参考文档</title><link href="https://lixiao90s.github.io/post/unity-shader-reference-documentation-8dcqe.html" rel="alternate" type="text/html" title="Unity Shader 参考文档" /><published>2025-07-31T09:06:12+08:00</published><updated>2025-07-31T09:06:12+08:00</updated><id>https://lixiao90s.github.io/post/unity-shader-reference-documentation-8dcqe</id><content type="html" xml:base="https://lixiao90s.github.io/post/unity-shader-reference-documentation-8dcqe.html"><![CDATA[<hr />

<h2 id="semantics语义">Semantics（语义）</h2>

<h3 id="应用程序到顶点着色器的数据appdata">应用程序到顶点着色器的数据（appdata）</h3>

<table>
  <thead>
    <tr>
      <th>语义</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 vertex : POSITION;</code>​</td>
      <td>顶点的本地坐标</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">uint vid : SV_VertexID;</code>​</td>
      <td>顶点的索引ID</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float3 normal : NORMAL;</code>​</td>
      <td>顶点的法线信息</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 tangent : TANGENT;</code>​</td>
      <td>顶点的切线信息</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 texcoord : TEXCOORD0;</code>​</td>
      <td>顶点的UV1信息</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 texcoord1 : TEXCOORD1;</code>​</td>
      <td>顶点的UV2信息</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 texcoord2 : TEXCOORD2;</code>​</td>
      <td>顶点的UV3信息</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 texcoord3 : TEXCOORD3;</code>​</td>
      <td>顶点的UV4信息</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">fixed4 color : COLOR;</code>​</td>
      <td>顶点的顶点色信息</td>
    </tr>
  </tbody>
</table>

<h3 id="顶点着色器到片断着色器的数据-v2f">顶点着色器到片断着色器的数据 (v2f)</h3>

<table>
  <thead>
    <tr>
      <th>语义</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 pos:SV_POSITION;</code>​</td>
      <td>顶点的齐次裁剪空间下的坐标，默认情况下用POSITION也可以(PS4下不支持)，但是为了支持所有平台，所以最好使用SV_POSITION</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">TEXCOORD0~N</code>​</td>
      <td>例如TEXCOORD0、TEXCOORD1、TEXCOORD2…等等</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">COLOR0~N</code>​</td>
      <td>例如COLOR0、COLOR1、COLOR2…等等，主要用于低精度数据，由于平台适配问题，不建议在v2f中使用COLORn</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float face:VFACE</code>​</td>
      <td>如果渲染表面朝向摄像机，则Face节点输出正值1，如果远离摄像机，则输出负值-1</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_VPOS_TYPE screenPos : VPOS</code>​</td>
      <td>当前片断在屏幕上的位置(单位是像素,可除以_ScreenParams.xy来做归一化)，此功能仅支持#pragma target 3.0及以上编译指令</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">uint vid : SV_VertexID</code>​</td>
      <td>顶点着色器可以接收具有”顶点编号”作为无符号整数的变量，当需要从纹理或ComputeBuffers中获取额外的顶点数据时比较有用，此语义仅支持#pragma target 3.5及以上</td>
    </tr>
  </tbody>
</table>

<p><strong>注意事项：</strong></p>

<ul>
  <li>OpenGL ES2.0支持最多8个</li>
  <li>OpenGL ES3.0支持最多16个</li>
</ul>

<h3 id="片断着色器输出的数据fragoutput">片断着色器输出的数据（fragOutput）</h3>

<table>
  <thead>
    <tr>
      <th>语义</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">fixed4 color : SV_Target;</code>​</td>
      <td>默认RenderTarget，也是默认输出的屏幕上的颜色，同时支持SV_Target1、SV_Target2…等等</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">fixed depth : SV_Depth;</code>​</td>
      <td>通过在片断着色器中输出SV_DEPTH语义可以更改像素的深度值，注意此功能相对会消耗性能，在没有特别需求的情况下尽量不要用</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="properties属性">Properties（属性）</h2>

<h3 id="基础属性类型">基础属性类型</h3>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_Int("Int", Int) = 1</code>​</td>
      <td>类型：整型<br />Cg/HLSL：int<br />取决于在Cg/HLSL中是用float还是int来声明的，如果定义为float则实际使用的就是浮点数，定义为int会被识别为int类型（去小数点直接取整）</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_Float ("Float", Float ) = 0</code>​</td>
      <td>类型：浮点数值<br />Cg/HLSL：可根据需要定义不同的浮点精度<br />• float：32位精度，常用于世界坐标位置以及UV坐标<br />• half：16位精度，范围[-6W,6W]，常用于本地坐标位置,方向等<br />• fixed：11位精度，范围[-2,2]，1/265的小数精度，常用于纹理与颜色等低精度的情况</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_Slider ("Slider", Range(0, 1)) = 0</code>​</td>
      <td>类型：数值滑动条<br />本身还是Float类型，只是通过Range(min,max)来控制滑动条的最小值与最大值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_Color("Color", Color) = (1,1,1,1)</code>​</td>
      <td>类型：颜色属性<br />Cg/HLSL：float4/half4/fixed4</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_Vector ("Vector", Vector) = (0,0,0,0)</code>​</td>
      <td>类型：四维向量<br />在Properties中无法定义二维或者三维向量，只能定义四维向量</td>
    </tr>
  </tbody>
</table>

<h3 id="纹理属性">纹理属性</h3>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_MainTex ("Texture", 2D) = "white" {}</code>​</td>
      <td>类型：2D纹理<br />Cg/HLSL：sampler2D/sampler2D_half/sampler2D_float<br />默认值有white、black、gray、bump以及空，空就是white</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_MainTexArray ("TextureArray", 2DArray) = "white" {}</code>​</td>
      <td>类型：2D纹理数组<br />TEXTURE2D_ARRAY(_MainTexArray); SAMPLER(sampler_MainTexArray);<br />SAMPLE_TEXTURE2D_ARRAY(_MainTexArry, sampler_MainTexArry, i.uv,_Index);<br />默认值有white、black、gray、bump以及空，空就是white<br />仅支持DX10、OpenGL3.0、Metal及以上版本</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_MainTex3D ("Texture", 3D) = "white" {}</code>​</td>
      <td>类型：3D纹理<br />Cg/HLSL：sampler3D/sampler3D_half/sampler3D_float</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_MainCube ("Texture", Cube) = "white" {}</code>​</td>
      <td>类型：立方体纹理<br />Cg/HLSL：samplerCUBE/samplerCUBE_half/samplerCUBE_float</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_MainTex ("Texture", Any) = "white" {}</code>​</td>
      <td>类型：通用纹理<br />支持2D、3D、Cube</td>
    </tr>
  </tbody>
</table>

<h3 id="attributes属性修饰符">Attributes（属性修饰符）</h3>

<table>
  <thead>
    <tr>
      <th>修饰符</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[Header(xxx)]</code>​</td>
      <td>用于在材质面板中当前属性的上方显示标题xxx，注意只支持英文、数字、空格以及下划线</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[HideInInspector]</code>​</td>
      <td>在材质面板中隐藏此条属性，在不希望暴露某条属性时可以快速将其隐藏</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[Space(n)]</code>​</td>
      <td>使材质面板属性之前有间隔，n为间隔的数值大小</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[HDR]</code>​</td>
      <td>标记为属性为高动态范围</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[PowerSlider(3)]</code>​</td>
      <td>滑条曲率，必须加在range属性前面，用于控制滑动的数值比例</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[IntRange]</code>​</td>
      <td>必须使用在Range属性之上，以使在材质面板中滑动时只能生成整数</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[Toggle]</code>​</td>
      <td>开关，加在数值类型前，可使材质面板中的数值变成开关，0是关，1是开</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[ToggleOff]</code>​</td>
      <td>与Toggle相当，0是开，1是关</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[Enum(Off, 0, On, 1)]</code>​</td>
      <td>数值枚举，可直接在cg中使用此关键字来替代数字，最多可定义7个，超出后无法以下拉列表框的形式展现</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[KeywordEnum (Enum0, Enum1, Enum2, Enum3, Enum4, Enum5, Enum6, Enum7, Enum8)]</code>​</td>
      <td>关键字枚举，需要#pragma multi_compile _XXX_ENUM0 _XXX_ENUM1 …来依次声明变体关键字，XXX为这条属性中声明的变量名，在cg/hlsl中可以通过#​if #elif #endif分别做判断</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[Enum (UnityEngine.Rendering.CullMode)]</code>​</td>
      <td>内置枚举，可在Enum()内直接调用Unity内部的枚举</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[NoScaleOffset]</code>​</td>
      <td>只能加在纹理属性前，使其隐藏材质面板中的Tiling和Offset</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[Normal]</code>​</td>
      <td>只能加在纹理属性前，标记此纹理是用来接收法线贴图的，当用户指定了非法线的纹理时会在材质面板上进行警告提示</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[Gamma]</code>​</td>
      <td>Float和Vector属性默认情况下不会进行颜色空间转换，可以通过添加[Gamma]来指明此属性为sRGB值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[PerRendererData]</code>​</td>
      <td>标记当前属性将以材质属性块的形式来自于每个渲染器数据</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[MainTexture]</code>​</td>
      <td>标记当前纹理为主纹理，便于C#通过Material.mainTexture调用</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[MainColor]</code>​</td>
      <td>标记当前颜色为主颜色，便于C#通过Material.color调用</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="math数学运算">Math（数学运算）</h2>

<h3 id="基础数学函数">基础数学函数</h3>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">abs(x)</code>​</td>
      <td>取绝对值，即正值返回正值，负值返回的还是正值，x值也可以为向量</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">acos(x)</code>​</td>
      <td>反余弦函数，输入参数范围为[-1, 1]，返回[0, π] 区间的弧度值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">asin(x)</code>​</td>
      <td>返回x的反正弦值，范围为(-π/2,π/2)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">atan(x)</code>​</td>
      <td>返回x的反正切值，范围为(-π/2,π/2)，表示弧度</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">atan2(y,x)</code>​</td>
      <td>返回y/x的反正切值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">ceil(x)</code>​</td>
      <td>对x进行向上取整，即x=0.1返回1，x=1.5返回2，x=-0.3返回0</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">clamp(x,a,b)</code>​</td>
      <td>如果x值小于a，则返回a；如果x值大于b，返回b；否则返回x</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">cos(x)</code>​</td>
      <td>返回弧度x的余弦值，范围在[-1,1]之间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">cosh(x)</code>​</td>
      <td>双曲余弦函数</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">degrees(x)</code>​</td>
      <td>将x从弧度转换成角度</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">exp(x)</code>​</td>
      <td>计算e的x次方，e = 2.71828182845904523536</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">exp2(x)</code>​</td>
      <td>计算2的x次方</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">floor(x)</code>​</td>
      <td>对x值进行向下取整(去尾求整)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">fmod(x,y)</code>​</td>
      <td>返回x/y的余数。如果y为0，结果不可预料，注意！如果x为负值，返回的结果也是负值！</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">frac(x)</code>​</td>
      <td>返回x的小数部分</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">log(x)</code>​</td>
      <td>返回x的自然对数</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">log2(x)</code>​</td>
      <td>返回以2为底的自然对数</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">log10(x)</code>​</td>
      <td>返回以10为底的自然对数</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">max(a,b)</code>​</td>
      <td>比较两个标量或等长向量元素，返回最大值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">min(a,b)</code>​</td>
      <td>比较两个标量或等长向量元素，返回最小值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">pow(x,y)</code>​</td>
      <td>返回x的y次方</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">round(x)</code>​</td>
      <td>返回x四舍五入的值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">saturate(x)</code>​</td>
      <td>如果x&lt;0返回0，如果x&gt;1返回1，否则返回x</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">sin(x)</code>​</td>
      <td>返回弧度x的正弦值，范围在[-1,1]之间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">sinh(x)</code>​</td>
      <td>双曲正弦函数</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">sqrt(x)</code>​</td>
      <td>返回x的平方根</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">tan(x)</code>​</td>
      <td>返回x的正切值</td>
    </tr>
  </tbody>
</table>

<h3 id="向量运算">向量运算</h3>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">all(a)</code>​</td>
      <td>当a或a的所有分量都为true或者非0时返回1(true)，否则返回0(false)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">any(a)</code>​</td>
      <td>如果a=0或者a中的所有分量为0，则返回0(false)；否则返回1(true)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">cross(a,b)</code>​</td>
      <td>返回两个三维向量a与b的叉积</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">dot(a,b)</code>​</td>
      <td>点乘，a和b可以为标量也可以为向量，其计算结果是两个向量夹角的余弦值，相当于|a| *</td>
      <td>b</td>
      <td>* cos(θ)或者a.x<em>b.x+a.y</em>b.y+a.z*b.z</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">distance(a,b)</code>​</td>
      <td>返回a,b间的距离</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">length(v)</code>​</td>
      <td>返回一个向量的模，即 sqrt(dot(v,v))</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">normalize(v)</code>​</td>
      <td>返回一个向量的归一化版本(方向一样，但是模为1)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">reflect(I, N)</code>​</td>
      <td>根据入射光方向向量I，和顶点法向量N，计算反射光方向向量</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">refract(I,N,eta)</code>​</td>
      <td>计算折射向量，I为入射光线，N为法向量，eta为折射系数</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h3 id="插值和步进函数">插值和步进函数</h3>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">lerp(A,B,alpha)</code>​</td>
      <td>线性插值。如果alpha=0，则返回A；如果alpha=1，则返回B；否则返回A与B的混合值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">smoothstep(min,max,x)</code>​</td>
      <td>平滑插值，如果x比min小，返回0；如果x比max大，返回1；如果x处于范围[min，max]中，则返回0和1之间的值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">step(a,b)</code>​</td>
      <td>如果a&lt;=b返回1，否则返回0</td>
    </tr>
  </tbody>
</table>

<h3 id="导数函数">导数函数</h3>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">ddx(v)</code>​</td>
      <td>当前像素右边的v值-当前像素的v值(水平方向的差值)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">ddy(v)</code>​</td>
      <td>当前像素下边的v值-当前像素的v值(垂直方向的差值)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">fwidth(v)</code>​</td>
      <td>当前像素与它右边及下边像素的差值，abs(ddx(v)) + abs(ddy(v))</td>
    </tr>
  </tbody>
</table>

<h3 id="纹理采样">纹理采样</h3>

<h4 id="内置渲染管线">内置渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">tex1D(samper1D tex,float s)</code>​</td>
      <td>一维纹理采样</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">tex2D(samper2D tex,float2 s)</code>​</td>
      <td>二维纹理采样</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">tex2Dlod(samper2D tex,float4 s)</code>​</td>
      <td>二维纹理采样，s.w表示采样的是mipmap的几级，仅在ES3.0以上支持</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">tex2DProj(samper2D tex,float4 s)</code>​</td>
      <td>二维投影纹理采样，uv使用s.xy/s.w</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">texCUBE(samperCUBE tex,float3 s)</code>​</td>
      <td>立方体纹理采样</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">tex3D(samper3D tex,float3 s)</code>​</td>
      <td>3D纹理采样，uv使用xyz</td>
    </tr>
  </tbody>
</table>

<h4 id="urp渲染管线">URP渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">TEXTURE2D(textureName);</code>​</td>
      <td>二维纹理的定义(纹理与采样器分离定义)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">TEXTURECUBE(textureName);</code>​</td>
      <td>立方体纹理的定义(纹理与采样器分离定义)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SAMPLER(samplerName);</code>​</td>
      <td>采样器的定义(纹理与采样器分离定义)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SAMPLE_TEXTURE2D(textureName, samplerName, coord);</code>​</td>
      <td>进行二维纹理采样操作</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord,lod);</code>​</td>
      <td>进行二维纹理采样操作</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord,bias);</code>​</td>
      <td>对mipmap进行偏移后再采样纹理</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SAMPLE_TEXTURECUBE(textureName, samplerName, coord);</code>​</td>
      <td>进行立方体纹理采样操作</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord,lod);</code>​</td>
      <td>进行立方体纹理采样操作</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SAMPLE_TEXTURE3D(textureName, samplerName, coord);</code>​</td>
      <td>进行3D纹理采样操作</td>
    </tr>
  </tbody>
</table>

<h3 id="纹理数组采样urp">纹理数组采样（URP）</h3>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">TEXTURE2D_ARRAY(textureName);</code>​</td>
      <td>纹理数组的定义</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SAMPLER(sampler_samplerName);</code>​</td>
      <td>纹理数组的采样器定义</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index);</code>​</td>
      <td>纹理数组采样</td>
    </tr>
  </tbody>
</table>

<h3 id="常用指令">常用指令</h3>

<table>
  <thead>
    <tr>
      <th>指令</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">mov dest, src1</code>​</td>
      <td>dest = src1</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">add dest, src1, src2</code>​</td>
      <td>dest = src1 + src2</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">mul dest, src1, src2</code>​</td>
      <td>dest = src1 * src2</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">div dest, src1, src2</code>​</td>
      <td>dest = src1 / src2</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">mad dest, src1, src2, src3</code>​</td>
      <td>dest = src1 * src2 + src3</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">dp2 dest, src1, src2</code>​</td>
      <td>(src1.x * src2.x) + (src1.y * src2.y)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">dp3 dest, src1, src2</code>​</td>
      <td>(src1.x * src2.x) + (src1.y * src2.y) + (src1.z * src2.z)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">dp4 dest, src1, src2</code>​</td>
      <td>(src1.x * src2.x) + (src1.y * src2.y) + (src1.z * src2.z) + (src1.w * src2.w)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">rsq dest, src1</code>​</td>
      <td>rsqrt(src1) 对src1进行平方根的倒数</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="buildin-variables内置变量">BuildIn Variables（内置变量）</h2>

<h3 id="基础函数">基础函数</h3>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_INITIALIZE_OUTPUT(type,name)</code>​</td>
      <td>由于HLSL编缉器不接受没有初始化的数据，所以为了支持所有平台，从而需要使用此方法进行初始化</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">TRANSFORM_TEX(i.uv,_MainTex)</code>​</td>
      <td>对UV进行Tiling与Offset变换</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float3 UnityWorldSpaceLightDir( float3 worldPos )</code>​</td>
      <td>返回顶点到灯光的向量</td>
    </tr>
  </tbody>
</table>

<h3 id="camera-and-screen">Camera and Screen</h3>

<h4 id="内置渲染管线-1">内置渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>变量</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_WorldSpaceCameraPos</code>​</td>
      <td>主相机的世界坐标位置，类型：float3</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UnityWorldSpaceViewDir(i.worldPos)</code>​</td>
      <td>世界空间下的相机方向(顶点到主相机)，类型：float3</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_CameraDepthTexture</code>​</td>
      <td>深度纹理，需要在脚本中开启相机的深度：Camera.main.depthTextureMode = DepthTextureMode.Depth</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">ComputeScreenPos(float4 pos)</code>​</td>
      <td>pos为裁剪空间下的坐标位置，返回的是某个投影点下的屏幕坐标位置</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_ScreenParams</code>​</td>
      <td>屏幕的相关参数，单位为像素。x表示屏幕的宽度，y表示屏幕的高度，z表示1+1/屏幕宽度，w表示1+1/屏幕高度</td>
    </tr>
  </tbody>
</table>

<h4 id="urp渲染管线-1">URP渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>变量</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_WorldSpaceCameraPos</code>​</td>
      <td>相机在世界空间下的位置坐标(xyz)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_ZBufferParams</code>​</td>
      <td>Z Buffer参数，包含近远裁剪面信息</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_CameraDepthTexture</code>​</td>
      <td>深度纹理，在PipelineAsset中勾选DepthTexture</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_CameraOpaqueTexture</code>​</td>
      <td>抓屏纹理，在PipelineAsset中勾选OpaqueTexture</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_ScreenParams</code>​</td>
      <td>屏幕的相关参数，单位为像素</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_ScaledScreenParams</code>​</td>
      <td>同上，但是有考虑到RenderScale的影响</td>
    </tr>
  </tbody>
</table>

<h3 id="time">Time</h3>

<table>
  <thead>
    <tr>
      <th>变量</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_Time</code>​</td>
      <td>时间，主要用于在Shader做动画，类型：float4<br />x = t/20<br />y = t<br />z = t<em>2w = t</em>3</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_SinTime</code>​</td>
      <td>t是时间的正弦值，返回值(-1~1)<br />x = t/8<br />y = t/4<br />z = t/2<br />w = t</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_CosTime</code>​</td>
      <td>t是时间的余弦值，返回值(-1~1)<br />x = t/8<br />y = t/4<br />z = t/2<br />w = t</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">unity_DeltaTime</code>​</td>
      <td>dt是时间增量，smoothDt是平滑时间<br />x = dt<br />y = 1/dt<br />z = smoothDt<br />w = 1/smoothDt</td>
    </tr>
  </tbody>
</table>

<h3 id="lighting-内置渲染管线">Lighting (内置渲染管线)</h3>

<table>
  <thead>
    <tr>
      <th>变量</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_LightColor0</code>​</td>
      <td>主平行灯的颜色值，rgb = 颜色x亮度；a = 亮度</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_WorldSpaceLightPos0</code>​</td>
      <td>平行灯：(xyz=位置,z=0)，已归一化<br />其它类型灯：(xyz=位置,z=1)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">unity_WorldToLight</code>​</td>
      <td>从世界空间转换到灯光空间下，等同于旧版的_LightMatrix0</td>
    </tr>
  </tbody>
</table>

<h3 id="fog-and-ambient-内置渲染管线">Fog and Ambient (内置渲染管线)</h3>

<table>
  <thead>
    <tr>
      <th>变量</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">unity_AmbientSky</code>​</td>
      <td>环境光（Gradient）中的Sky Color</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">unity_AmbientEquator</code>​</td>
      <td>环境光（Gradient）中的Equator Color</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">unity_AmbientGround</code>​</td>
      <td>环境光（Gradient）中的Ground Color</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_LIGHTMODEL_AMBIENT</code>​</td>
      <td>环境光(Color)中的颜色，等同于环境光（Gradient）中的Sky Color</td>
    </tr>
  </tbody>
</table>

<h3 id="gpu-instancing">GPU Instancing</h3>

<table>
  <thead>
    <tr>
      <th>内容</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>实现步骤</td>
      <td>用于对多个对象(网格一样，材质一样，但是材质属性不一样)合批，单个合批最大上限为511个对象<br />1. #pragma multi_compile_instancing 添加此指令后会使材质面板上曝露Instaning开关<br />2. UNITY_VERTEX_INPUT_INSTANCE_ID 在顶点着色器的输入(appdata)和输出(v2f可选)中添加(uint instanceID : SV_InstanceID)<br />3. 构建需要实例化的额外数据<br />4. UNITY_SETUP_INSTANCE_ID(v) 放在顶点着色器/片断着色器(可选)中最开始的地方<br />5. UNITY_TRANSFER_INSTANCE_ID(v, o) 当需要将实例化ID传到片断着色器时，在顶点着色器中添加<br />6. UNITY_ACCESS_INSTANCED_PROP(arrayName, propName) 在片断着色器中访问具体的实例化变量</td>
    </tr>
    <tr>
      <td>Instancing选项</td>
      <td>对GPU Instancing进行一些设置<br />• #pragma instancing_options forcemaxcount:batchSize 强制设置单个批次内Instancing的最大数量<br />• #pragma instancing_options maxcount:batchSize 设置单个批次内Instancing的最大数量</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="buildin-transformation内置变换">BuildIn Transformation（内置变换）</h2>

<h3 id="空间变换矩阵">空间变换(矩阵)</h3>

<h4 id="内置渲染管线-2">内置渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>矩阵</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_MVP</code>​</td>
      <td>模型空间»投影空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_MV</code>​</td>
      <td>模型空间»观察空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_V</code>​</td>
      <td>视图空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_P</code>​</td>
      <td>投影空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_MATRIX_VP</code>​</td>
      <td>视图空间&gt;投影空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">unity_ObjectToWorld</code>​</td>
      <td>本地空间»世界空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">unity_WorldToObject</code>​</td>
      <td>世界空间&gt;本地空间</td>
    </tr>
  </tbody>
</table>

<h4 id="urp渲染管线-2">URP渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">GetObjectToWorldMatrix()</code>​</td>
      <td>本地空间到世界空间的矩阵</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">GetWorldToObjectMatrix()</code>​</td>
      <td>世界空间到本地空间的矩阵</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">GetWorldToViewMatrix()</code>​</td>
      <td>世界空间到观察空间的矩阵</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">GetWorldToHClipMatrix()</code>​</td>
      <td>世界空间到齐次裁剪空间的矩阵</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">GetViewToHClipMatrix()</code>​</td>
      <td>观察空间到齐次裁剪空间的矩阵</td>
    </tr>
  </tbody>
</table>

<h3 id="空间变换方法">空间变换(方法)</h3>

<h4 id="内置渲染管线-3">内置渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UnityObjectToClipPos(v.vertex)</code>​</td>
      <td>将模型空间下的顶点转换到齐次裁剪空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UnityObjectToWorldNormal(v.normal)</code>​</td>
      <td>将模型空间下的法线转换到世界空间(已归一化)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UnityObjectToWorldDir (v.tangent)</code>​</td>
      <td>将模型空间下的切线转换到世界空间(已归一化)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UnityWorldSpaceLightDir (i.worldPos)</code>​</td>
      <td>世界空间下顶点到灯光方向的向量(未归一化)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UnityWorldSpaceViewDir (i.worldPos)</code>​</td>
      <td>世界空间下顶点到视线方向的向量(未归一化)</td>
    </tr>
  </tbody>
</table>

<h4 id="urp渲染管线-3">URP渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float3 TransformObjectToWorld (float3 positionOS)</code>​</td>
      <td>从本地空间变换到世界空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float3 TransformWorldToObject (float3 positionWS)</code>​</td>
      <td>从世界空间变换到本地空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float3 TransformWorldToView(float3 positionWS)</code>​</td>
      <td>从世界空间变换到视图空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 TransformObjectToHClip(float3 positionOS)</code>​</td>
      <td>将模型空间下的顶点变换到齐次裁剪空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 TransformWorldToHClip(float3 positionWS)</code>​</td>
      <td>将世界空间下的顶点变换到齐次裁剪空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 TransformWViewToHClip (float3 positionVS)</code>​</td>
      <td>将视图空间下的顶点变换到齐次裁剪空间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float3 TransformObjectToWorldNormal (float3 normalOS)</code>​</td>
      <td>将法线从本地空间变换到世界空间(已归一化)</td>
    </tr>
  </tbody>
</table>

<h3 id="基础变换矩阵">基础变换矩阵</h3>

<table>
  <thead>
    <tr>
      <th>矩阵类型</th>
      <th>矩阵定义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>平移矩阵</td>
      <td>```float4x4 M_translate = float4x4(<br />    1, 0, 0, T.x,<br />    0, 1, 0, T.y,<br />    0, 0, 1, T.z,<br />    0, 0</td>
    </tr>
  </tbody>
</table>]]></content><author><name></name></author><category term="shader" /><category term="unity" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Unity Shader 参考文档 - 第一部分</title><link href="https://lixiao90s.github.io/post/unity-shader-reference-document-part-1-z21bblp.html" rel="alternate" type="text/html" title="Unity Shader 参考文档 - 第一部分" /><published>2025-07-31T09:05:58+08:00</published><updated>2025-07-31T09:05:58+08:00</updated><id>https://lixiao90s.github.io/post/unity-shader-reference-document-part-1-z21bblp</id><content type="html" xml:base="https://lixiao90s.github.io/post/unity-shader-reference-document-part-1-z21bblp.html"><![CDATA[<hr />

<h2 id="semantics语义">Semantics（语义）</h2>

<h3 id="应用程序到顶点着色器的数据appdata">应用程序到顶点着色器的数据（appdata）</h3>

<table>
  <thead>
    <tr>
      <th>语义</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 vertex : POSITION;</code>​</td>
      <td>顶点的本地坐标</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">uint vid : SV_VertexID;</code>​</td>
      <td>顶点的索引ID</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float3 normal : NORMAL;</code>​</td>
      <td>顶点的法线信息</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 tangent : TANGENT;</code>​</td>
      <td>顶点的切线信息</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 texcoord : TEXCOORD0;</code>​</td>
      <td>顶点的UV1信息</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 texcoord1 : TEXCOORD1;</code>​</td>
      <td>顶点的UV2信息</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 texcoord2 : TEXCOORD2;</code>​</td>
      <td>顶点的UV3信息</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 texcoord3 : TEXCOORD3;</code>​</td>
      <td>顶点的UV4信息</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">fixed4 color : COLOR;</code>​</td>
      <td>顶点的顶点色信息</td>
    </tr>
  </tbody>
</table>

<h3 id="顶点着色器到片断着色器的数据-v2f">顶点着色器到片断着色器的数据 (v2f)</h3>

<table>
  <thead>
    <tr>
      <th>语义</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float4 pos:SV_POSITION;</code>​</td>
      <td>顶点的齐次裁剪空间下的坐标，默认情况下用POSITION也可以(PS4下不支持)，但是为了支持所有平台，所以最好使用SV_POSITION</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">TEXCOORD0~N</code>​</td>
      <td>例如TEXCOORD0、TEXCOORD1、TEXCOORD2…等等</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">COLOR0~N</code>​</td>
      <td>例如COLOR0、COLOR1、COLOR2…等等，主要用于低精度数据，由于平台适配问题，不建议在v2f中使用COLORn</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">float face:VFACE</code>​</td>
      <td>如果渲染表面朝向摄像机，则Face节点输出正值1，如果远离摄像机，则输出负值-1</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">UNITY_VPOS_TYPE screenPos : VPOS</code>​</td>
      <td>当前片断在屏幕上的位置(单位是像素,可除以_ScreenParams.xy来做归一化)，此功能仅支持#pragma target 3.0及以上编译指令</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">uint vid : SV_VertexID</code>​</td>
      <td>顶点着色器可以接收具有”顶点编号”作为无符号整数的变量，当需要从纹理或ComputeBuffers中获取额外的顶点数据时比较有用，此语义仅支持#pragma target 3.5及以上</td>
    </tr>
  </tbody>
</table>

<p><strong>注意事项：</strong></p>

<ul>
  <li>OpenGL ES2.0支持最多8个</li>
  <li>OpenGL ES3.0支持最多16个</li>
</ul>

<h3 id="片断着色器输出的数据fragoutput">片断着色器输出的数据（fragOutput）</h3>

<table>
  <thead>
    <tr>
      <th>语义</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">fixed4 color : SV_Target;</code>​</td>
      <td>默认RenderTarget，也是默认输出的屏幕上的颜色，同时支持SV_Target1、SV_Target2…等等</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">fixed depth : SV_Depth;</code>​</td>
      <td>通过在片断着色器中输出SV_DEPTH语义可以更改像素的深度值，注意此功能相对会消耗性能，在没有特别需求的情况下尽量不要用</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="properties属性">Properties（属性）</h2>

<h3 id="基础属性类型">基础属性类型</h3>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_Int("Int", Int) = 1</code>​</td>
      <td>类型：整型<br />Cg/HLSL：int<br />取决于在Cg/HLSL中是用float还是int来声明的，如果定义为float则实际使用的就是浮点数，定义为int会被识别为int类型（去小数点直接取整）</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_Float ("Float", Float ) = 0</code>​</td>
      <td>类型：浮点数值<br />Cg/HLSL：可根据需要定义不同的浮点精度<br />• float：32位精度，常用于世界坐标位置以及UV坐标<br />• half：16位精度，范围[-6W,6W]，常用于本地坐标位置,方向等<br />• fixed：11位精度，范围[-2,2]，1/265的小数精度，常用于纹理与颜色等低精度的情况</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_Slider ("Slider", Range(0, 1)) = 0</code>​</td>
      <td>类型：数值滑动条<br />本身还是Float类型，只是通过Range(min,max)来控制滑动条的最小值与最大值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_Color("Color", Color) = (1,1,1,1)</code>​</td>
      <td>类型：颜色属性<br />Cg/HLSL：float4/half4/fixed4</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_Vector ("Vector", Vector) = (0,0,0,0)</code>​</td>
      <td>类型：四维向量<br />在Properties中无法定义二维或者三维向量，只能定义四维向量</td>
    </tr>
  </tbody>
</table>

<h3 id="纹理属性">纹理属性</h3>

<table>
  <thead>
    <tr>
      <th>属性</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_MainTex ("Texture", 2D) = "white" {}</code>​</td>
      <td>类型：2D纹理<br />Cg/HLSL：sampler2D/sampler2D_half/sampler2D_float<br />默认值有white、black、gray、bump以及空，空就是white</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_MainTexArray ("TextureArray", 2DArray) = "white" {}</code>​</td>
      <td>类型：2D纹理数组<br />TEXTURE2D_ARRAY(_MainTexArray); SAMPLER(sampler_MainTexArray);<br />SAMPLE_TEXTURE2D_ARRAY(_MainTexArry, sampler_MainTexArry, i.uv,_Index);<br />默认值有white、black、gray、bump以及空，空就是white<br />仅支持DX10、OpenGL3.0、Metal及以上版本</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_MainTex3D ("Texture", 3D) = "white" {}</code>​</td>
      <td>类型：3D纹理<br />Cg/HLSL：sampler3D/sampler3D_half/sampler3D_float</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_MainCube ("Texture", Cube) = "white" {}</code>​</td>
      <td>类型：立方体纹理<br />Cg/HLSL：samplerCUBE/samplerCUBE_half/samplerCUBE_float</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">_MainTex ("Texture", Any) = "white" {}</code>​</td>
      <td>类型：通用纹理<br />支持2D、3D、Cube</td>
    </tr>
  </tbody>
</table>

<h3 id="attributes属性修饰符">Attributes（属性修饰符）</h3>

<table>
  <thead>
    <tr>
      <th>修饰符</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[Header(xxx)]</code>​</td>
      <td>用于在材质面板中当前属性的上方显示标题xxx，注意只支持英文、数字、空格以及下划线</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[HideInInspector]</code>​</td>
      <td>在材质面板中隐藏此条属性，在不希望暴露某条属性时可以快速将其隐藏</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[Space(n)]</code>​</td>
      <td>使材质面板属性之前有间隔，n为间隔的数值大小</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[HDR]</code>​</td>
      <td>标记为属性为高动态范围</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[PowerSlider(3)]</code>​</td>
      <td>滑条曲率，必须加在range属性前面，用于控制滑动的数值比例</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[IntRange]</code>​</td>
      <td>必须使用在Range属性之上，以使在材质面板中滑动时只能生成整数</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[Toggle]</code>​</td>
      <td>开关，加在数值类型前，可使材质面板中的数值变成开关，0是关，1是开</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[ToggleOff]</code>​</td>
      <td>与Toggle相当，0是开，1是关</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[Enum(Off, 0, On, 1)]</code>​</td>
      <td>数值枚举，可直接在cg中使用此关键字来替代数字，最多可定义7个，超出后无法以下拉列表框的形式展现</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[KeywordEnum (Enum0, Enum1, Enum2, Enum3, Enum4, Enum5, Enum6, Enum7, Enum8)]</code>​</td>
      <td>关键字枚举，需要#pragma multi_compile _XXX_ENUM0 _XXX_ENUM1 …来依次声明变体关键字，XXX为这条属性中声明的变量名，在cg/hlsl中可以通过#​if #elif #endif分别做判断</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[Enum (UnityEngine.Rendering.CullMode)]</code>​</td>
      <td>内置枚举，可在Enum()内直接调用Unity内部的枚举</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[NoScaleOffset]</code>​</td>
      <td>只能加在纹理属性前，使其隐藏材质面板中的Tiling和Offset</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[Normal]</code>​</td>
      <td>只能加在纹理属性前，标记此纹理是用来接收法线贴图的，当用户指定了非法线的纹理时会在材质面板上进行警告提示</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[Gamma]</code>​</td>
      <td>Float和Vector属性默认情况下不会进行颜色空间转换，可以通过添加[Gamma]来指明此属性为sRGB值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[PerRendererData]</code>​</td>
      <td>标记当前属性将以材质属性块的形式来自于每个渲染器数据</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[MainTexture]</code>​</td>
      <td>标记当前纹理为主纹理，便于C#通过Material.mainTexture调用</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">[MainColor]</code>​</td>
      <td>标记当前颜色为主颜色，便于C#通过Material.color调用</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="math数学运算">Math（数学运算）</h2>

<h3 id="基础数学函数">基础数学函数</h3>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">abs(x)</code>​</td>
      <td>取绝对值，即正值返回正值，负值返回的还是正值，x值也可以为向量</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">acos(x)</code>​</td>
      <td>反余弦函数，输入参数范围为[-1, 1]，返回[0, π] 区间的弧度值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">asin(x)</code>​</td>
      <td>返回x的反正弦值，范围为(-π/2,π/2)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">atan(x)</code>​</td>
      <td>返回x的反正切值，范围为(-π/2,π/2)，表示弧度</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">atan2(y,x)</code>​</td>
      <td>返回y/x的反正切值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">ceil(x)</code>​</td>
      <td>对x进行向上取整，即x=0.1返回1，x=1.5返回2，x=-0.3返回0</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">clamp(x,a,b)</code>​</td>
      <td>如果x值小于a，则返回a；如果x值大于b，返回b；否则返回x</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">cos(x)</code>​</td>
      <td>返回弧度x的余弦值，范围在[-1,1]之间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">cosh(x)</code>​</td>
      <td>双曲余弦函数</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">degrees(x)</code>​</td>
      <td>将x从弧度转换成角度</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">exp(x)</code>​</td>
      <td>计算e的x次方，e = 2.71828182845904523536</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">exp2(x)</code>​</td>
      <td>计算2的x次方</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">floor(x)</code>​</td>
      <td>对x值进行向下取整(去尾求整)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">fmod(x,y)</code>​</td>
      <td>返回x/y的余数。如果y为0，结果不可预料，注意！如果x为负值，返回的结果也是负值！</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">frac(x)</code>​</td>
      <td>返回x的小数部分</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">log(x)</code>​</td>
      <td>返回x的自然对数</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">log2(x)</code>​</td>
      <td>返回以2为底的自然对数</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">log10(x)</code>​</td>
      <td>返回以10为底的自然对数</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">max(a,b)</code>​</td>
      <td>比较两个标量或等长向量元素，返回最大值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">min(a,b)</code>​</td>
      <td>比较两个标量或等长向量元素，返回最小值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">pow(x,y)</code>​</td>
      <td>返回x的y次方</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">round(x)</code>​</td>
      <td>返回x四舍五入的值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">saturate(x)</code>​</td>
      <td>如果x&lt;0返回0，如果x&gt;1返回1，否则返回x</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">sin(x)</code>​</td>
      <td>返回弧度x的正弦值，范围在[-1,1]之间</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">sinh(x)</code>​</td>
      <td>双曲正弦函数</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">sqrt(x)</code>​</td>
      <td>返回x的平方根</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">tan(x)</code>​</td>
      <td>返回x的正切值</td>
    </tr>
  </tbody>
</table>

<h3 id="向量运算">向量运算</h3>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">all(a)</code>​</td>
      <td>当a或a的所有分量都为true或者非0时返回1(true)，否则返回0(false)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">any(a)</code>​</td>
      <td>如果a=0或者a中的所有分量为0，则返回0(false)；否则返回1(true)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">cross(a,b)</code>​</td>
      <td>返回两个三维向量a与b的叉积</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">dot(a,b)</code>​</td>
      <td>点乘，a和b可以为标量也可以为向量，其计算结果是两个向量夹角的余弦值，相当于|a| *</td>
      <td>b</td>
      <td>* cos(θ)或者a.x<em>b.x+a.y</em>b.y+a.z*b.z</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">distance(a,b)</code>​</td>
      <td>返回a,b间的距离</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">length(v)</code>​</td>
      <td>返回一个向量的模，即 sqrt(dot(v,v))</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">normalize(v)</code>​</td>
      <td>返回一个向量的归一化版本(方向一样，但是模为1)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">reflect(I, N)</code>​</td>
      <td>根据入射光方向向量I，和顶点法向量N，计算反射光方向向量</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">refract(I,N,eta)</code>​</td>
      <td>计算折射向量，I为入射光线，N为法向量，eta为折射系数</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h3 id="插值和步进函数">插值和步进函数</h3>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">lerp(A,B,alpha)</code>​</td>
      <td>线性插值。如果alpha=0，则返回A；如果alpha=1，则返回B；否则返回A与B的混合值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">smoothstep(min,max,x)</code>​</td>
      <td>平滑插值，如果x比min小，返回0；如果x比max大，返回1；如果x处于范围[min，max]中，则返回0和1之间的值</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">step(a,b)</code>​</td>
      <td>如果a&lt;=b返回1，否则返回0</td>
    </tr>
  </tbody>
</table>

<h3 id="导数函数">导数函数</h3>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">ddx(v)</code>​</td>
      <td>当前像素右边的v值-当前像素的v值(水平方向的差值)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">ddy(v)</code>​</td>
      <td>当前像素下边的v值-当前像素的v值(垂直方向的差值)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">fwidth(v)</code>​</td>
      <td>当前像素与它右边及下边像素的差值，abs(ddx(v)) + abs(ddy(v))</td>
    </tr>
  </tbody>
</table>

<h3 id="纹理采样">纹理采样</h3>

<h4 id="内置渲染管线">内置渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">tex1D(samper1D tex,float s)</code>​</td>
      <td>一维纹理采样</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">tex2D(samper2D tex,float2 s)</code>​</td>
      <td>二维纹理采样</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">tex2Dlod(samper2D tex,float4 s)</code>​</td>
      <td>二维纹理采样，s.w表示采样的是mipmap的几级，仅在ES3.0以上支持</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">tex2DProj(samper2D tex,float4 s)</code>​</td>
      <td>二维投影纹理采样，uv使用s.xy/s.w</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">texCUBE(samperCUBE tex,float3 s)</code>​</td>
      <td>立方体纹理采样</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">tex3D(samper3D tex,float3 s)</code>​</td>
      <td>3D纹理采样，uv使用xyz</td>
    </tr>
  </tbody>
</table>

<h4 id="urp渲染管线">URP渲染管线</h4>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">TEXTURE2D(textureName);</code>​</td>
      <td>二维纹理的定义(纹理与采样器分离定义)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">TEXTURECUBE(textureName);</code>​</td>
      <td>立方体纹理的定义(纹理与采样器分离定义)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SAMPLER(samplerName);</code>​</td>
      <td>采样器的定义(纹理与采样器分离定义)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SAMPLE_TEXTURE2D(textureName, samplerName, coord);</code>​</td>
      <td>进行二维纹理采样操作</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord,lod);</code>​</td>
      <td>进行二维纹理采样操作</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord,bias);</code>​</td>
      <td>对mipmap进行偏移后再采样纹理</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SAMPLE_TEXTURECUBE(textureName, samplerName, coord);</code>​</td>
      <td>进行立方体纹理采样操作</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord,lod);</code>​</td>
      <td>进行立方体纹理采样操作</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SAMPLE_TEXTURE3D(textureName, samplerName, coord);</code>​</td>
      <td>进行3D纹理采样操作</td>
    </tr>
  </tbody>
</table>

<h3 id="纹理数组采样urp">纹理数组采样（URP）</h3>

<table>
  <thead>
    <tr>
      <th>函数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">TEXTURE2D_ARRAY(textureName);</code>​</td>
      <td>纹理数组的定义</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SAMPLER(sampler_samplerName);</code>​</td>
      <td>纹理数组的采样器定义</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index);</code>​</td>
      <td>纹理数组采样</td>
    </tr>
  </tbody>
</table>

<h3 id="常用指令">常用指令</h3>

<table>
  <thead>
    <tr>
      <th>指令</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">mov dest, src1</code>​</td>
      <td>dest = src1</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">add dest, src1, src2</code>​</td>
      <td>dest = src1 + src2</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">mul dest, src1, src2</code>​</td>
      <td>dest = src1 * src2</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">div dest, src1, src2</code>​</td>
      <td>dest = src1 / src2</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">mad dest, src1, src2, src3</code>​</td>
      <td>dest = src1 * src2 + src3</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">dp2 dest, src1, src2</code>​</td>
      <td>(src1.x * src2.x) + (src1.y * src2.y)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">dp3 dest, src1, src2</code>​</td>
      <td>(src1.x * src2.x) + (src1.y * src2.y) + (src1.z * src2.z)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">dp4 dest, src1, src2</code>​</td>
      <td>(src1.x * src2.x) + (src1.y * src2.y) + (src1.z * src2.z) + (src1.w * src2.w)</td>
    </tr>
    <tr>
      <td>​<code class="language-plaintext highlighter-rouge">rsq dest, src1</code>​</td>
      <td>rsqrt(src1) 对src1进行平方根的倒数</td>
    </tr>
  </tbody>
</table>]]></content><author><name></name></author><category term="shader" /><category term="unity" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Unity Mask遮罩失效问题</title><link href="https://lixiao90s.github.io/post/unity-mask-failure-issues-z1aeqtt.html" rel="alternate" type="text/html" title="Unity Mask遮罩失效问题" /><published>2025-07-30T14:34:27+08:00</published><updated>2025-07-30T14:34:27+08:00</updated><id>https://lixiao90s.github.io/post/unity-mask-failure-issues-z1aeqtt</id><content type="html" xml:base="https://lixiao90s.github.io/post/unity-mask-failure-issues-z1aeqtt.html"><![CDATA[<p>实际效果</p>

<p><img src="/assets/images/image-20250730143814-cygxc0l.png" alt="image" /></p>

<p>期望效果</p>

<p><img src="/assets/images/image-20250730143635-4r24aw6.png" alt="image" /></p>

<p>‍</p>

<h2 id="环境设置">环境设置</h2>

<ul>
  <li>Canvas设置<img src="/assets/images/image-20250730144216-latiynl.png" alt="image" /></li>
</ul>

<p>​​</p>

<ul>
  <li>Camera设置<img src="/assets/images/image-20250730144316-kwiuxap.png" alt="image" /></li>
</ul>

<p>在当前情况下就会出现MASK失效的问题</p>

<p>在把相机设置成Screen Space - Overlay或者设置清除深度 如下图即可解决</p>

<p><img src="/assets/images/image-20250730144512-i5hzrsf.png" alt="image" /></p>

<p>我是设置了清除深度缓存，让其显示效果正常</p>

<h2 id="相机渲染模式的区别">相机渲染模式的区别</h2>

<ul>
  <li>
    <h3 id="screen-space---overlay">Screen Space - Overlay</h3>

    <ul>
      <li>
        <p>UI直接渲染在屏幕上，不依赖相机//</p>
      </li>
      <li>
        <p>不受3D场景影响//</p>
      </li>
      <li>性能较好//</li>
      <li>遮罩效果稳定</li>
      <li>不需要深度测试</li>
    </ul>
  </li>
  <li>
    <h3 id="screen-space---camera">Screen Space - Camera</h3>

    <ul>
      <li>
        <p>UI渲染在指定相机前方的平面上</p>
      </li>
      <li>
        <p>受相机设置影响（FOV、深度等）</p>
      </li>
      <li>可以与3D场景交互</li>
      <li>遮罩效果可能受相机设置影响</li>
      <li>需要正确的深度缓冲区管理</li>
    </ul>
  </li>
</ul>

<h2 id="clear-depth-的作用原理">Clear Depth 的作用原理</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>问题场景：
 - UI相机和游戏相机共享深度缓冲区
 - 游戏相机已经渲染了3D场景，设置了深度值
 - UI相机渲染时，深度测试可能失败
 - 导致UI元素（包括遮罩）不显示或显示异常
渲染流程：
 1. 游戏相机渲染3D场景 → 设置深度缓冲区
 2. UI相机渲染UI → 需要清除之前的深度值
 3. 如果不清除深度，UI可能被深度测试过滤掉
</pre></td></tr></tbody></table></code></pre></div></div>]]></content><author><name></name></author><category term="unity" /><category term="UGUI" /><summary type="html"><![CDATA[实际效果]]></summary></entry><entry><title type="html">ET8.1版本</title><link href="https://lixiao90s.github.io/post/et81-version-z7czqy.html" rel="alternate" type="text/html" title="ET8.1版本" /><published>2025-06-04T08:47:07+08:00</published><updated>2025-06-04T08:47:07+08:00</updated><id>https://lixiao90s.github.io/post/et81-version-z7czqy</id><content type="html" xml:base="https://lixiao90s.github.io/post/et81-version-z7czqy.html"><![CDATA[<h1 id="et81版本">ET8.1版本</h1>

<p>ET8.1</p>

<ul>
  <li>model和modelView 主要是放类的定义</li>
  <li>hotFix和hotFixView 主要放类的视线</li>
  <li>带View的就是unity视图相关的</li>
  <li>Unity.loader下是非热更的函数</li>
</ul>

<p>‍</p>

<h2 id="ecs-组件式编程">ECS 组件式编程</h2>

<ul>
  <li>与unity官方的ECS毫无关系</li>
</ul>

<p>ET 框架设计原则：</p>

<ul>
  <li>树状领域</li>
  <li>组合模式</li>
  <li>事件驱动</li>
  <li>逻辑分发</li>
</ul>

<p>后期编写全部在</p>

<ul>
  <li>
    <p>AllHotFix</p>

    <ul>
      <li>System</li>
    </ul>
  </li>
  <li>
    <p>AllModel</p>

    <ul>
      <li>component 和entity</li>
    </ul>
  </li>
  <li>Model 逻辑层，不能引用任何unity下的代码</li>
  <li>ModelView 表现层，可以使用unity</li>
  <li>客户端代码，必须在ET.Client命名空间当中，Server同理，如果是两者都用命名空间则是ET</li>
  <li>实体和组件都会继承Entity</li>
  <li>通过ComponentOf(typeof(Computer)) 来表明当前组件会挂在Computer上</li>
  <li>
    <p>表现层调用逻辑层是没问题，但是逻辑层应该通过抛出事件的方式，驱动逻辑层做出修改</p>

    <p>‍</p>

    <p>‍</p>

    <h3 id="为什么system要用static">为什么System要用static</h3>
  </li>
</ul>

<p>‍</p>

<h2 id="fiber">Fiber</h2>

<p><img src="http://127.0.0.1:61725/assets/7fa237e61827b28bd5ac8bbaa64d5575-20250625083528-0yajur7.jpg" alt="7fa237e61827b28bd5ac8bbaa64d5575" /></p>

<p><img src="http://127.0.0.1:61725/assets/6e1ad008fc15671f89d7ee6218418ba1-20250625083820-onl8o85.jpg" alt="6e1ad008fc15671f89d7ee6218418ba1" /></p>

<p><img src="http://127.0.0.1:61725/assets/734de6bcbb0176922bc33be5e95ad65f-20250625083905-udlorz6.jpg" alt="734de6bcbb0176922bc33be5e95ad65f" /></p>

<p><img src="http://127.0.0.1:61725/assets/4380a4e6f64083adb692901219f10574-20250625083959-eblv0yb.jpg" alt="4380a4e6f64083adb692901219f10574" /></p>

<p><img src="http://127.0.0.1:61725/assets/762b1f77e76f02662e708d1b555f63de-20250625084548-9eiw0is.jpg" alt="762b1f77e76f02662e708d1b555f63de" /></p>

<p><img src="http://127.0.0.1:61725/assets/031a3fda7242ae49a50ff668ca32332f-20250625084909-9zcfykz.jpg" alt="031a3fda7242ae49a50ff668ca32332f" /></p>

<p><img src="http://127.0.0.1:61725/assets/6db830b5ac7ebd1dd1c48fac1cde8ceb-20250630084331-sm36igd.jpg" alt="6db830b5ac7ebd1dd1c48fac1cde8ceb" /></p>

<p><img src="http://127.0.0.1:61725/assets/a587cdf64af7384c34eded940eddff7a-20250630085656-odo2fyy.jpg" alt="a587cdf64af7384c34eded940eddff7a" /></p>

<p>两个纤程通讯使用的ProcessInnerSender</p>]]></content><author><name></name></author><summary type="html"><![CDATA[ET8.1版本]]></summary></entry><entry><title type="html">Unity 跑酷游戏开发笔记</title><link href="https://lixiao90s.github.io/posts/unity-parkour-game/" rel="alternate" type="text/html" title="Unity 跑酷游戏开发笔记" /><published>2025-04-20T12:00:00+08:00</published><updated>2025-04-20T12:00:00+08:00</updated><id>https://lixiao90s.github.io/posts/unity-parkour-game</id><content type="html" xml:base="https://lixiao90s.github.io/posts/unity-parkour-game/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#unity-跑酷游戏开发笔记" id="markdown-toc-unity-跑酷游戏开发笔记">Unity 跑酷游戏开发笔记</a>    <ul>
      <li><a href="#一项目概述" id="markdown-toc-一项目概述">一、项目概述</a>        <ul>
          <li><a href="#11-游戏类型" id="markdown-toc-11-游戏类型">1.1 游戏类型</a></li>
          <li><a href="#12-技术选择" id="markdown-toc-12-技术选择">1.2 技术选择</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="unity-跑酷游戏开发笔记">Unity 跑酷游戏开发笔记</h1>

<h2 id="一项目概述">一、项目概述</h2>
<p>有一段时间没有使用unity开发，熟悉unity开发，并熟悉unity的新技术，例如新的框架，hybridclr，yooasset等，也是为了丰富简历，在休息完这段时间后，希望能顺利入职</p>

<h3 id="11-游戏类型">1.1 游戏类型</h3>
<ul>
  <li>3D 跑酷游戏</li>
  <li>第三人称视角</li>
</ul>

<h3 id="12-技术选择">1.2 技术选择</h3>
<ul>
  <li>框架</li>
</ul>]]></content><author><name>lixiao</name></author><category term="游戏开发" /><category term="unity" /><category term="c#" /><category term="游戏开发" /><category term="跑酷游戏" /></entry></feed>