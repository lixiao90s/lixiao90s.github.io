[ { "title": "Grain官方文档的一些理解", "url": "/post/some-understanding-of-grain-s-official-documentation-zcic9v.html", "categories": "", "tags": "orleans, 服务器, .Net, c#", "date": "2025-08-08 14:31:29 +0800", "content": "灵活放置 grain被激活时，由runtime决定 哪个silo激活 放置策略 随机 本地哟偶先 负载均衡 自定义 持久化 将grain状态保存到外部存储系统（一般是数据库或者云存储），当被停用时状态不丢失，激活时恢复到之前状态，这样业务将无感。 public sealed class ShoppingCartGrain( [PersistentState( stateName: \"ShoppingCart\", storageName: \"shopping-cart\")] IPersistentState&lt;Dictionary&lt;string, CartItem&gt;&gt; cart) : Grain, IShoppingCartGrain //配置地方 if (builder.Environment.IsDevelopment()) { builder.Host.UseOrleans((_, builder) =&gt; { builder .UseLocalhostClustering() .AddMemoryGrainStorage(\"shopping-cart\") // &lt;-- Here it is! .AddStartupTask&lt;SeedProductStoreTask&gt;(); }); } 无状态工作者(Stateless workers) 不存储任何需要持久化的状态，每次调用都是全新操作 Grain call filters (调用筛选器) 关注核心的业务逻辑，同时将日志、授权、错误处理等通用功能集中到可重用的筛选器组件中，极大地提高了代码的可维护性和可扩展性。 您可以把它想象成 ASP.NET Core 中的中间件 (Middleware)，或者其他框架中的“拦截器” (Interceptor)。它的核心作用就是 在不修改 grain 本身代码的情况下，为 grain 的方法调用添加额外的通用逻辑 。 面向切面编程 (AOP) 这是最经典的用例。您希望记录每个 grain 方法的调用情况，比如：哪个方法被调用了、参数是什么、执行了多长时间、是否成功等。如果没有筛选器，您就需要在每个 grain 的每个方法里都写重复的日志代码。 集中管理日志逻辑。 轻松监控系统性能和瓶颈。 调试和追踪问题。 // 1. 实现筛选器接口 public class LoggingGrainCallFilter : IIncomingGrainCallFilter { private readonly ILogger&lt;LoggingGrainCallFilter&gt; _logger; public LoggingGrainCallFilter(ILogger&lt;LoggingGrainCallFilter&gt; logger) { _logger = logger; } public async Task Invoke(IIncomingGrainCallContext context) { var stopwatch = Stopwatch.StartNew(); _logger.LogInformation( \"Grain Call Starting: {Grain}.{Method} with arguments {Arguments}\", context.Grain.GetType().Name, context.ImplementationMethod.Name, context.Arguments); try { // 调用链中的下一个筛选器，或者直接调用 grain 方法 await context.Invoke(); stopwatch.Stop(); _logger.LogInformation( \"Grain Call Succeeded: {Grain}.{Method} executed in {ElapsedMilliseconds}ms\", context.Grain.GetType().Name, context.ImplementationMethod.Name, stopwatch.ElapsedMilliseconds); } catch (Exception ex) { stopwatch.Stop(); _logger.LogError( ex, \"Grain Call Failed: {Grain}.{Method} executed in {ElapsedMilliseconds}ms\", context.Grain.GetType().Name, context.ImplementationMethod.Name, stopwatch.ElapsedMilliseconds); // 必须重新抛出异常，否则调用方会认为调用成功了 throw; } } } // 2. 在 Silo 中注册筛选器 builder.Host.UseOrleans(siloBuilder =&gt; { // 将筛选器注册为全局筛选器，应用到所有 grain siloBuilder.AddIncomingGrainCallFilter&lt;LoggingGrainCallFilter&gt;(); }); 例子2 授权赛选器 ‍ // 1. 定义一个特性，用来标记需要授权的方法 [AttributeUsage(AttributeTargets.Method)] public class RequiresAdminRoleAttribute : Attribute { } // 2. 实现筛选器 public class AuthorizationGrainCallFilter : IIncomingGrainCallFilter { public async Task Invoke(IIncomingGrainCallContext context) { // 检查目标方法是否标记了我们的特性 var requiresAdmin = context.ImplementationMethod.GetCustomAttribute&lt;RequiresAdminRoleAttribute&gt;(); if (requiresAdmin is not null) { // 从调用上下文中获取用户信息 (这通常需要您自己实现) var userRole = RequestContext.Get(\"UserRole\") as string; if (userRole != \"Admin\") { // 如果用户不是 Admin，则直接抛出异常，阻止方法调用 throw new UnauthorizedAccessException(\"User does not have the required 'Admin' role.\"); } } // 如果检查通过，则继续调用 await context.Invoke(); } } // 3. 在 Grain 方法上使用特性 public class SuperSecretGrain : Grain, ISuperSecretGrain { [RequiresAdminRole] public Task&lt;string&gt; GetTheSecretCode() { return Task.FromResult(\"12345\"); } public Task&lt;string&gt; GetPublicInfo() { return Task.FromResult(\"This is public info.\"); } } // 4. 别忘了在 Silo 中注册筛选器！ siloBuilder.AddIncomingGrainCallFilter&lt;AuthorizationGrainCallFilter&gt;(); 统一的错误处理 (Error Handling) public class ErrorHandlingGrainCallFilter : IIncomingGrainCallFilter { public async Task Invoke(IIncomingGrainCallContext context) { try { await context.Invoke(); } catch (BusinessValidationException ex) { // 捕获我们自定义的业务逻辑异常 // 并且将其转换为一个特定的结果，而不是让它冒泡到客户端 context.Result = new { ErrorCode = ex.ErrorCode, Message = ex.Message }; } catch (Exception) { // 对于所有其他未知的异常，我们只返回一个通用的错误信息 // 并且在服务器端记录详细日志（可以在日志筛选器中完成） throw new ApplicationException(\"An unexpected error occurred. Please try again later.\"); } } } // 注册筛选器 siloBuilder.AddIncomingGrainCallFilter&lt;ErrorHandlingGrainCallFilter&gt;(); ## Request context 它的主要作用是在一次完整的请求-响应生命周期中，共享那些 不属于 grain 本身状态 、但又对处理逻辑很重要的 临时性数据 。 1. // 设置一个唯一的追踪 ID，用于追踪整个调用链 RequestContext.Set(\"TraceId\", Guid.NewGuid()); // 设置当前用户的 ID RequestContext.Set(\"UserId\", \"user-123\"); // 现在发起对第一个 grain 的调用 var grainA = client.GetGrain&lt;IGrainA&gt;(0); await grainA.DoSomething(); 2. public class GrainB : Grain, IGrainB { public async Task DoWork() { // 直接从 RequestContext 中读取数据 var traceId = RequestContext.Get(\"TraceId\"); var userId = RequestContext.Get(\"UserId\"); _logger.LogInformation(\"GrainB is doing work for user {UserId} with trace {TraceId}\", userId, traceId); // ... 业务逻辑 ... // 调用下一个 grain，RequestContext 中的数据会自动传递过去 var grainC = this.GrainFactory.GetGrain&lt;IGrainC&gt;(0); await grainC.DoMoreWork(); } } RequestContext 的主要应用场景 ‍ 分布式追踪 (Distributed Tracing) ：这是最常见的用途。在请求的最开始生成一个唯一的 TraceId (或 CorrelationId )，并放入 RequestContext 。之后，在每个 grain 的日志中都带上这个 ID。当系统出现问题时，您就可以通过这个 TraceId 在日志系统中（如 ELK, Splunk, Datadog）串联起一次完整请求经过的所有路径，极大地简化了分布式环境下的问题排查。 ‍ 传递用户身份或租户信息 ：在多租户的应用中，您可以在请求入口处将用户的身份令牌 (token)、用户ID或租户ID放入 RequestContext 。这样，调用链中的任何一个 grain 都可以知道当前操作属于哪个用户或租户，而无需在每个方法签名中都传递这些信息。这对于实现授权逻辑（如我们之前讨论的调用筛选器）尤其有用。 ‍ 传递客户端信息 ：例如客户端的设备类型 ( “iOS” , “Android” , “Web” )、IP 地址或者语言偏好 ( “en-US” , “zh-CN” )。这可以让 grain 根据不同的客户端环境返回不同的数据或执行不同的逻辑。 ‍ 功能开关或 A/B 测试 ：您可以将一些功能开关的标志位放入 RequestContext ，来控制在本次请求中是否启用某个新功能，从而实现灰度发布或 A/B 测试。 需要注意的关键点 线程安全 ： RequestContext 是基于 AsyncLocal 实现的，这意味着它存储的数据是与当前的异步控制流（async control flow）绑定的，是线程安全的。 非持久化 ： RequestContext 中的数据是 临时的、非持久的 。它只在一次请求的生命周期内有效。它 不是 用来替代 grain 的持久化状态的。 数据大小 ：由于 RequestContext 的数据需要在每次 grain 间调用时进行序列化和网络传输，所以不应该在里面存放大量的数据。只应存放少量的、关键的元数据。 ‍ 分布式 ACID 事务(Distributed ACID transactions) 原子性 (Atomicity) ：一个事务中的所有操作，要么 全部成功 ，要么 全部失败 回滚。不会出现“钱扣了，但对方没收到”的中间状态。 一致性 (Consistency) ：事务必须使系统从一个有效的状态转移到另一个有效的状态。例如，转账前后，银行系统所有账户的总金额应该是不变的。 隔离性 (Isolation) ：并发执行的事务之间互不干扰。Orleans 提供了 可串行化 (Serializable) 的隔离级别，这是最严格的隔离级别，它保证了并发事务的最终结果与某个顺序执行它们的结果完全相同。 持久性 (Durability) ：一旦事务成功提交，其结果就是永久性的，即使系统发生故障也不会丢失。 分布式 （Distributed ）：这意味着一个 ACID 事务可以跨越 多个不同的 grain ，而这些 grain 可能位于集群中 不同的物理服务器 (Silo) 上 官方例子关键代码 // (这是 BankAccount 示例中的代码结构) public interface IAccountGrain : IGrainWithIntegerKey { // [Transaction] 特性指明这个方法必须在一个事务中执行 [Transaction(TransactionOption.Join)] Task Withdraw(uint amount); [Transaction(TransactionOption.Join)] Task Deposit(uint amount); [Transaction(TransactionOption.CreateOrJoin)] Task&lt;uint&gt; GetBalance(); } // (这是 BankAccount 示例中的代码结构) public class AccountGrain : Grain, IAccountGrain { // 使用 ITransactionalState 来存储账户余额,前面有个IPersistState private readonly ITransactionalState&lt;Balance&gt; _balance; public AccountGrain( [TransactionalState(\"balance\")] ITransactionalState&lt;Balance&gt; balance) { _balance = balance ?? throw new ArgumentNullException(nameof(balance)); } // 在方法中，我们就像操作普通对象一样修改状态 public Task Withdraw(uint amount) { return _balance.PerformUpdate(b =&gt; b.Value -= amount); } public Task Deposit(uint amount) { return _balance.PerformUpdate(b =&gt; b.Value += amount); } public Task&lt;uint&gt; GetBalance() { return _balance.PerformRead(b =&gt; b.Value); } } //执行事务 // (这是 BankAccount 示例中的代码结构) // 注入 ITransactionClient private readonly ITransactionClient _transactionClient; public async Task Transfer(IAccountGrain fromAccount, IAccountGrain toAccount, uint amountToTransfer) { try { // 使用 TransactionClient 来执行一个事务性的 lambda 表达式 // 在这个 lambda 表达式中进行的所有 grain 调用，都会被自动包含在同一个事务里 await _transactionClient.RunTransaction( TransactionOption.Create, // 创建一个新事务 async () =&gt; { // 1. 从 fromAccount 取款 await fromAccount.Withdraw(amountToTransfer); // 2. 向 toAccount 存款 await toAccount.Deposit(amountToTransfer); }); } catch (Exception ex) { // 如果在执行过程中发生任何错误 (比如 fromAccount 余额不足抛出异常) // 整个事务会自动回滚。 // fromAccount 的取款操作会被撤销，toAccount 的存款操作也根本不会发生。 Console.WriteLine($\"Transaction failed: {ex.Message}\"); } } ITransactionalState&lt;T&gt;​ 与 IPersistentState&lt;T&gt;​ 的关键区别 为了更好地理解它，我们可以将它与我们之前讨论过的标准持久化组件 IPersistentState&lt;T&gt;​ 进行对比： 特性 ​IPersistentState&lt;T&gt;​ (标准持久化) ​ITransactionalState&lt;T&gt;​ (事务性状态) 核心关注点 单个 Grain 状态的持久化（Durability） 。确保 Grain 失活或服务器重启后，状态能从存储中恢复。 跨多个 Grain 操作的原子性（Atomicity） 和隔离性（Isolation） 。确保一组操作要么全部成功，要么全部失败。 操作方式 通过 .State​ 属性直接访问和修改内存中的状态，然后显式调用 .WriteStateAsync()​ 将其写入存储。 通过 .PerformUpdate()​ 和 .PerformRead()​ 方法来“请求”对状态进行修改或读取。 谁来控制写入 开发者。您需要自己决定何时调用 WriteStateAsync()​。 Orleans 事务管理器。开发者从不直接调用写入方法。状态的最终提交或回滚由事务协调器自动处理。 适用场景 适用于绝大多数不需要跨 Grain 协调的、独立的有状态服务。例如，保存用户的购物车、个人资料等。 必须用于需要多个 Grain 协同完成一个业务逻辑的场景。最典型的例子就是银行转账，涉及两个账户 Grain 的状态同步更新。 ITransactionalState&lt;T&gt;​ 的工作机制 ​ITransactionalState&lt;T&gt;​ 通过两个核心方法来运作： ​​Task&lt;TResult&gt; PerformRead(Func&lt;T, TResult&gt; readFunc)​ ​ 作用：以事务安全的方式读取状态。 解释：当你调用此方法时，Orleans 会确保你读取到的数据在当前事务的隔离级别（通常是“可串行化”）下是一致的。这意味着你不会读到其他并发事务尚未提交的“脏数据”。 示例：在 AccountGrain​ 中获取余额。 public Task&lt;decimal&gt; GetBalance() { return _balance.PerformRead(balance =&gt; balance.Value); } ​​Task PerformUpdate(Action&lt;T&gt; updateAction)​ ​ 作用：以事务安全的方式更新状态。 解释：这是最关键的部分。当你调用此方法时，你并不是立即修改了状态。相反，你是在向当前事务提交一个“意图”——“我计划对状态进行这样的修改”。这个修改操作会被记录下来，但不会立即持久化。 示例：在 AccountGrain​ 中存款。 public Task Deposit(decimal amount) { return _balance.PerformUpdate(balance =&gt; balance.Value += amount); } ‍ ## Orleans Streams 的核心概念 Orleans Streams 是一个强大的流式处理框架，它将流处理的复杂性与 Grain 模型无缝集成。您可以把它想象成一个内置于 Orleans 的、 为 Grain “量身定做” 的、虚拟化的发布/订阅（Pub/Sub）系统 。 ‍ 1.虚拟化（Virtualization） ：与 Grain 一样，流也是虚拟的。这意味着您不需要显式地创建或销毁一个流。流永远存在，就像 Grain 一样。您只需通过一个唯一的标识符（ StreamId ）就可以向它发布消息或订阅它。 2.生产者与消费者解耦 ：生产者向一个流发布消息，而不需要知道谁在监听这个流，有多少个监听者，或者它们当前是否处于激活状态。同样，消费者订阅一个流，而不需要知道谁在发布消息。 3.可靠性与持久性 ：Orleans Streams 通过流提供程序（Stream Provider） 来支持不同的底层消息队列技术。这意味着流中的消息可以是持久化的（例如，使用 Azure Event Hubs 或 RabbitMQ），确保了即使在消费者离线或系统重启后，消息也不会丢失。 4.自动化的生命周期管理 ：Orleans 负责管理消费者的订阅生命周期。当一个订阅流的 Grain 被激活时，Orleans 会自动为其恢复订阅。如果消费者处理消息失败，Orleans 还提供了内置的重试和错误处理机制。 5.背压（Backpressure） ：系统会自动监测消费者的处理速度。如果消费者跟不上消息产生的速度，流提供程序会减慢或暂停向其递送消息，防止消费者被压垮。 ‍ Stream (流) 它是一个逻辑上的 通道 ，用于传输一系列有序的事件。 每个流都有一个唯一的标识符（一个 Guid 和一个 string 类型的命名空间），例如 StreamId.Create(“my-namespace”, someGuid) 。 流是 虚拟的、持久的 。即使没有任何生产者或消费者连接到它，流也“存在”。数据可以发布到一个流中，即使当时没有消费者；当消费者稍后订阅时，它可以从流的特定点开始接收数据。 2.Stream Producer (流生产者) 任何可以将事件发布到流中的实体。通常是一个 Grain，但也可以是 Orleans 集群外部的客户端。 生产者获取一个流的句柄 ( IAsyncStream )，然后调用 .OnNextAsync(event) 来发布事件。 示例 : 在 Streaming\\Simple\\Grains\\ProducerGrain.cs 中， ProducerGrain 就是一个生产者。它会定期向一个流中发送 int 型的事件。 3.Stream Consumer (流消费者) 订阅流并处理事件的实体，通常也是一个 Grain。 消费者通过订阅一个流来接收事件。当新事件到达时，Orleans 运行时会调用消费者 Grain 中预定义的处理方法（例如 OnNextAsync ）。 隐式订阅 vs. 显式订阅 : 隐式订阅 ( [ImplicitStreamSubscription(“MyStreamNamespace”)] ) : 这是最常见的方式。您可以在 Grain 类上使用此特性。Orleans 会自动为具有相同 Guid 的 Grain 订阅相应命名空间下的流。例如，一个 ConsumerGrain 被激活并传入一个 Guid，它会自动订阅到 StreamId.Create(“MyStreamNamespace”, thatSameGuid) 。 显式订阅 : 消费者可以动态地获取流的句柄，并调用 .SubscribeAsync(IAsyncObserver) 来手动订阅或退订。 示例 : 在 Streaming\\Simple\\Grains\\ConsumerGrain.cs 中， ConsumerGrain 就是一个消费者。它隐式地订阅流，并在收到事件时将其打印出来。 4.Stream Provider (流提供程序) 这是流的物理实现。它负责事件的传输、持久化和传递保证。 Orleans 提供了多种内置的流提供程序： MemoryStreamProvider : 用于测试和开发。事件存储在内存中，Silo 重启后会丢失。 AzureQueueStreamProvider : 使用 Azure Queue Storage 作为传输媒介。 EventHubStreamProvider : 使用 Azure Event Hubs，适用于大规模、高吞吐量的场景。 AWSSQSStreamProvider : 使用 Amazon SQS。 官方例子 Streaming\\CustomDataAdapter 示例那样，创建自己的提供程序来对接任何消息系统（如 RabbitMQ, Kafka 等）。 " }, { "title": "Orleans框架", "url": "/post/orleans-framework-z1wuwgn.html", "categories": "", "tags": "服务器, .Net, c#", "date": "2025-08-08 14:31:23 +0800", "content": "基本概念理解 Virtual Actor核心机制 自动管理生命周期 自动实例化 触发条件：消息发送至未激活Actor时，运行时自动创建Grain实例并调用ActivateAsync()​ 资源回收：闲置实例触发DeactivateAsync()​清理，内存释放 故障恢复 服务器宕机：运行时在下一请求时自动在新节点重建Grain，无需应用层监控 位置透明 调用抽象：通过Grain ID调用Actor，物理位置由运行时目录服务动态映射，缓存命中率&gt;90% 扩展模式 无状态Worker：同一Grain多实例并行处理请求，适用无状态场景（如只读缓存） Grain Grain是Orleans中的虚拟Actor，代表一个独立的状态实体或计算单元（如玩家、订单、房间）。每个Grain拥有唯一的标识符（Grain ID），通过接口定义其行为 在基于Orleans框架的游戏开发中，Grains作为分布式Actor模型的核心单元，将需要独立状态、并发安全、生命周期管理的实体抽象为Grains（如玩家、房间、全局服务） 2. 单线程执行的技术实现 Orleans通过以下机制实现Grain的单线程执行： Orleans运行时确保每个激活的Grain在任何时刻仅在一个线程上执行。这意味着对Grain内部状态的访问天然无需锁或其他同步机制 异步消息队列： 所有对Grain的调用（即使代码表现为方法调用）均被转化为异步消息，存入该Grain专属的WorkItemGroup​队列 协作式调度： 运行时使用少量线程（通常等于CPU核心数） 处理所有Grain的消息队列。消息按顺序从队列中取出，由同一线程连续执行直至完成（无抢占） 状态隔离性： Grain的状态（如玩家血量、位置）仅能通过消息修改，外部无法直接访问，从物理上杜绝共享内存冲 ‍ Silo Silo是物理资源单位（如一台服务器） ‍ 调用机制本质：消息传递 调用方（如PlayerGrain​）向RoomGrain​发送请求消息。 运行时调度： 若RoomGrain​与调用方在同一Silo，消息通过本地队列直接传递，无网络开销 若在不同Silo，消息经TCP连接（默认端口11111）路由至目标Silo的RoomGrain​ ​RoomGrain​处理 ：消息进入其专属​​WorkItemGroup​​队列， 单线程串行执行（即使多个请求并发到达） 单线程执行模型： 每个Grain（包括RoomGrain​）绑定独立队列，请求严格串行处理，避免状态竞争 例如：玩家A和B同时向RoomGrain​发送消息，消息按到达顺序依次处理。 状态隔离性： ​RoomGrain​封装房间状态（如玩家列表、位置），外部仅能通过消息修改，天然线程安全 消息顺序保障： 同一发送方的消息默认按序传递（除非标记[Unordered]​） 所有Grain交互均为消息驱动，所谓“直接调用”只是语法糖，底层仍由Orleans消息系统保障顺序性，这样可以避免资源竞争等问题，也是实现无锁编程的关键 ‍ 直接调用消息转化位异步消息的实现 Grain引用抽象 当开发者调用GrainFactory.GetGrain&lt;T&gt;()​时，Orleans运行时动态生成代理对象（如PlayerGrainReference​），而非真实Grain实例 代理对象实现与Grain接口相同的公开方法（如Move()​、Attack()​）。 调用代理方法时，实际触发消息封装流程。 透明代理技术 基于.NET的RealProxy​或DispatchProxy​，在方法调用时拦截参数并构造消息体 // 示例：代理对象拦截方法调用 public class GrainReferenceProxy : DispatchProxy { protected override object Invoke(MethodInfo method, object[] args) { var request = new InvokeMethodRequest(method.Name, args); // 封装方法名和参数 return SendMessage(request); // 转入消息发送 } } 消息结构定义 每个方法调用被封装为InvokeMethodRequest​对象，包含： 目标Grain标识（Grain ID） 方法签名（方法名、参数类型） 参数值（序列化后的二进制数据） 。 高效序列化 默认使用Bond​或MessagePack​二进制序列化，压缩数据体积 若方法标记[Immutable]​，参数按值传递；否则按引用传递（需生成Grain引用）。 远程调用路径（跨Silo） 步骤 技术实现 网关路由 客户端通过配置的Gateway端口（默认30000）发送消息至Silo集群。 一致性哈希定位 根据Grain ID哈希值确定目标Silo，路由表缓存于本地目录服务（LocalGrainDirectory​）。 Silo间通信 使用自定义二进制协议（或gRPC）经TCP端口（默认11111）传输 ‍ 是对于Orleans中基本概念的理解，喜欢这套框架的很大原因是无锁开发，高并发的天然优势，以及方便扩展集群，再加上本身又在从事unity开发，对于C#用起来也更得心应手。 具体API和开发手册可以查看https://learn.microsoft.com/zh-cn/dotnet/orleans/ ‍ " }, { "title": "Unity Shader 参考文档 - 第四部分", "url": "/post/unity-shader-reference-document-part-4-z28zd5r.html", "categories": "", "tags": "shader, unity", "date": "2025-07-31 09:07:01 +0800", "content": " Pipeline（渲染管线） 应用程序阶段（Application Stage） 阶段 描述 ​0.Application Stage​ 此阶段一般由CPU将需要在屏幕上绘制的几何体、摄像机位置、光照纹理等输出到管线的几何阶段 几何阶段（Geometry Stage） 阶段 描述 ​1.模型和视图变换（Model and View Transform）​ 模型和视图变换阶段分为模型变换和视图变换。模型变换的目的是将模型从本地空间变换到世界空间当中，而视图变换的目的是将摄像机放置于坐标原点（以使裁剪和投影操作更简单高效），将模型从世界空间变换到相机空间(观察空间)，以便后续步骤的操作 ​2.顶点着色（Vertex Shading）​ 顶点着色阶段的目的在于确定模型上顶点处的光照效果，其输出结果（颜色、向量、纹理坐标等）会被发送到光栅化阶段以进行插值操作 ​3.几何、曲面细分着色器​ 【可选项】分为几何着色器(Geometry Shader)和曲面细分着色器(Tessellation Shader)，主要是对顶点进行增加与删除修改等操作 ​4.投影（Projection）​ 投影阶段分为正交投影与透视投影，将上面的观察空间变换到齐次裁剪空间 ​5.裁剪（Clipping）​ 齐次裁剪空间会通过透视除法变换到归一化的设备坐标NDC中，然后再根据图元在视体的位置分为三种裁剪情况：1.当图元完全位于视体内部，那么它可以直接进行下一个阶段2.当图元完全位于视体外部，则不会进入下一个阶段，直接丢弃3.当图元部分位于视体内部，则需要对位于视体内的图元进行裁剪处理 ​6.屏幕映射（Screen Mapping）​ 屏幕映射阶段的主要目的，是将之前步骤得到的坐标映射到对应的屏幕坐标系上 光栅化阶段（Rasterizer Stage） 阶段 描述 ​7.三角形设定（Triangle Setup）​ 此阶段主要是将从几何阶段得到的一个个顶点通过计算来得到一个个三角形网格 ​8.三角形遍历（Triangle Traversal）​ 此阶段将进行逐像素遍历检查操作，以检查出该像素是否被上一步得到的三角形所覆盖，这个查找过程被称为三角形遍历 ​9.像素着色(Pixel Shading)​ 对应于ShaderLab中的frag函数，主要目的是定义像素的最终输出颜色 ​10.混合（Merging）​ 主要任务是合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色。此阶段还负责可见性问题（深度测试、模版测试等）的处理 Shader Lab 阶段 描述 ​1.appdata​ 将应用程序阶段的内容传递到顶点着色器中 ​2.vertex(顶点着色器)​ 本地空间&gt;(本地到世界空间矩阵)&gt;世界空间&gt;(世界到观察空间矩阵)&gt;观察空间&gt;(投影矩阵)&gt;齐次裁剪空间 ​3.透视除法​ 齐次裁剪空间作透视除法(clip.xyzw/clip.w)，变换到归一化设备坐标NDC ​4.视口变换​ 从NDC坐标变换到屏幕坐标 ​5.fragment(片断着色器)​ 用从顶点着色器的输出来当输入进行逐片断的颜色计算并输出 Platform Differences（平台差异） 裁剪空间(规范化立方体) 平台 描述 ​OpenGL​ 裁剪空间下坐标范围(-1,1) ​DirectX​ 裁剪空间下坐标范围(1,0) ​UNITY_NEAR_CLIP_VALUE​ 裁剪空间下的近剪裁值，(DX为1,OpenGL为-1) ReversedZ 类型 描述 ​Reversed direction(反向方向)​ DirectX 11、DirectX 12、PS4、Xbox One、Metal这些平台都属于反向方向深度值从近裁剪面到远裁剪面的值为[1 ~ 0]裁剪空间下的Z轴范围为[near,0] ​Traditional direction(传统方向)​ 除以上反向方向的平台以外都属于传统方向深度值从近裁剪面到远裁剪面的值为[0 ~ 1]裁剪空间下的Z轴范围为：DX平台=[0,far]OpenGL平台=[-near,far] ​UNITY_REVERSED_Z​ 判断当前平台是否开启ReversedZ ​SystemInfo.usesReversedZBuffer​ 利用C#判断当前平台是否支持ReversedZ Computer Shader（计算着色器） 内容 描述 ​SystemInfo.supportsComputeShaders​ C#中检测硬件是否支持Computer Shader。OpenGLES 3.1及以上支持Compute Shader ​#pragma kernel CSMain SOME_DEFINE DEFINE_WITH_VALUE=1337​ 声明执行函数为CSMain，可通过多行声明多个函数。SOME_DEFINE和DEFINE_WITH_VALUE是预定义宏，此项为可选项 ​ComputerShader.Dispatch(k,X,Y,Z)​ k表示要执行的核函数索引，XYZ表示开启XYZ个线程组，注意是组(每个组中会有具体的线程)! ​[numthreads(x,y,z)]​ 每个线程组中的总线程数(xyz) ​SV_GroupID​ 当前线程所在的线程组ID。[(0,0,0)~(X-1,Y-1,Z-1)] ​SV_GroupThreadID​ 当前线程在所在线程组内的ID。[(0,0,0)~(x-1,y-1,z-1)] ​SV_DispatchThreadID​ 当前线程的全局唯一ID。值为线程组*线程数+当前线程，是个三维坐标 ​SV_GroupIndex​ 当前线程在所在线程内的下标，int类型。[0~XYZ-1] GLSL（OpenGL着色语言） 基本类型 类型 描述 ​void​ 空类型，即不返回任何值 ​bool​ 布尔类型，即真或者假，true false ​int​ 带符号的整数 ​float​ 带符号的浮点数 ​vec2,vec3,vec4​ n维浮点数向量 ​bvec2,bvec3,bvec4​ n维布尔向量 ​ivec2,ivec3,ivec4​ n维向整数向量 ​mat2,mat3,mat4​ 2x2,3x3,4x4浮点数矩阵 ​clamp(a,min,max)​ 将a限制在min和max之间 ​sampler2D​ 2D纹理 ​samplerCube​ 立方体纹理 Other（其他语法） 内置渲染管线 语法 描述 ​CGPROGRAM/ENDCG​ cg代码的开始与结束 ​CGINCLUDE/ENDCG​ 通常用于定义多段vert/frag函数，然后这段CG代码会插入到所有Pass的CG中，根据当前Pass的设置来选择加载 ​Fallback \"name\"​ 备胎，当Shader中没有任何SubShader可执行时，则执行FallBack。默认值为Off，表示没有备胎。示例:FallBack “Diffuse” ​GrabPass​ GrabPass{} 抓取当前屏幕存储到_GrabTexture中，每个有此命令的Shader都会每帧执行GrabPass { “TextureName” } 抓取当前屏幕存储到自定义的TextureName中，每帧中只有第一个拥有此命令的Shader执行一次GrabPass也支持Name与Tags URP渲染管线 语法 描述 ​include​ ​#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl\"​ ​CBUFFER_START(UnityPerMaterial)/CBUFFER_END​ 将材质属性面板中的变量定义在这个常量缓冲区中，用于支持SRP Batcher ​HLSLPROGRAM/ENDHLSL​ HLSL代码的开始与结束 ​HLSLINCLUDE/ENDHLSL​ 通常用于定义多段vert/frag函数，然后这段CG代码会插入到所有Pass的CG中，根据当前Pass的设置来选择加载 ​Fallback \"name\"​ 备胎，当Shader中没有任何SubShader可执行时，则执行FallBack。默认值为Off，表示没有备胎。比如URP下默认的紫色报错Shader:Fallback “Hidden/Universal Render Pipeline/FallbackError” 通用语法 语法 描述 ​LOD​ Shader LOD，可利用脚本来控制LOD级别，通常用于不同配置显示不同的SubShader。注意SubShader要从高往低写，要不然会无法生效 ​Category{}​ 定义一组所有SubShader共享的命令，位于SubShader外面 ​CustomEditor \"name\"​ 自定义材质面板，name为自定义的脚本名称。可利用此功能对材质面板进行个性化自定义 ​Name \"MyPassName\"​ 给当前Pass指定名称，以便利用UsePass进行调用 ​UsePass \"Shader/NAME\"​ 调用其它Shader中的Pass，注意Pass的名称要全部大写！Shader的路径也要写全，以便能找到具体是哪个Shader的哪个Pass。另外加了UsePass后，也要注意相应的Properties要自行添加 Substance Painter（材质绘制） 参考网址 内容 描述 ​URL​ https://substance3d.adobe.com/documentation/spdoc/shader-api-89686018.html 材质参数 颜色(RGB) //: param custom {\"default\":[1,0.9568,0.8392],\"label\":\"灯光颜色(RGB)\",\"widget\":\"color\",\"group\":\"灯光\",\"description\":\"tooltip在这里\"} uniform vec3 _LightColor; uniform vec4 _BaseColor;(当为4维颜色时,alpha会变成滑条) 整型 //: param custom { \"default\": 0, \"label\": \"Int\",\"min\": 0, \"max\": 10,\"step\": 1,\"group\":\"Int\" } uniform int u_int1; uniform ivec2 u_int2; uniform ivec3 u_int3; uniform ivec4 u_int4; 浮点值 //: param custom { \"default\": 1, \"label\": \"Float\", \"min\": 0, \"max\": 2,\"step\": 0.1,\"group\":\"Float\" } uniform float u_float1; uniform vec2 u_float2; uniform vec3 u_float3; uniform vec4 u_float4; 开关 //: param custom { \"default\": false, \"label\": \"Boolean\",\"group\":\"Toogle\" } uniform bool u_bool; 枚举 //: param custom { //: \"default\": -1, //: \"label\": \"Combobox\", //: \"widget\": \"combobox\", //: \"values\": { //: \"Value -1\": -1, //: \"Value 0\": 0, //: \"Value 10\": 10 //: }, //: \"group\":\"Enum\" //: } uniform int u_combobox; 自定义纹理 //: param custom { \"default\": \"\", \"default_color\": [1.0, 1.0, 1.0, 1.0], \"label\": \"Texture\",\"usage\": \"texture\",\"group\":\"Texture\" } //: param custom { \"default\": \"\", \"label\": \"Texture\",\"usage\": \"environment\",\"group\":\"Texture\" } uniform sampler2D u_sampler1; vec4 tex = texture(u_sampler1, inputs.tex_coord); 内置通道图 //: param auto channel_basecolor //: param auto channel_ambientocclusion //: param auto channel_anisotropyangle //: param auto channel_anisotropylevel //: param auto channel_blendingmask //: param auto channel_diffuse //: param auto channel_displacement //: param auto channel_emissive //: param auto channel_glossiness //: param auto channel_height //: param auto channel_ior //: param auto channel_metallic //: param auto channel_normal //: param auto channel_opacity //: param auto channel_reflection //: param auto channel_roughness //: param auto channel_scattering //: param auto channel_specular //: param auto channel_specularlevel //: param auto channel_transmissive uniform SamplerSparse channel_tex; vec4 tex = textureSparse(channel_basecolor,i.sparse_coord); 用户自定义通道图 //: param auto channel_user0 //: param auto channel_user1 //: param auto channel_user2 //: param auto channel_user3 //: param auto channel_user4 //: param auto channel_user5 //: param auto channel_user6 //: param auto channel_user7 uniform SamplerSparse channel_userTex; 模型纹理 //: param auto texture_ambientocclusion (AO) //: param auto texture_curvature (曲率) //: param auto texture_id (ID图) //: param auto texture_normal (切线空间下的法线纹理) //: param auto texture_normal_ws (世界空间下的法线纹理) //: param auto texture_position (世界空间下的位置纹理) //: param auto texture_thickness (厚度纹理) uniform sampler2D u_meshTexture; 片断输出 输出 描述 ​最终输出(emissiveColorOutput + albedoOutput * diffuseShadingOutput + specularShadingOutput)​ ​void alphaOutput(1);diffuseShadingOutput(vec3(0,0,0));specularShadingOutput(vec3(0,0,0));emissiveColorOutput(vec3(0,0,0));albedoOutput(vec3(1,1,1));sssCoefficientsOutput(vec4(0,0,0,0));​ Experience（经验总结） 经验 描述 ​分支​ 尽量不要使用if或者switch去做大量的分支，否则在部分机型上会卡到怀疑人生! ​Stencil​ 红米9C上开启深度图同时Shader中启用Stencil时会导致资源显示不可见，关闭任一个即可解决 Miscellaneous（杂项技巧） PS中的混合公式（A、B为图层） 混合模式 公式 正常 ​A*(1-B.a)+B*(B.a)​ 变暗 ​min(A,B)​ 变亮 ​max(A,B)​ 正片叠底 ​A*B​ 滤色 ​1-((1-A)*(1-B))​ 颜色加深 ​A-((1-A)*(1-B))/B​ 颜色减淡 ​A+(A*B)/(1-B)​ 线性加深 ​A+B-1​ 线性减淡 ​A+B​ 叠加 ​half4 a = step(A,0.5);half4 c = a*A*B*2+(1-a)*(1-(1-A)*(1-B)*2);​ 强光 ​half4 a = step(B,0.5);half4 c =a*A*B*2+(1-a)*(1-(1-A)*(1-B)*2);​ 柔光 ​half4 a = step(B,0.5);half4 c =a*(A*B*2+A*A*(1-B*2))+(1-a)*(A*(1-B)*2+sqrt(A)*(2*B-1)​ 亮光 ​half4 a = step(B,0.5);half4 c =a*(A-(1-A)*(1-2*B)/(2*B))+(1-a)*(A+A*(2*B-1)/(2*(1-B)));​ 点光 ​half4 a = step(B,0.5);half4 c =a*(min(A,2*B))+(1-a)*(max(A,( B*2-1)));​ 线性光 ​A+2*B-1​ 排除 ​A+B-A*B*2​ 差值 ​abs(A-B)​ 深色 ​half4 a = step(B.r+B.g+B.b,A.r+A.g+A.b);half4 c =a*(B)+(1-a)*(A);​ 浅色 ​half4 a = step(B.r+B.g+B.b,A.r+A.g+A.b);half4 c =a*(A)+(1-a)*(B);​ 减去 ​A-B​ 划分 ​A/B​ UV技巧 技巧 代码 UV重映射到中心位置 ​float2 centerUV = uv * 2 - 1​ 画圆 ​float circle = smoothstep(_Radius, (_Radius + _CircleFade), length(uv * 2 - 1));​ 画矩形 ​float2 centerUV = abs(i.uv.xy * 2 - 1);float rectangleX = smoothstep(_Width, (_Width + _RectangleFade), centerUV.x);float rectangleY = smoothstep(_Heigth, (_Heigth + _RectangleFade), centerUV.y);float rectangleClamp = clamp((rectangleX + rectangleY), 0.0, 1.0);​ 黑白棋盘格 ​float2 uv = i.uv * 格子密度;uv = floor(uv) * 0.5;float c = frac(uv.x + uv.y) * 2;return c;​ 蜂窝格 ​float2 uv = i.uv * 格子密度;uv.y += floor(uv.x) * 0.5;uv = fmod(uv,1);uv = uv*2-1;uv = abs(uv);float d = max((uv.x*0.9+uv.y*0.5),uv.y);d = step(d,_Size);return d;​ 极坐标 ​float2 centerUV = (i.uv * 2 - 1);float atan2UV = 1 - abs(atan2(centerUV.g, centerUV.r) / 3.14);​ 将0-1的值控制在某个自定义的区间内 ​frac(x*n+n);​ 旋转 ​fixed t=_Time.y;float2 rot= cos(t)*i.uv+sin(t)*float2(i.uv.y,-i.uv.x);​ 从中心缩放纹理 ​half2 offset = (0.5-i.uv.xy)*_Offset;half4 baseMap = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv.xy + offset);​ 序列图 ​float2 splitUV = uv * (1/_Sequence.xy) + float2(0,_Sequence.y - 1/_Sequence.y);float time = _Time.y * _Sequence.z;uv = splitUV + float2(floor(time *_Sequence.x)/_Sequence.x,1-floor(time)/_Sequence.y);​ 顶点技巧 技巧 代码 模型中心点坐标 ​float3 objCenterPos = mul( unity_ObjectToWorld, float4( 0, 0, 0, 1 ) ).xyz;​ 获取模型的旋转角度(Y轴) ​float cosA = unity_ObjectToWorld._11;float sinA = unity_ObjectToWorld._13;float angle = atan2(sinA, cosA);angle *= 180 / 3.1415926;if (angle &lt; 0) angle += 360;​ BillBoard 在顶点着色器中添加相机空间转换代码 网格阴影 ​half4 worldPos = mul(unity_ObjectToWorld, v.vertex);worldPos.y = 2.47;worldPos.xz += fixed2(阴影X方向,阴影Z方向)*v.vertex.y;o.pos = mul(UNITY_MATRIX_VP,worldPos);​ 颜色技巧 技巧 代码 去色 ​dot(rgb,fixed3(0.22,0.707,0.071))​ RGB2HSV 使用专门的转换函数 HSV2RGB 使用专门的转换函数 利用HSV对颜色进行调整 ​half3 hsv = RGB2HSV(baseMap.rgb);baseMap.rgb = HSV2RGB(float3((hsv.x + _HSVValue.x), (hsv.y * _HSVValue.y), (hsv.z * _HSVValue.z)));​ 随机(单通道) ​frac(sin(dot(uv, float2(127.1, 311.7))) * 43758.5453);​ 随机(三通道) ​float3 q = float3(dot(p,float2(127.1,311.7)),dot(p,float2(269.5,183.3)),dot(p,float2(419.2,371.9)));return frac(sin(q)*43758.5453);​ 深度技巧 技巧 代码 从深度重建世界坐标 ​float2 screenUV = i.positionCS/_ScreenParams.xy;half depthMap = SAMPLE_TEXTURE2D(_CameraDepthTexture, sampler_CameraDepthTexture, screenUV).r;float3 positionWS = ComputeWorldSpacePosition(screenUV, depth, UNITY_MATRIX_I_VP);​ 光照技巧 技巧 代码 Matcap ​o.normalWS = TransformObjectToWorldNormal(v.normalOS);o.uv.zw = mul(UNITY_MATRIX_V, float4(o.normalWS, 0.0)).xy * 0.5 + 0.5;​ 其他技巧 技巧 代码 菲涅尔 ​half3 worldViewDir = normalize (UnityWorldSpaceViewDir (i.worldPos));float ndotv = dot (i.normal, worldViewDir);float fresnel = (0.2 + 2.0 * pow (1.0 - ndotv, 2.0));​ XRay射线 新建一个Pass，设置Blend，Zwrite Off关闭深度写入，Ztest greater深度测试设置为大于 Dither 使用专门的Dither函数（2x2、4x4、8x8） 总结 这个完整的Unity Shader参考文档涵盖了： Semantics（语义） - 数据传递的关键字 Properties（属性） - 材质面板中的可调参数 Math（数学运算） - 常用的数学函数和运算 BuildIn Variables（内置变量） - Unity提供的内置变量和函数 BuildIn Transformation（内置变换） - 空间变换矩阵和方法 Lighting（光照） - 各种光照模型和实现 Tags（标签） - 渲染管线和队列控制 Pragma（编译指令） - 编译控制和变体管理 Render State（渲染状态） - 渲染状态设置 Transformation（空间变换） - 详细的变换矩阵和方法 Predefined Macros（预定义宏） - Unity预定义的宏 Pipeline（渲染管线） - 渲染管线流程 Platform Differences（平台差异） - 不同平台的差异 Computer Shader（计算着色器） - 计算着色器相关内容 GLSL（OpenGL着色语言） - GLSL语法 Other（其他语法） - 其他shader语法 Substance Painter（材质绘制） - Substance Painter中的shader语法 Experience（经验总结） - 实际开发中的经验 Miscellaneous（杂项技巧） - 实用的shader技巧和算法 这个文档可以作为Unity Shader开发的完整参考手册，帮助开发者快速查找和使用各种shader功能。 " }, { "title": "Unity Shader 参考文档 - 第三部分", "url": "/post/unity-shader-reference-document-part-3-z2bufyb.html", "categories": "", "tags": "shader, unity", "date": "2025-07-31 09:06:46 +0800", "content": " Pragma（编译指令） 基础编译指令 指令 描述 ​#pragma target 2.0​ Shader编绎目标级别，默认值为2.5• 2.0: 基础功能• 2.5: derivatives• 3.0: 2.5 + interpolators10 + samplelod + fragcoord• 3.5: 3.0 + interpolators15 + mrt4 + integers + 2darray + instancing• 4.0: 3.5 + geometry• 4.5: 3.5 + compute + randomwrite• 4.6: 4.0 + cubearray + tesshw + tessellation• 5.0: 4.0 + compute + randomwrite + tesshw + tessellation ​#pragma require xxx​ 表明shader需要的特性功能• interpolators10: 至少支持10个插值器• interpolators15: 至少支持15个插值器• interpolators32: 至少支持32个插值器• mrt4: 至少支持4个Multiple Render Targets• mrt8: 至少支持8个Multiple Render Targets• derivatives: 片断着色器支持偏导函数(ddx/ddy)• samplelod: 纹理LOD采样• fragcoord: 将像素的位置传入到片断着色器中• integers: 支持真正的整数类型• 2darray: 2D纹理数组• cubearray: Cubemap纹理数组• instancing: GPU实例化• geometry: 几何着色器• compute: Compute Shader• randomwrite: 可以编写任意位置的一些纹理和缓冲区 ​#pragma shader_feature​ 变体声明，常用于不需要程序控制开关的关键字，在编缉器的材质上设置，打包时会自动过滤 ​#pragma shader_feature_local​ 声明本地变体(shader_feature)，unity2019才支持的功能，每个Shader最多可以有64个本地变体 ​#pragma multi_compile​ 变体声明，在打包时会把所有变体都打包进去，这是它与feature的区别 ​#pragma multi_compile_local​ 声明本地变体(multi_compile)，unity2019才支持的功能 ​#pragma multi_compile_fog​ 雾类型定义：FOG_EXP FOG_EXP2 FOG_LINEAR ​#pragma skip_variants XXX01 XXX02...​ 剔除指定的变体，可同时剔除多个 内置渲染管线特定指令 指令 描述 ​#pragma multi_compile_fwdbase​ 定义在LightMode = ForwardBase的Pass中，生成Unity在ForwardBase中需要的各种内置宏 ​#pragma multi_compile_fwdadd​ 定义在LightMode=ForwardAdd的Pass中，生成Unity在ForwardAdd中需要的各种内置宏 ​#pragma multi_compile_shadowcaster​ 定义在LightMode=ShadowCaster的Pass中，会自动生成SHADOWS_DEPTH和SHADOW_CUBE宏 URP特定指令 指令 描述 ​#pragma prefer_hlslcc gles​ 将HLSL代码转换为GLSL代码时，优先使用HLSLcc转换器 ​#include \"XXX.hlsl\"​ 引入hlsl文件 ​#include_with_pragmas \"XXX.hlsl\"​ 引入hlsl文件，同时也会使用hlsl文件中的#pragma指令 ​#pragma editor_sync_compilation​ 强制某个Shader以同步的方式进行编绎 平台相关指令 指令 描述 ​#pragma only_renderers​ 仅编译指定平台的Shader• d3d11 - Direct3D 11/12• glcore - OpenGL 3.x/4.x• gles - OpenGL ES 2.0• gles3 - OpenGL ES 3.x• metal - iOS/Mac Metal• vulkan - Vulkan• d3d11_9x - Direct3D 11 9.x功能级别• xboxone - Xbox One• ps4 - PlayStation 4• psp2 - PlayStation Vita• n3ds - Nintendo 3DS• wiiu - Nintendo Wii U ​#pragma exclude_renderers​ 剔除掉指定平台的相关代码 ​#pragma once​ 通常添加在通用的.hlsl文件中，以此来避免多次或者重复引用和编绎 其他指令 指令 描述 ​#define NAME​ 定义一个叫NAME的字段 ​#define NAME 1​ 定义一个叫NAME的字段并且它的值为1 ​#error xxx​ 多用于分支的判断中，利用此语句可直接输出一条报错信息 ​#pragma fragmentoption ARB_precision_hint_fastest​ 最快的，意思就是会用低精度 ​#pragma fragmentoption ARB_precision_hint_nicest​ 最佳的，会用高精度 ​#pragma enable_d3d11_debug_symbols​ 开启调试，便于在调试工具中进行查看分析 ​#pragma skip_optimizations &lt;gles/vulkan...&gt;​ 调试用，禁用某平台的优化 ​#pragma shader_feature EDITOR_VISUALIZATION​ 开启Material Validation，Scene视图中的模式 Render State（渲染状态） Cull（背面剔除） Cull Back | Front | Off Back: 表示剔除背面，也就是显示正面，这也是最常用的设置 Front: 表示剔除前面，只显示背面 Off: 表示关闭剔除，也就是正反面都渲染 模版测试（Stencil） Stencil { Ref [_Stencil] ReadMask [_StencilReadMask] WriteMask [_StencilWriteMask] Comp [_StencilComp] Pass [_StencilOp] Fail [_Fail] ZFail [_ZFail] } Comp（比较操作） 操作 描述 ​Less​ 相当于”&lt;”操作，即仅当左边&lt;右边，模板测试通过，渲染像素 ​Greater​ 相当于”&gt;”操作，即仅当左边&gt;右边，模板测试通过，渲染像素 ​Lequal​ 相当于”&lt;=”操作，即仅当左边&lt;=右边，模板测试通过，渲染像素 ​Gequal​ 相当于”&gt;=”操作，即仅当左边&gt;=右边，模板测试通过，渲染像素 ​Equal​ 相当于”=”操作，即仅当左边=右边，模板测试通过，渲染像素 ​NotEqual​ 相当于”!=”操作，即仅当左边!=右边，模板测试通过，渲染像素 ​Always​ 不管公式两边为何值，模板测试总是通过，渲染像素 ​Never​ 不管公式两边为何值，模板测试总是失败，像素被抛弃 模版缓冲区的更新 操作 描述 ​Keep​ 保留当前缓冲中的内容，即stencilBufferValue不变 ​Zero​ 将0写入缓冲，即stencilBufferValue值变为0 ​Replace​ 将参考值写入缓冲，即将referenceValue赋值给stencilBufferValue ​IncrSat​ 将当前模板缓冲值加1，如果stencilBufferValue超过255了，那么保留为255 ​DecrSat​ 将当前模板缓冲值减1，如果stencilBufferValue超过为0，那么保留为0 ​Invert​ 将当前模板缓冲值（stencilBufferValue）按位取反 ​IncrWrap​ 当前缓冲的值加1，如果缓冲值超过255了，那么变成0 ​DecrWrap​ 当前缓冲的值减1，如果缓冲值已经为0，那么变成255 深度缓冲 |设置|描述| | ————–| ———————————————————————————————| |ZTest (Less|Greater| |​ZTest[unity_GUIZTestMode]​|unity_GUIZTestMode用于UI材质中，此值默认为LEqual，仅当UI中Canvas模式为Overlay时，值为Always| |ZWrite On|Off| |ZClip True|False| |​Offset Factor, Units`​|深度偏移，offset = (m * factor) + (r * units)，默认值为0,0| 颜色遮罩 ColorMask RGB | A | 0 | R、G、B、A的任意组合 颜色遮罩，默认值为：RGBA，表示写入RGBA四个通道。 混合（Blend） 源颜色*SrcFactor + 目标颜色*DstFactor 混合因子 因子 描述 ​One​ 源或目标的完整值 ​Zero​ 0 ​SrcColor​ 源的颜色值 ​SrcAlpha​ 源的Alpha值 ​DstColor​ 目标的颜色值 ​DstAlpha​ 目标的Alpha值 ​OneMinusSrcColor​ 1-源颜色得到的值 ​OneMinusSrcAlpha​ 1-源Alpha得到的值 ​OneMinusDstColor​ 1-目标颜色得到的值 ​OneMinusDstAlpha​ 1-目标Alpha得到的值 常用的几种混合类型 Blend SrcAlpha OneMinusSrcAlpha // Traditional transparency Blend One OneMinusSrcAlpha // Premultiplied transparency Blend One One // Additive Blend OneMinusDstColor One // Soft Additive Blend DstColor Zero // Multiplicative Blend DstColor SrcColor // 2x Multiplicative 混合操作的具体运算符 操作 描述 ​Add​ 源+目标 ​Sub​ 源-目标 ​RevSub​ 目标-源 ​Min​ 源与目标中最小值 ​Max​ 源与目标中最大值 其他 设置 描述 AlphaToMask On|Off   Conservative True|False   Transformation（空间变换） 空间变换(矩阵) 矩阵 描述 ​UNITY_MATRIX_M​ 模型变换矩阵:unity_ObjectToWorld ​UNITY_MATRIX_I_M​ 模型变换逆矩阵:unity_WorldToObject ​UNITY_MATRIX_V​ 视图变换矩阵:unity_MatrixV ​UNITY_MATRIX_I_V​ 视图变换逆矩阵:unity_MatrixInvV ​UNITY_MATRIX_P​ 投影变换矩阵:OptimizeProjectionMatrix(glstate_matrix_projection) ​UNITY_MATRIX_I_P​ 投影变换逆矩阵:ERROR_UNITY_MATRIX_I_P_IS_NOT_DEFINED ​UNITY_MATRIX_VP​ 视图投影变换矩阵:unity_MatrixVP ​UNITY_MATRIX_I_VP​ 视图投影变换逆矩阵:_InvCameraViewProj ​UNITY_MATRIX_MV​ 模型视图变换矩阵:mul(UNITY_MATRIX_V, UNITY_MATRIX_M) ​UNITY_MATRIX_T_MV​ 模型视图变换转置矩阵:transpose(UNITY_MATRIX_MV) ​UNITY_MATRIX_IT_MV​ 模型视图变换转置逆矩阵:transpose(mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V)) ​UNITY_MATRIX_MVP​ 模型视图投影变换矩阵:mul(UNITY_MATRIX_VP, UNITY_MATRIX_M) 空间变换(方法) 内置渲染管线 函数 描述 ​UnityObjectToClipPos(v.vertex)​ 将模型空间下的顶点转换到齐次裁剪空间 ​UnityObjectToWorldNormal(v.normal)​ 将模型空间下的法线转换到世界空间(已归一化) ​UnityObjectToWorldDir (v.tangent)​ 将模型空间下的切线转换到世界空间(已归一化) ​UnityWorldSpaceLightDir (i.worldPos)​ 世界空间下顶点到灯光方向的向量(未归一化) ​UnityWorldSpaceViewDir (i.worldPos)​ 世界空间下顶点到视线方向的向量(未归一化) URP渲染管线 函数 描述 ​float3 TransformObjectToWorld(float3 positionOS)​ 模型空间»世界空间 ​float3 TransformWorldToObject(float3 positionWS)​ 世界空间»模型空间 ​float3 TransformWorldToView(float3 positionWS)​ 世界空间»视图空间 ​float4 TransformObjectToHClip(float3 positionOS)​ 模型空间»齐次裁剪空间 (比MVP高效) ​float4 TransformWorldToHClip(float3 positionWS)​ 世界空间»齐次裁剪空间 ​float4 TransformWViewToHClip(float3 positionVS)​ 视图空间»齐次裁剪空间 ​real3 TransformObjectToWorldDir(real3 dirOS)​ (向量)模型空间»世界空间 ​real3 TransformWorldToObjectDir(real3 dirWS)​ (向量)世界空间»模型空间 ​real3 TransformWorldToViewDir(real3 dirWS)​ (向量)世界空间»视图空间 ​real3 TransformWorldToHClipDir(real3 directionWS)​ (向量)世界空间&gt;齐次裁剪空间 ​float3 TransformObjectToWorldNormal(float3 normalOS)​ (法线)模型空间»世界空间(已归一化) ​float3 TransformWorldToObjectNormal(float3 normalWS)​ (法线)世界空间»模型空间(已归一化) 基础变换矩阵 矩阵类型 矩阵定义 平移矩阵 ​float4x4 M_translate = float4x4( 1, 0, 0, T.x, 0, 1, 0, T.y, 0, 0, 1, T.z, 0, 0, 0, 1);​ 缩放矩阵 ​float4x4 M_scale = float4x4( S.x, 0, 0, 0, 0, S.y, 0, 0, 0, 0, S.z, 0, 0, 0, 0, 1);​ 旋转矩阵(X轴) ​float4x4 M_rotationX = float4x4( 1, 0, 0, 0, 0, cos(θ), -sin(θ), 0, 0, sin(θ), cos(θ), 0, 0, 0, 0, 1);​ 旋转矩阵(Y轴) ​float4x4 M_rotationY = float4x4( cos(θ), 0, sin(θ), 0, 0, 1, 0, 0, -sin(θ), 0, cos(θ), 0, 0, 0, 0, 1);​ 旋转矩阵(Z轴) ​float4x4 M_rotationZ = float4x4( cos(θ), -sin(θ), 0, 0, sin(θ), cos(θ), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);​ 变换规则 将P点从A空间变换到B空间 P_B = M_AB * P_A = (M_BA)^-1 * P_A = (M_BA)^T * P_A Predefined Macros（预定义宏） Target platform 宏 描述 ​SHADER_API_D3D11​ Direct3D 11 ​SHADER_API_GLCORE​ 桌面OpenGL核心(GL3/4) ​SHADER_API_GLES​ OpenGl ES 2.0 ​SHADER_API_GLES3​ OpenGl ES 3.0/3.1 ​SHADER_API_METAL​ IOS/Mac Metal ​SHADER_API_VULKAN​ Vulkan ​SHADER_API_D3D11_9X​ Direct3D 11 9.x功能级别 ​SHADER_API_PS4​ PS4平台，SHADER_API_PSSL同时也会被定义 ​SHADER_API_XBOXONE​ Xbox One ​SHADER_API_MOBILE​ 所有移动平台(GLES/GLES3/METAL) ​SHADER_API_DESKTOP​ Window、Mac和Linux桌面平台 流程控制 宏 描述 ​#define UNITY_BRANCH [branch]​ 添加在if语句上面，表示此语句会根据判断只执行符合条件的代码，有跳转指令 ​#define UNITY_FLATTEN [flatten]​ 添加在if语句上面，表示此语句会执行全部代码，然后根据条件来选择某个具体的结果，没有跳转指令 ​#define UNITY_UNROLL [unroll]​ 添加在for语句上面，表示此循环在编绎时会展开所有循环代码 ​#define UNITY_UNROLLX(_x) [unroll(_x)]​ 添加在for语句上面，功能同上，同时可以指定具体的展开次数 ​#define UNITY_LOOP [loop]​ 添加在for语句上面，表示此循环不可展开，正常执行跳转 Shader target model 宏 描述 ​#if SHADER_TARGET &lt; 30​ 对应于#pragma target的值，2.0就是20，3.0就是30 Unity version 宏 描述 ​#if UNITY_VERSION &gt;= 500​ Unity版本号判断，500表示5.0.0 Platform difference helpers 宏 描述 ​UNITY_UV_STARTS_AT_TOP​ 一般此判断当前平台是DX(UV原点在左上角)还是OpenGL(UV原点在左下角) ​UNITY_NO_SCREENSPACE_SHADOWS​ 定义移动平台不进行Cascaded ScreenSpace Shadow UI 宏 描述 ​UNITY_UI_CLIP_RECT​ 当父级物体有Rect Mask 2D组件时激活需要先手动定义此变体#pragma multi_compile _ UNITY_UI_CLIP_RECT同时需要声明：_ClipRect(一个四维向量)UnityGet2DClipping (float2 position, float4 clipRect)即可实现遮罩 Lighting 宏 描述 ​UNITY_SHOULD_SAMPLE_SH​ 是否进行计算SH（光照探针与顶点着色） ​UNITY_SAMPLE_FULL_SH_PER_PIXEL​ 光照贴图uv和来自SHL2的环境颜色在顶点和像素内插器中共享 ​HANDLE_SHADOWS_BLENDING_IN_GI​ 当同时定义了SHADOWS_SCREEN与LIGHTMAP_ON时开启 ​UNITY_SHADOW_COORDS(N)​ 定义一个float4类型的变量_ShadowCoord，语义为第N个TEXCOORD ​V2F_SHADOW_CASTER;​ 用于”LightMode” = “ShadowCaster”中，相当于定义了float4 pos:SV_POSITION Other 宏 描述 ​UNITY_SHADER_NO_UPGRADE​ 另Shader不自动更新API，只需把语句用注释的形式写在shader中任意位置即可 URP特定宏 宏 描述 ​UNITY_NO_DXT5nm​ 法线纹理是否不采用DXT5压缩，移动平台是，非移动平台否 ​UNITY_ASTC_NORMALMAP_ENCODING​ 当在移动平台中，法线纹理采用类DXT5nm的压缩时启用 ​SHADERGRAPH_PREVIEW​ 在ShaderGraph中的Custom Function自义定节点上使用，用于判断是否处于SG面板预览中 " }, { "title": "Unity Shader 参考文档 - 第二部分", "url": "/post/unity-shader-reference-document-part-2-zv2tg1.html", "categories": "", "tags": "shader, unity", "date": "2025-07-31 09:06:34 +0800", "content": " BuildIn Variables（内置变量） 基础函数 函数 描述 ​UNITY_INITIALIZE_OUTPUT(type,name)​ 由于HLSL编缉器不接受没有初始化的数据，所以为了支持所有平台，从而需要使用此方法进行初始化 ​TRANSFORM_TEX(i.uv,_MainTex)​ 对UV进行Tiling与Offset变换 ​float3 UnityWorldSpaceLightDir( float3 worldPos )​ 返回顶点到灯光的向量 Camera and Screen 内置渲染管线 变量 描述 ​_WorldSpaceCameraPos​ 主相机的世界坐标位置，类型：float3 ​UnityWorldSpaceViewDir(i.worldPos)​ 世界空间下的相机方向(顶点到主相机)，类型：float3 ​_CameraDepthTexture​ 深度纹理，需要在脚本中开启相机的深度：Camera.main.depthTextureMode = DepthTextureMode.Depth ​ComputeScreenPos(float4 pos)​ pos为裁剪空间下的坐标位置，返回的是某个投影点下的屏幕坐标位置 ​_ScreenParams​ 屏幕的相关参数，单位为像素。x表示屏幕的宽度，y表示屏幕的高度，z表示1+1/屏幕宽度，w表示1+1/屏幕高度 URP渲染管线 变量 描述 ​_WorldSpaceCameraPos​ 相机在世界空间下的位置坐标(xyz) ​_ZBufferParams​ Z Buffer参数，包含近远裁剪面信息 ​_CameraDepthTexture​ 深度纹理，在PipelineAsset中勾选DepthTexture ​_CameraOpaqueTexture​ 抓屏纹理，在PipelineAsset中勾选OpaqueTexture ​_ScreenParams​ 屏幕的相关参数，单位为像素 ​_ScaledScreenParams​ 同上，但是有考虑到RenderScale的影响 Time 变量 描述 ​_Time​ 时间，主要用于在Shader做动画，类型：float4x = t/20y = tz = t2w = t3 ​_SinTime​ t是时间的正弦值，返回值(-1~1)x = t/8y = t/4z = t/2w = t ​_CosTime​ t是时间的余弦值，返回值(-1~1)x = t/8y = t/4z = t/2w = t ​unity_DeltaTime​ dt是时间增量，smoothDt是平滑时间x = dty = 1/dtz = smoothDtw = 1/smoothDt Lighting (内置渲染管线) 变量 描述 ​_LightColor0​ 主平行灯的颜色值，rgb = 颜色x亮度；a = 亮度 ​_WorldSpaceLightPos0​ 平行灯：(xyz=位置,z=0)，已归一化其它类型灯：(xyz=位置,z=1) ​unity_WorldToLight​ 从世界空间转换到灯光空间下，等同于旧版的_LightMatrix0 Fog and Ambient (内置渲染管线) 变量 描述 ​unity_AmbientSky​ 环境光（Gradient）中的Sky Color ​unity_AmbientEquator​ 环境光（Gradient）中的Equator Color ​unity_AmbientGround​ 环境光（Gradient）中的Ground Color ​UNITY_LIGHTMODEL_AMBIENT​ 环境光(Color)中的颜色，等同于环境光（Gradient）中的Sky Color GPU Instancing 内容 描述 实现步骤 用于对多个对象(网格一样，材质一样，但是材质属性不一样)合批，单个合批最大上限为511个对象1. #pragma multi_compile_instancing 添加此指令后会使材质面板上曝露Instaning开关2. UNITY_VERTEX_INPUT_INSTANCE_ID 在顶点着色器的输入(appdata)和输出(v2f可选)中添加(uint instanceID : SV_InstanceID)3. 构建需要实例化的额外数据4. UNITY_SETUP_INSTANCE_ID(v) 放在顶点着色器/片断着色器(可选)中最开始的地方5. UNITY_TRANSFER_INSTANCE_ID(v, o) 当需要将实例化ID传到片断着色器时，在顶点着色器中添加6. UNITY_ACCESS_INSTANCED_PROP(arrayName, propName) 在片断着色器中访问具体的实例化变量 Instancing选项 对GPU Instancing进行一些设置• #pragma instancing_options forcemaxcount:batchSize 强制设置单个批次内Instancing的最大数量• #pragma instancing_options maxcount:batchSize 设置单个批次内Instancing的最大数量 BuildIn Transformation（内置变换） 空间变换(矩阵) 内置渲染管线 矩阵 描述 ​UNITY_MATRIX_MVP​ 模型空间»投影空间 ​UNITY_MATRIX_MV​ 模型空间»观察空间 ​UNITY_MATRIX_V​ 视图空间 ​UNITY_MATRIX_P​ 投影空间 ​UNITY_MATRIX_VP​ 视图空间&gt;投影空间 ​unity_ObjectToWorld​ 本地空间»世界空间 ​unity_WorldToObject​ 世界空间&gt;本地空间 URP渲染管线 函数 描述 ​GetObjectToWorldMatrix()​ 本地空间到世界空间的矩阵 ​GetWorldToObjectMatrix()​ 世界空间到本地空间的矩阵 ​GetWorldToViewMatrix()​ 世界空间到观察空间的矩阵 ​GetWorldToHClipMatrix()​ 世界空间到齐次裁剪空间的矩阵 ​GetViewToHClipMatrix()​ 观察空间到齐次裁剪空间的矩阵 空间变换(方法) 内置渲染管线 函数 描述 ​UnityObjectToClipPos(v.vertex)​ 将模型空间下的顶点转换到齐次裁剪空间 ​UnityObjectToWorldNormal(v.normal)​ 将模型空间下的法线转换到世界空间(已归一化) ​UnityObjectToWorldDir (v.tangent)​ 将模型空间下的切线转换到世界空间(已归一化) ​UnityWorldSpaceLightDir (i.worldPos)​ 世界空间下顶点到灯光方向的向量(未归一化) ​UnityWorldSpaceViewDir (i.worldPos)​ 世界空间下顶点到视线方向的向量(未归一化) URP渲染管线 函数 描述 ​float3 TransformObjectToWorld (float3 positionOS)​ 从本地空间变换到世界空间 ​float3 TransformWorldToObject (float3 positionWS)​ 从世界空间变换到本地空间 ​float3 TransformWorldToView(float3 positionWS)​ 从世界空间变换到视图空间 ​float4 TransformObjectToHClip(float3 positionOS)​ 将模型空间下的顶点变换到齐次裁剪空间 ​float4 TransformWorldToHClip(float3 positionWS)​ 将世界空间下的顶点变换到齐次裁剪空间 ​float4 TransformWViewToHClip (float3 positionVS)​ 将视图空间下的顶点变换到齐次裁剪空间 ​float3 TransformObjectToWorldNormal (float3 normalOS)​ 将法线从本地空间变换到世界空间(已归一化) 基础变换矩阵 矩阵类型 矩阵定义 平移矩阵 ​float4x4 M_translate = float4x4( 1, 0, 0, T.x, 0, 1, 0, T.y, 0, 0, 1, T.z, 0, 0, 0, 1);​ 缩放矩阵 ​float4x4 M_scale = float4x4( S.x, 0, 0, 0, 0, S.y, 0, 0, 0, 0, S.z, 0, 0, 0, 0, 1);​ 旋转矩阵(X轴) ​float4x4 M_rotationX = float4x4( 1, 0, 0, 0, 0, cos(θ), sin(θ), 0, 0, -sin(θ), cos(θ), 0, 0, 0, 0, 1);​ 旋转矩阵(Y轴) ​float4x4 M_rotationY = float4x4( cos(θ), 0, sin(θ), 0, 0, 1, 0, 0, -sin(θy), 0, cos(θ), 0, 0, 0, 0, 1);​ 旋转矩阵(Z轴) ​float4x4 M_rotationZ = float4x4( cos(θ), sin(θ), 0, 0, -sin(θ), cos(θ), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);​ Lighting（光照） 光照模型 Lambertian Diffuse = Ambient + Kd * LightColor * max(0,dot(N,L)) Diffuse: 最终物体上的漫反射光强 Ambient: 环境光强度，为了简化计算，环境光强采用一个常数表示 Kd: 物体材质对光的反射系数 LightColor: 光源的强度 N: 顶点的单位法线向量 L: 顶点指向光源的单位向量 Phong Specular = SpecularColor * Ks * pow(max(0,dot(R,V)), Shininess) Specular: 最终物体上的反射高光光强 SpecularColor: 反射光的颜色 Ks: 反射强度系数 R: 反射向量，可使用2 * N * dot(N,L) - L或者reflect(-L,N)获得 V: 观察方向 N: 顶点的单位法线向量 L: 顶点指向光源的单位向量 Shininess: 乘方运算来模拟高光的变化 Blinn-Phong Specular = SpecularColor * Ks * pow(max(0,dot(N,H)), Shininess) H: 入射光线L与视线V的中间向量，也称为半角向量H = normalize(L+V) Disney Principled BRDF f(l,v) = diffuse + D(h)F(v,h)G(l,v,h)/4cos(n·l)cos(n·v) f(l,v) : 双向反射分布函数的最终值，l表示光的方向，v表示视线的方向 diffuse: 漫反射 D(h) : 法线分布函数(Normal Distribution Function) F(v,h) : 菲涅尔方程(Fresnel Equation) G(l,v,h) : 几何函数(Geometry Function) 法线贴图 内置渲染管线 appdata中定义NORMAL与TANGENT语义 v2f中声明三个变量用于组成成切线空间下的旋转矩阵 在顶点着色器中执行切线空间转换 在片断着色器中计算出世界空间下的法线 URP渲染管线 Attributes中定义NORMAL与TANGENT语义 Varyings中声明三个变量用于组成成切线空间下的旋转矩阵 在顶点着色器中执行切线空间转换 在片断着色器中计算出世界空间下的法线 阴影 内置渲染管线 生成阴影: 添加”LightMode” = “ShadowCaster”的Pass 采样阴影: 使用UNITY_SHADOW_COORDS、TRANSFER_SHADOW、UNITY_LIGHT_ATTENUATION URP渲染管线 投射阴影: 添加LightMode=ShadowCaster的pass即可渲染进lightmap产生投影 接收阴影: 使用相关宏定义来控制阴影接收 雾效 内置渲染管线 方案一: 常规方案，使用UNITY_FOG_COORDS、UNITY_TRANSFER_FOG、UNITY_APPLY_FOG 方案二: 当在v2f中有定义worldPos时，可以把worldPos.w利用起来做为雾效值 URP渲染管线 使用#pragma multi_compile_fog 在Varyings中定义fogCoord 在顶点着色器中添加ComputeFogFactor 在片断着色器中添加MixFog Tags（标签） 基础语法 Tags { \"TagName1\" = \"Value1\" \"TagName2\" = \"Value2\" } RenderPipeline（URP） 标签 描述 ​\"RenderPipeline\" = \"UniversalPipeline\"​ 渲染管线标记，对应的管线C#代码UniversalRenderPipeline.cs中的Shader.globalRenderPipeline = UniversalPipeline,LightweightPipeline Queue（渲染队列） 队列 值 描述 ​\"Queue\" = \"Background\"​ 1000 此队列的对象最先进行渲染 ​\"Queue\" = \"Geometry\"​ 2000 默认值，通常用于不透明对象，比如场景中的物件与角色等 ​\"Queue\" = \"AlphaTest\"​ 2450 要么完全透明要么完全不透明，多用于利用贴图来实现边缘透明的效果 ​\"Queue\" = \"Transparent\"​ 3000 常用于半透明对象，渲染时从后往前进行渲染 ​\"Queue\" = \"Overlay\"​ 4000 此渲染队列用于叠加效果，最后渲染的东西应该放在这里 LightMode（Pass中） 内置渲染管线 模式 描述 ​ForwardBase​ 用于前向渲染路径，支持环境光、主像素光、球谐光照与烘焙光照 ​ForwardAdd​ 用于前向渲染路径，支持额外的逐像素光照，每盏灯一个Pass ​Deferred​ 用于延迟渲染 ​ShadowCaster​ 深度渲染与Shadowmap ​MotionVectors​ 运动矢量 ​Always​ 永远渲染 URP渲染管线 模式 描述 ​\"LightMode\" = \"UniversalForward\"​ 用于前向渲染路径，所有的灯光都在这一个pass中执行 ​\"LightMode\" = \"SRPDefaultUnlit\"​ 用于在额外需要一个pass时使用 ​\"LightMode\" = \"ShadowCaster\"​ 用于生成阴影贴图ShadowMap ​\"LightMode\" = \"DepthOnly\"​ 用于生成相机下的深度信息 ​\"LightMode\" = \"DepthNormals\"​ 用于生成相机下的深度法线信息 ​\"LightMode\" = \"Meta\"​ 仅在光照烘焙时才会使用此Pass ​\"LightMode\" = \"Universal2D\"​ 用于URP使用2D渲染器时绘制物体的Pass RenderType 类型 描述 ​\"RenderType\" = \"Opaque\"​ 大多数不透明着色器 ​\"RenderType\" = \"Transparent\"​ 大多数半透明着色器，比如粒子、特效、字体等 ​\"RenderType\" = \"TransparentCutout\"​ 透贴着色器，多用于植被等 ​\"RenderType\" = \"Background\"​ 多用于天空盒着色器 ​\"RenderType\" = \"Overlay\"​ GUI、光晕着色器等 其他标签 标签 描述 ​\"DisableBatching\" = \"True\"​ 禁用批处理 ​\"ForceNoShadowCasting\" = \"True\"​ 强制关闭阴影投射 ​\"IgnoreProjector\" = \"True\"​ 不受投影器影响 ​\"CanUseSpriteAtlas\" = \"True\"​ 支持精灵打包图集 ​\"PreviewType\" = \"Plane\"​ 材质面板中的预览模型显示为平面 ​\"PerformanceChecks\" = \"True\"​ 开启性能检测提示 " }, { "title": "Unity Shader 参考文档", "url": "/post/unity-shader-reference-documentation-8dcqe.html", "categories": "", "tags": "shader, unity", "date": "2025-07-31 09:06:12 +0800", "content": " Semantics（语义） 应用程序到顶点着色器的数据（appdata） 语义 描述 ​float4 vertex : POSITION;​ 顶点的本地坐标 ​uint vid : SV_VertexID;​ 顶点的索引ID ​float3 normal : NORMAL;​ 顶点的法线信息 ​float4 tangent : TANGENT;​ 顶点的切线信息 ​float4 texcoord : TEXCOORD0;​ 顶点的UV1信息 ​float4 texcoord1 : TEXCOORD1;​ 顶点的UV2信息 ​float4 texcoord2 : TEXCOORD2;​ 顶点的UV3信息 ​float4 texcoord3 : TEXCOORD3;​ 顶点的UV4信息 ​fixed4 color : COLOR;​ 顶点的顶点色信息 顶点着色器到片断着色器的数据 (v2f) 语义 描述 ​float4 pos:SV_POSITION;​ 顶点的齐次裁剪空间下的坐标，默认情况下用POSITION也可以(PS4下不支持)，但是为了支持所有平台，所以最好使用SV_POSITION ​TEXCOORD0~N​ 例如TEXCOORD0、TEXCOORD1、TEXCOORD2…等等 ​COLOR0~N​ 例如COLOR0、COLOR1、COLOR2…等等，主要用于低精度数据，由于平台适配问题，不建议在v2f中使用COLORn ​float face:VFACE​ 如果渲染表面朝向摄像机，则Face节点输出正值1，如果远离摄像机，则输出负值-1 ​UNITY_VPOS_TYPE screenPos : VPOS​ 当前片断在屏幕上的位置(单位是像素,可除以_ScreenParams.xy来做归一化)，此功能仅支持#pragma target 3.0及以上编译指令 ​uint vid : SV_VertexID​ 顶点着色器可以接收具有”顶点编号”作为无符号整数的变量，当需要从纹理或ComputeBuffers中获取额外的顶点数据时比较有用，此语义仅支持#pragma target 3.5及以上 注意事项： OpenGL ES2.0支持最多8个 OpenGL ES3.0支持最多16个 片断着色器输出的数据（fragOutput） 语义 描述 ​fixed4 color : SV_Target;​ 默认RenderTarget，也是默认输出的屏幕上的颜色，同时支持SV_Target1、SV_Target2…等等 ​fixed depth : SV_Depth;​ 通过在片断着色器中输出SV_DEPTH语义可以更改像素的深度值，注意此功能相对会消耗性能，在没有特别需求的情况下尽量不要用 Properties（属性） 基础属性类型 属性 描述 ​_Int(\"Int\", Int) = 1​ 类型：整型Cg/HLSL：int取决于在Cg/HLSL中是用float还是int来声明的，如果定义为float则实际使用的就是浮点数，定义为int会被识别为int类型（去小数点直接取整） ​_Float (\"Float\", Float ) = 0​ 类型：浮点数值Cg/HLSL：可根据需要定义不同的浮点精度• float：32位精度，常用于世界坐标位置以及UV坐标• half：16位精度，范围[-6W,6W]，常用于本地坐标位置,方向等• fixed：11位精度，范围[-2,2]，1/265的小数精度，常用于纹理与颜色等低精度的情况 ​_Slider (\"Slider\", Range(0, 1)) = 0​ 类型：数值滑动条本身还是Float类型，只是通过Range(min,max)来控制滑动条的最小值与最大值 ​_Color(\"Color\", Color) = (1,1,1,1)​ 类型：颜色属性Cg/HLSL：float4/half4/fixed4 ​_Vector (\"Vector\", Vector) = (0,0,0,0)​ 类型：四维向量在Properties中无法定义二维或者三维向量，只能定义四维向量 纹理属性 属性 描述 ​_MainTex (\"Texture\", 2D) = \"white\" {}​ 类型：2D纹理Cg/HLSL：sampler2D/sampler2D_half/sampler2D_float默认值有white、black、gray、bump以及空，空就是white ​_MainTexArray (\"TextureArray\", 2DArray) = \"white\" {}​ 类型：2D纹理数组TEXTURE2D_ARRAY(_MainTexArray); SAMPLER(sampler_MainTexArray);SAMPLE_TEXTURE2D_ARRAY(_MainTexArry, sampler_MainTexArry, i.uv,_Index);默认值有white、black、gray、bump以及空，空就是white仅支持DX10、OpenGL3.0、Metal及以上版本 ​_MainTex3D (\"Texture\", 3D) = \"white\" {}​ 类型：3D纹理Cg/HLSL：sampler3D/sampler3D_half/sampler3D_float ​_MainCube (\"Texture\", Cube) = \"white\" {}​ 类型：立方体纹理Cg/HLSL：samplerCUBE/samplerCUBE_half/samplerCUBE_float ​_MainTex (\"Texture\", Any) = \"white\" {}​ 类型：通用纹理支持2D、3D、Cube Attributes（属性修饰符） 修饰符 描述 ​[Header(xxx)]​ 用于在材质面板中当前属性的上方显示标题xxx，注意只支持英文、数字、空格以及下划线 ​[HideInInspector]​ 在材质面板中隐藏此条属性，在不希望暴露某条属性时可以快速将其隐藏 ​[Space(n)]​ 使材质面板属性之前有间隔，n为间隔的数值大小 ​[HDR]​ 标记为属性为高动态范围 ​[PowerSlider(3)]​ 滑条曲率，必须加在range属性前面，用于控制滑动的数值比例 ​[IntRange]​ 必须使用在Range属性之上，以使在材质面板中滑动时只能生成整数 ​[Toggle]​ 开关，加在数值类型前，可使材质面板中的数值变成开关，0是关，1是开 ​[ToggleOff]​ 与Toggle相当，0是开，1是关 ​[Enum(Off, 0, On, 1)]​ 数值枚举，可直接在cg中使用此关键字来替代数字，最多可定义7个，超出后无法以下拉列表框的形式展现 ​[KeywordEnum (Enum0, Enum1, Enum2, Enum3, Enum4, Enum5, Enum6, Enum7, Enum8)]​ 关键字枚举，需要#pragma multi_compile _XXX_ENUM0 _XXX_ENUM1 …来依次声明变体关键字，XXX为这条属性中声明的变量名，在cg/hlsl中可以通过#​if #elif #endif分别做判断 ​[Enum (UnityEngine.Rendering.CullMode)]​ 内置枚举，可在Enum()内直接调用Unity内部的枚举 ​[NoScaleOffset]​ 只能加在纹理属性前，使其隐藏材质面板中的Tiling和Offset ​[Normal]​ 只能加在纹理属性前，标记此纹理是用来接收法线贴图的，当用户指定了非法线的纹理时会在材质面板上进行警告提示 ​[Gamma]​ Float和Vector属性默认情况下不会进行颜色空间转换，可以通过添加[Gamma]来指明此属性为sRGB值 ​[PerRendererData]​ 标记当前属性将以材质属性块的形式来自于每个渲染器数据 ​[MainTexture]​ 标记当前纹理为主纹理，便于C#通过Material.mainTexture调用 ​[MainColor]​ 标记当前颜色为主颜色，便于C#通过Material.color调用 Math（数学运算） 基础数学函数 函数 描述 ​abs(x)​ 取绝对值，即正值返回正值，负值返回的还是正值，x值也可以为向量 ​acos(x)​ 反余弦函数，输入参数范围为[-1, 1]，返回[0, π] 区间的弧度值 ​asin(x)​ 返回x的反正弦值，范围为(-π/2,π/2) ​atan(x)​ 返回x的反正切值，范围为(-π/2,π/2)，表示弧度 ​atan2(y,x)​ 返回y/x的反正切值 ​ceil(x)​ 对x进行向上取整，即x=0.1返回1，x=1.5返回2，x=-0.3返回0 ​clamp(x,a,b)​ 如果x值小于a，则返回a；如果x值大于b，返回b；否则返回x ​cos(x)​ 返回弧度x的余弦值，范围在[-1,1]之间 ​cosh(x)​ 双曲余弦函数 ​degrees(x)​ 将x从弧度转换成角度 ​exp(x)​ 计算e的x次方，e = 2.71828182845904523536 ​exp2(x)​ 计算2的x次方 ​floor(x)​ 对x值进行向下取整(去尾求整) ​fmod(x,y)​ 返回x/y的余数。如果y为0，结果不可预料，注意！如果x为负值，返回的结果也是负值！ ​frac(x)​ 返回x的小数部分 ​log(x)​ 返回x的自然对数 ​log2(x)​ 返回以2为底的自然对数 ​log10(x)​ 返回以10为底的自然对数 ​max(a,b)​ 比较两个标量或等长向量元素，返回最大值 ​min(a,b)​ 比较两个标量或等长向量元素，返回最小值 ​pow(x,y)​ 返回x的y次方 ​round(x)​ 返回x四舍五入的值 ​saturate(x)​ 如果x&lt;0返回0，如果x&gt;1返回1，否则返回x ​sin(x)​ 返回弧度x的正弦值，范围在[-1,1]之间 ​sinh(x)​ 双曲正弦函数 ​sqrt(x)​ 返回x的平方根 ​tan(x)​ 返回x的正切值 向量运算 函数 描述     ​all(a)​ 当a或a的所有分量都为true或者非0时返回1(true)，否则返回0(false)     ​any(a)​ 如果a=0或者a中的所有分量为0，则返回0(false)；否则返回1(true)     ​cross(a,b)​ 返回两个三维向量a与b的叉积     ​dot(a,b)​ 点乘，a和b可以为标量也可以为向量，其计算结果是两个向量夹角的余弦值，相当于|a| * b * cos(θ)或者a.xb.x+a.yb.y+a.z*b.z ​distance(a,b)​ 返回a,b间的距离     ​length(v)​ 返回一个向量的模，即 sqrt(dot(v,v))     ​normalize(v)​ 返回一个向量的归一化版本(方向一样，但是模为1)     ​reflect(I, N)​ 根据入射光方向向量I，和顶点法向量N，计算反射光方向向量     ​refract(I,N,eta)​ 计算折射向量，I为入射光线，N为法向量，eta为折射系数     插值和步进函数 函数 描述 ​lerp(A,B,alpha)​ 线性插值。如果alpha=0，则返回A；如果alpha=1，则返回B；否则返回A与B的混合值 ​smoothstep(min,max,x)​ 平滑插值，如果x比min小，返回0；如果x比max大，返回1；如果x处于范围[min，max]中，则返回0和1之间的值 ​step(a,b)​ 如果a&lt;=b返回1，否则返回0 导数函数 函数 描述 ​ddx(v)​ 当前像素右边的v值-当前像素的v值(水平方向的差值) ​ddy(v)​ 当前像素下边的v值-当前像素的v值(垂直方向的差值) ​fwidth(v)​ 当前像素与它右边及下边像素的差值，abs(ddx(v)) + abs(ddy(v)) 纹理采样 内置渲染管线 函数 描述 ​tex1D(samper1D tex,float s)​ 一维纹理采样 ​tex2D(samper2D tex,float2 s)​ 二维纹理采样 ​tex2Dlod(samper2D tex,float4 s)​ 二维纹理采样，s.w表示采样的是mipmap的几级，仅在ES3.0以上支持 ​tex2DProj(samper2D tex,float4 s)​ 二维投影纹理采样，uv使用s.xy/s.w ​texCUBE(samperCUBE tex,float3 s)​ 立方体纹理采样 ​tex3D(samper3D tex,float3 s)​ 3D纹理采样，uv使用xyz URP渲染管线 函数 描述 ​TEXTURE2D(textureName);​ 二维纹理的定义(纹理与采样器分离定义) ​TEXTURECUBE(textureName);​ 立方体纹理的定义(纹理与采样器分离定义) ​SAMPLER(samplerName);​ 采样器的定义(纹理与采样器分离定义) ​SAMPLE_TEXTURE2D(textureName, samplerName, coord);​ 进行二维纹理采样操作 ​SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord,lod);​ 进行二维纹理采样操作 ​SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord,bias);​ 对mipmap进行偏移后再采样纹理 ​SAMPLE_TEXTURECUBE(textureName, samplerName, coord);​ 进行立方体纹理采样操作 ​SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord,lod);​ 进行立方体纹理采样操作 ​SAMPLE_TEXTURE3D(textureName, samplerName, coord);​ 进行3D纹理采样操作 纹理数组采样（URP） 函数 描述 ​TEXTURE2D_ARRAY(textureName);​ 纹理数组的定义 ​SAMPLER(sampler_samplerName);​ 纹理数组的采样器定义 ​SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index);​ 纹理数组采样 常用指令 指令 描述 ​mov dest, src1​ dest = src1 ​add dest, src1, src2​ dest = src1 + src2 ​mul dest, src1, src2​ dest = src1 * src2 ​div dest, src1, src2​ dest = src1 / src2 ​mad dest, src1, src2, src3​ dest = src1 * src2 + src3 ​dp2 dest, src1, src2​ (src1.x * src2.x) + (src1.y * src2.y) ​dp3 dest, src1, src2​ (src1.x * src2.x) + (src1.y * src2.y) + (src1.z * src2.z) ​dp4 dest, src1, src2​ (src1.x * src2.x) + (src1.y * src2.y) + (src1.z * src2.z) + (src1.w * src2.w) ​rsq dest, src1​ rsqrt(src1) 对src1进行平方根的倒数 BuildIn Variables（内置变量） 基础函数 函数 描述 ​UNITY_INITIALIZE_OUTPUT(type,name)​ 由于HLSL编缉器不接受没有初始化的数据，所以为了支持所有平台，从而需要使用此方法进行初始化 ​TRANSFORM_TEX(i.uv,_MainTex)​ 对UV进行Tiling与Offset变换 ​float3 UnityWorldSpaceLightDir( float3 worldPos )​ 返回顶点到灯光的向量 Camera and Screen 内置渲染管线 变量 描述 ​_WorldSpaceCameraPos​ 主相机的世界坐标位置，类型：float3 ​UnityWorldSpaceViewDir(i.worldPos)​ 世界空间下的相机方向(顶点到主相机)，类型：float3 ​_CameraDepthTexture​ 深度纹理，需要在脚本中开启相机的深度：Camera.main.depthTextureMode = DepthTextureMode.Depth ​ComputeScreenPos(float4 pos)​ pos为裁剪空间下的坐标位置，返回的是某个投影点下的屏幕坐标位置 ​_ScreenParams​ 屏幕的相关参数，单位为像素。x表示屏幕的宽度，y表示屏幕的高度，z表示1+1/屏幕宽度，w表示1+1/屏幕高度 URP渲染管线 变量 描述 ​_WorldSpaceCameraPos​ 相机在世界空间下的位置坐标(xyz) ​_ZBufferParams​ Z Buffer参数，包含近远裁剪面信息 ​_CameraDepthTexture​ 深度纹理，在PipelineAsset中勾选DepthTexture ​_CameraOpaqueTexture​ 抓屏纹理，在PipelineAsset中勾选OpaqueTexture ​_ScreenParams​ 屏幕的相关参数，单位为像素 ​_ScaledScreenParams​ 同上，但是有考虑到RenderScale的影响 Time 变量 描述 ​_Time​ 时间，主要用于在Shader做动画，类型：float4x = t/20y = tz = t2w = t3 ​_SinTime​ t是时间的正弦值，返回值(-1~1)x = t/8y = t/4z = t/2w = t ​_CosTime​ t是时间的余弦值，返回值(-1~1)x = t/8y = t/4z = t/2w = t ​unity_DeltaTime​ dt是时间增量，smoothDt是平滑时间x = dty = 1/dtz = smoothDtw = 1/smoothDt Lighting (内置渲染管线) 变量 描述 ​_LightColor0​ 主平行灯的颜色值，rgb = 颜色x亮度；a = 亮度 ​_WorldSpaceLightPos0​ 平行灯：(xyz=位置,z=0)，已归一化其它类型灯：(xyz=位置,z=1) ​unity_WorldToLight​ 从世界空间转换到灯光空间下，等同于旧版的_LightMatrix0 Fog and Ambient (内置渲染管线) 变量 描述 ​unity_AmbientSky​ 环境光（Gradient）中的Sky Color ​unity_AmbientEquator​ 环境光（Gradient）中的Equator Color ​unity_AmbientGround​ 环境光（Gradient）中的Ground Color ​UNITY_LIGHTMODEL_AMBIENT​ 环境光(Color)中的颜色，等同于环境光（Gradient）中的Sky Color GPU Instancing 内容 描述 实现步骤 用于对多个对象(网格一样，材质一样，但是材质属性不一样)合批，单个合批最大上限为511个对象1. #pragma multi_compile_instancing 添加此指令后会使材质面板上曝露Instaning开关2. UNITY_VERTEX_INPUT_INSTANCE_ID 在顶点着色器的输入(appdata)和输出(v2f可选)中添加(uint instanceID : SV_InstanceID)3. 构建需要实例化的额外数据4. UNITY_SETUP_INSTANCE_ID(v) 放在顶点着色器/片断着色器(可选)中最开始的地方5. UNITY_TRANSFER_INSTANCE_ID(v, o) 当需要将实例化ID传到片断着色器时，在顶点着色器中添加6. UNITY_ACCESS_INSTANCED_PROP(arrayName, propName) 在片断着色器中访问具体的实例化变量 Instancing选项 对GPU Instancing进行一些设置• #pragma instancing_options forcemaxcount:batchSize 强制设置单个批次内Instancing的最大数量• #pragma instancing_options maxcount:batchSize 设置单个批次内Instancing的最大数量 BuildIn Transformation（内置变换） 空间变换(矩阵) 内置渲染管线 矩阵 描述 ​UNITY_MATRIX_MVP​ 模型空间»投影空间 ​UNITY_MATRIX_MV​ 模型空间»观察空间 ​UNITY_MATRIX_V​ 视图空间 ​UNITY_MATRIX_P​ 投影空间 ​UNITY_MATRIX_VP​ 视图空间&gt;投影空间 ​unity_ObjectToWorld​ 本地空间»世界空间 ​unity_WorldToObject​ 世界空间&gt;本地空间 URP渲染管线 函数 描述 ​GetObjectToWorldMatrix()​ 本地空间到世界空间的矩阵 ​GetWorldToObjectMatrix()​ 世界空间到本地空间的矩阵 ​GetWorldToViewMatrix()​ 世界空间到观察空间的矩阵 ​GetWorldToHClipMatrix()​ 世界空间到齐次裁剪空间的矩阵 ​GetViewToHClipMatrix()​ 观察空间到齐次裁剪空间的矩阵 空间变换(方法) 内置渲染管线 函数 描述 ​UnityObjectToClipPos(v.vertex)​ 将模型空间下的顶点转换到齐次裁剪空间 ​UnityObjectToWorldNormal(v.normal)​ 将模型空间下的法线转换到世界空间(已归一化) ​UnityObjectToWorldDir (v.tangent)​ 将模型空间下的切线转换到世界空间(已归一化) ​UnityWorldSpaceLightDir (i.worldPos)​ 世界空间下顶点到灯光方向的向量(未归一化) ​UnityWorldSpaceViewDir (i.worldPos)​ 世界空间下顶点到视线方向的向量(未归一化) URP渲染管线 函数 描述 ​float3 TransformObjectToWorld (float3 positionOS)​ 从本地空间变换到世界空间 ​float3 TransformWorldToObject (float3 positionWS)​ 从世界空间变换到本地空间 ​float3 TransformWorldToView(float3 positionWS)​ 从世界空间变换到视图空间 ​float4 TransformObjectToHClip(float3 positionOS)​ 将模型空间下的顶点变换到齐次裁剪空间 ​float4 TransformWorldToHClip(float3 positionWS)​ 将世界空间下的顶点变换到齐次裁剪空间 ​float4 TransformWViewToHClip (float3 positionVS)​ 将视图空间下的顶点变换到齐次裁剪空间 ​float3 TransformObjectToWorldNormal (float3 normalOS)​ 将法线从本地空间变换到世界空间(已归一化) 基础变换矩阵 矩阵类型 矩阵定义 平移矩阵 ```float4x4 M_translate = float4x4( 1, 0, 0, T.x, 0, 1, 0, T.y, 0, 0, 1, T.z, 0, 0 " }, { "title": "Unity Shader 参考文档 - 第一部分", "url": "/post/unity-shader-reference-document-part-1-z21bblp.html", "categories": "", "tags": "shader, unity", "date": "2025-07-31 09:05:58 +0800", "content": " Semantics（语义） 应用程序到顶点着色器的数据（appdata） 语义 描述 ​float4 vertex : POSITION;​ 顶点的本地坐标 ​uint vid : SV_VertexID;​ 顶点的索引ID ​float3 normal : NORMAL;​ 顶点的法线信息 ​float4 tangent : TANGENT;​ 顶点的切线信息 ​float4 texcoord : TEXCOORD0;​ 顶点的UV1信息 ​float4 texcoord1 : TEXCOORD1;​ 顶点的UV2信息 ​float4 texcoord2 : TEXCOORD2;​ 顶点的UV3信息 ​float4 texcoord3 : TEXCOORD3;​ 顶点的UV4信息 ​fixed4 color : COLOR;​ 顶点的顶点色信息 顶点着色器到片断着色器的数据 (v2f) 语义 描述 ​float4 pos:SV_POSITION;​ 顶点的齐次裁剪空间下的坐标，默认情况下用POSITION也可以(PS4下不支持)，但是为了支持所有平台，所以最好使用SV_POSITION ​TEXCOORD0~N​ 例如TEXCOORD0、TEXCOORD1、TEXCOORD2…等等 ​COLOR0~N​ 例如COLOR0、COLOR1、COLOR2…等等，主要用于低精度数据，由于平台适配问题，不建议在v2f中使用COLORn ​float face:VFACE​ 如果渲染表面朝向摄像机，则Face节点输出正值1，如果远离摄像机，则输出负值-1 ​UNITY_VPOS_TYPE screenPos : VPOS​ 当前片断在屏幕上的位置(单位是像素,可除以_ScreenParams.xy来做归一化)，此功能仅支持#pragma target 3.0及以上编译指令 ​uint vid : SV_VertexID​ 顶点着色器可以接收具有”顶点编号”作为无符号整数的变量，当需要从纹理或ComputeBuffers中获取额外的顶点数据时比较有用，此语义仅支持#pragma target 3.5及以上 注意事项： OpenGL ES2.0支持最多8个 OpenGL ES3.0支持最多16个 片断着色器输出的数据（fragOutput） 语义 描述 ​fixed4 color : SV_Target;​ 默认RenderTarget，也是默认输出的屏幕上的颜色，同时支持SV_Target1、SV_Target2…等等 ​fixed depth : SV_Depth;​ 通过在片断着色器中输出SV_DEPTH语义可以更改像素的深度值，注意此功能相对会消耗性能，在没有特别需求的情况下尽量不要用 Properties（属性） 基础属性类型 属性 描述 ​_Int(\"Int\", Int) = 1​ 类型：整型Cg/HLSL：int取决于在Cg/HLSL中是用float还是int来声明的，如果定义为float则实际使用的就是浮点数，定义为int会被识别为int类型（去小数点直接取整） ​_Float (\"Float\", Float ) = 0​ 类型：浮点数值Cg/HLSL：可根据需要定义不同的浮点精度• float：32位精度，常用于世界坐标位置以及UV坐标• half：16位精度，范围[-6W,6W]，常用于本地坐标位置,方向等• fixed：11位精度，范围[-2,2]，1/265的小数精度，常用于纹理与颜色等低精度的情况 ​_Slider (\"Slider\", Range(0, 1)) = 0​ 类型：数值滑动条本身还是Float类型，只是通过Range(min,max)来控制滑动条的最小值与最大值 ​_Color(\"Color\", Color) = (1,1,1,1)​ 类型：颜色属性Cg/HLSL：float4/half4/fixed4 ​_Vector (\"Vector\", Vector) = (0,0,0,0)​ 类型：四维向量在Properties中无法定义二维或者三维向量，只能定义四维向量 纹理属性 属性 描述 ​_MainTex (\"Texture\", 2D) = \"white\" {}​ 类型：2D纹理Cg/HLSL：sampler2D/sampler2D_half/sampler2D_float默认值有white、black、gray、bump以及空，空就是white ​_MainTexArray (\"TextureArray\", 2DArray) = \"white\" {}​ 类型：2D纹理数组TEXTURE2D_ARRAY(_MainTexArray); SAMPLER(sampler_MainTexArray);SAMPLE_TEXTURE2D_ARRAY(_MainTexArry, sampler_MainTexArry, i.uv,_Index);默认值有white、black、gray、bump以及空，空就是white仅支持DX10、OpenGL3.0、Metal及以上版本 ​_MainTex3D (\"Texture\", 3D) = \"white\" {}​ 类型：3D纹理Cg/HLSL：sampler3D/sampler3D_half/sampler3D_float ​_MainCube (\"Texture\", Cube) = \"white\" {}​ 类型：立方体纹理Cg/HLSL：samplerCUBE/samplerCUBE_half/samplerCUBE_float ​_MainTex (\"Texture\", Any) = \"white\" {}​ 类型：通用纹理支持2D、3D、Cube Attributes（属性修饰符） 修饰符 描述 ​[Header(xxx)]​ 用于在材质面板中当前属性的上方显示标题xxx，注意只支持英文、数字、空格以及下划线 ​[HideInInspector]​ 在材质面板中隐藏此条属性，在不希望暴露某条属性时可以快速将其隐藏 ​[Space(n)]​ 使材质面板属性之前有间隔，n为间隔的数值大小 ​[HDR]​ 标记为属性为高动态范围 ​[PowerSlider(3)]​ 滑条曲率，必须加在range属性前面，用于控制滑动的数值比例 ​[IntRange]​ 必须使用在Range属性之上，以使在材质面板中滑动时只能生成整数 ​[Toggle]​ 开关，加在数值类型前，可使材质面板中的数值变成开关，0是关，1是开 ​[ToggleOff]​ 与Toggle相当，0是开，1是关 ​[Enum(Off, 0, On, 1)]​ 数值枚举，可直接在cg中使用此关键字来替代数字，最多可定义7个，超出后无法以下拉列表框的形式展现 ​[KeywordEnum (Enum0, Enum1, Enum2, Enum3, Enum4, Enum5, Enum6, Enum7, Enum8)]​ 关键字枚举，需要#pragma multi_compile _XXX_ENUM0 _XXX_ENUM1 …来依次声明变体关键字，XXX为这条属性中声明的变量名，在cg/hlsl中可以通过#​if #elif #endif分别做判断 ​[Enum (UnityEngine.Rendering.CullMode)]​ 内置枚举，可在Enum()内直接调用Unity内部的枚举 ​[NoScaleOffset]​ 只能加在纹理属性前，使其隐藏材质面板中的Tiling和Offset ​[Normal]​ 只能加在纹理属性前，标记此纹理是用来接收法线贴图的，当用户指定了非法线的纹理时会在材质面板上进行警告提示 ​[Gamma]​ Float和Vector属性默认情况下不会进行颜色空间转换，可以通过添加[Gamma]来指明此属性为sRGB值 ​[PerRendererData]​ 标记当前属性将以材质属性块的形式来自于每个渲染器数据 ​[MainTexture]​ 标记当前纹理为主纹理，便于C#通过Material.mainTexture调用 ​[MainColor]​ 标记当前颜色为主颜色，便于C#通过Material.color调用 Math（数学运算） 基础数学函数 函数 描述 ​abs(x)​ 取绝对值，即正值返回正值，负值返回的还是正值，x值也可以为向量 ​acos(x)​ 反余弦函数，输入参数范围为[-1, 1]，返回[0, π] 区间的弧度值 ​asin(x)​ 返回x的反正弦值，范围为(-π/2,π/2) ​atan(x)​ 返回x的反正切值，范围为(-π/2,π/2)，表示弧度 ​atan2(y,x)​ 返回y/x的反正切值 ​ceil(x)​ 对x进行向上取整，即x=0.1返回1，x=1.5返回2，x=-0.3返回0 ​clamp(x,a,b)​ 如果x值小于a，则返回a；如果x值大于b，返回b；否则返回x ​cos(x)​ 返回弧度x的余弦值，范围在[-1,1]之间 ​cosh(x)​ 双曲余弦函数 ​degrees(x)​ 将x从弧度转换成角度 ​exp(x)​ 计算e的x次方，e = 2.71828182845904523536 ​exp2(x)​ 计算2的x次方 ​floor(x)​ 对x值进行向下取整(去尾求整) ​fmod(x,y)​ 返回x/y的余数。如果y为0，结果不可预料，注意！如果x为负值，返回的结果也是负值！ ​frac(x)​ 返回x的小数部分 ​log(x)​ 返回x的自然对数 ​log2(x)​ 返回以2为底的自然对数 ​log10(x)​ 返回以10为底的自然对数 ​max(a,b)​ 比较两个标量或等长向量元素，返回最大值 ​min(a,b)​ 比较两个标量或等长向量元素，返回最小值 ​pow(x,y)​ 返回x的y次方 ​round(x)​ 返回x四舍五入的值 ​saturate(x)​ 如果x&lt;0返回0，如果x&gt;1返回1，否则返回x ​sin(x)​ 返回弧度x的正弦值，范围在[-1,1]之间 ​sinh(x)​ 双曲正弦函数 ​sqrt(x)​ 返回x的平方根 ​tan(x)​ 返回x的正切值 向量运算 函数 描述     ​all(a)​ 当a或a的所有分量都为true或者非0时返回1(true)，否则返回0(false)     ​any(a)​ 如果a=0或者a中的所有分量为0，则返回0(false)；否则返回1(true)     ​cross(a,b)​ 返回两个三维向量a与b的叉积     ​dot(a,b)​ 点乘，a和b可以为标量也可以为向量，其计算结果是两个向量夹角的余弦值，相当于|a| * b * cos(θ)或者a.xb.x+a.yb.y+a.z*b.z ​distance(a,b)​ 返回a,b间的距离     ​length(v)​ 返回一个向量的模，即 sqrt(dot(v,v))     ​normalize(v)​ 返回一个向量的归一化版本(方向一样，但是模为1)     ​reflect(I, N)​ 根据入射光方向向量I，和顶点法向量N，计算反射光方向向量     ​refract(I,N,eta)​ 计算折射向量，I为入射光线，N为法向量，eta为折射系数     插值和步进函数 函数 描述 ​lerp(A,B,alpha)​ 线性插值。如果alpha=0，则返回A；如果alpha=1，则返回B；否则返回A与B的混合值 ​smoothstep(min,max,x)​ 平滑插值，如果x比min小，返回0；如果x比max大，返回1；如果x处于范围[min，max]中，则返回0和1之间的值 ​step(a,b)​ 如果a&lt;=b返回1，否则返回0 导数函数 函数 描述 ​ddx(v)​ 当前像素右边的v值-当前像素的v值(水平方向的差值) ​ddy(v)​ 当前像素下边的v值-当前像素的v值(垂直方向的差值) ​fwidth(v)​ 当前像素与它右边及下边像素的差值，abs(ddx(v)) + abs(ddy(v)) 纹理采样 内置渲染管线 函数 描述 ​tex1D(samper1D tex,float s)​ 一维纹理采样 ​tex2D(samper2D tex,float2 s)​ 二维纹理采样 ​tex2Dlod(samper2D tex,float4 s)​ 二维纹理采样，s.w表示采样的是mipmap的几级，仅在ES3.0以上支持 ​tex2DProj(samper2D tex,float4 s)​ 二维投影纹理采样，uv使用s.xy/s.w ​texCUBE(samperCUBE tex,float3 s)​ 立方体纹理采样 ​tex3D(samper3D tex,float3 s)​ 3D纹理采样，uv使用xyz URP渲染管线 函数 描述 ​TEXTURE2D(textureName);​ 二维纹理的定义(纹理与采样器分离定义) ​TEXTURECUBE(textureName);​ 立方体纹理的定义(纹理与采样器分离定义) ​SAMPLER(samplerName);​ 采样器的定义(纹理与采样器分离定义) ​SAMPLE_TEXTURE2D(textureName, samplerName, coord);​ 进行二维纹理采样操作 ​SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord,lod);​ 进行二维纹理采样操作 ​SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord,bias);​ 对mipmap进行偏移后再采样纹理 ​SAMPLE_TEXTURECUBE(textureName, samplerName, coord);​ 进行立方体纹理采样操作 ​SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord,lod);​ 进行立方体纹理采样操作 ​SAMPLE_TEXTURE3D(textureName, samplerName, coord);​ 进行3D纹理采样操作 纹理数组采样（URP） 函数 描述 ​TEXTURE2D_ARRAY(textureName);​ 纹理数组的定义 ​SAMPLER(sampler_samplerName);​ 纹理数组的采样器定义 ​SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index);​ 纹理数组采样 常用指令 指令 描述 ​mov dest, src1​ dest = src1 ​add dest, src1, src2​ dest = src1 + src2 ​mul dest, src1, src2​ dest = src1 * src2 ​div dest, src1, src2​ dest = src1 / src2 ​mad dest, src1, src2, src3​ dest = src1 * src2 + src3 ​dp2 dest, src1, src2​ (src1.x * src2.x) + (src1.y * src2.y) ​dp3 dest, src1, src2​ (src1.x * src2.x) + (src1.y * src2.y) + (src1.z * src2.z) ​dp4 dest, src1, src2​ (src1.x * src2.x) + (src1.y * src2.y) + (src1.z * src2.z) + (src1.w * src2.w) ​rsq dest, src1​ rsqrt(src1) 对src1进行平方根的倒数 " }, { "title": "Unity Mask遮罩失效问题", "url": "/post/unity-mask-failure-issues-z1aeqtt.html", "categories": "", "tags": "unity, UGUI", "date": "2025-07-30 14:34:27 +0800", "content": "实际效果 期望效果 ‍ 环境设置 Canvas设置 ​​ Camera设置 在当前情况下就会出现MASK失效的问题 在把相机设置成Screen Space - Overlay或者设置清除深度 如下图即可解决 我是设置了清除深度缓存，让其显示效果正常 相机渲染模式的区别 Screen Space - Overlay UI直接渲染在屏幕上，不依赖相机// 不受3D场景影响// 性能较好// 遮罩效果稳定 不需要深度测试 Screen Space - Camera UI渲染在指定相机前方的平面上 受相机设置影响（FOV、深度等） 可以与3D场景交互 遮罩效果可能受相机设置影响 需要正确的深度缓冲区管理 Clear Depth 的作用原理 问题场景： - UI相机和游戏相机共享深度缓冲区 - 游戏相机已经渲染了3D场景，设置了深度值 - UI相机渲染时，深度测试可能失败 - 导致UI元素（包括遮罩）不显示或显示异常 渲染流程： 1. 游戏相机渲染3D场景 → 设置深度缓冲区 2. UI相机渲染UI → 需要清除之前的深度值 3. 如果不清除深度，UI可能被深度测试过滤掉 " }, { "title": "ET8.1版本", "url": "/post/et81-version-z7czqy.html", "categories": "", "tags": "", "date": "2025-06-04 08:47:07 +0800", "content": "ET8.1版本 ET8.1 model和modelView 主要是放类的定义 hotFix和hotFixView 主要放类的视线 带View的就是unity视图相关的 Unity.loader下是非热更的函数 ‍ ECS 组件式编程 与unity官方的ECS毫无关系 ET 框架设计原则： 树状领域 组合模式 事件驱动 逻辑分发 后期编写全部在 AllHotFix System AllModel component 和entity Model 逻辑层，不能引用任何unity下的代码 ModelView 表现层，可以使用unity 客户端代码，必须在ET.Client命名空间当中，Server同理，如果是两者都用命名空间则是ET 实体和组件都会继承Entity 通过ComponentOf(typeof(Computer)) 来表明当前组件会挂在Computer上 表现层调用逻辑层是没问题，但是逻辑层应该通过抛出事件的方式，驱动逻辑层做出修改 ‍ ‍ 为什么System要用static ‍ Fiber 两个纤程通讯使用的ProcessInnerSender " }, { "title": "Unity 跑酷游戏开发笔记", "url": "/posts/unity-parkour-game/", "categories": "游戏开发", "tags": "unity, c#, 游戏开发, 跑酷游戏", "date": "2025-04-20 12:00:00 +0800", "content": " Unity 跑酷游戏开发笔记 一、项目概述 1.1 游戏类型 1.2 技术选择 Unity 跑酷游戏开发笔记 一、项目概述 有一段时间没有使用unity开发，熟悉unity开发，并熟悉unity的新技术，例如新的框架，hybridclr，yooasset等，也是为了丰富简历，在休息完这段时间后，希望能顺利入职 1.1 游戏类型 3D 跑酷游戏 第三人称视角 1.2 技术选择 框架 " }, { "title": "Unity热更新方案对比", "url": "/posts/hybridclr-learning/", "categories": "unity", "tags": "unity, hybridclr, tolua, ilruntime, 热更新", "date": "2025-03-12 14:00:00 +0800", "content": " Unity热更新方案对比：HybridCLR、ToLua、ILRuntime 一、热更新方案概述 1.1 HybridCLR 1.2 ToLua 1.3 ILRuntime 二、技术对比 2.1 性能对比 2.2 开发效率 2.3 特性支持 HybridCLR ToLua ILRuntime 五、注意事项 5.1 HybridCLR 注意事项 5.2 ToLua 注意事项 5.3 ILRuntime 注意事项 Unity热更新方案对比：HybridCLR、ToLua、ILRuntime 一、热更新方案概述 1.1 HybridCLR HybridCLR 是 Unity 下的 AOT 热更新解决方案，支持完全的 C# 语法。它通过在 Android 平台的 il2cpp 中添加 interpreter 来实现热更新。 主要特点： 零成本：不需要额外的运行时开销 原生支持：直接使用 C# 开发，无需额外的语言绑定 性能优秀：通过 AOT + Interpreter 混合执行 完整支持：支持所有 C# 特性，包括反射、泛型等 跨平台：支持所有 il2cpp 支持的平台 1.2 ToLua ToLua 是一个将 C# 代码导出为 Lua 接口的解决方案，实现热更新的方式是通过 Lua 脚本。 主要特点： 成熟稳定：使用广泛，社区活跃 性能较好：Lua 执行效率相对较高 学习成本：需要掌握 Lua 语言 开发效率：需要编写导出代码，有一定工作量 局限性：不支持部分 C# 特性 1.3 ILRuntime ILRuntime 是一个纯 C# 实现的 .NET 虚拟机，可以直接运行 DLL 格式的程序。 主要特点： 纯 C# 实现：不依赖 Mono 和 IL2CPP 跨平台性：支持所有平台 性能一般：解释执行，性能低于原生代码 完整性：支持大部分 .NET 特性 开发便利：直接使用 C# 开发 二、技术对比 2.1 性能对比 2.2 开发效率 HybridCLR 直接使用 C# 开发 无需编写绑定代码 支持完整的 IDE 功能 调试方便 ToLua 需要编写导出代码 需要掌握 Lua 调试相对困难 需要维护两种语言 ILRuntime 使用 C# 开发 需要适配部分特性 调试支持一般 部分语法限制 2.3 特性支持 HybridCLR 完整的 C# 特性 反射 泛型 值类型 委托 异步/await ToLua 基础类型 委托（需导出） 泛型（有限支持） 值类型（需转换） 反射（有限支持） ILRuntime 大部分 C# 特性 反射（性能较低） 泛型（需注册） 值类型（性能较低） 委托（需注册） 五、注意事项 5.1 HybridCLR 注意事项 需要注意 AOT 泛型问题 更新包体积相对较大 需要合理规划热更新内容 注意内存管理 5.2 ToLua 注意事项 注意导出代码的维护 处理好类型转换 注意 Lua GC 控制好内存使用 5.3 ILRuntime 注意事项 注意性能开销 处理好跨域调用 注意泛型注册 控制好内存使用 " }, { "title": "使用 Cursor 作为 Unity 开发环境", "url": "/posts/cursor-unity-dev/", "categories": "unity", "tags": "unity, cursor, 开发工具, 调试", "date": "2025-03-12 13:00:00 +0800", "content": " 使用 Cursor 作为 Unity 开发环境 一、环境配置 1.1 前期准备 1.2 配置步骤 1.3 调试 使用 Cursor 作为 Unity 开发环境 一、环境配置 1.1 前期准备 Unity 项目已创建 Cursor IDE 已安装 Unity 编辑器已配置外部编辑器为 Cursor 科学上网 1.2 配置步骤 在 Unity 中设置外部编辑器 在包管理器中 粘贴 https://github.com/boxqkrtm/com.unity.ide.cursor.git 进入 Edit &gt; Preferences &gt; External Tools 选择 External Script Editor 为 Cursor 并单击 Regenerate project files。 配置 Cursor 的 Unity 开发环境 安装 C# 扩展 安装 Unity 插件 配置调试环境 1.3 调试 在unity 中 选择 Assets-&gt; open c# project 在cursor 中 ctrl+shift+p 输入 attach，选择对应的unity进程 " }, { "title": "思源笔记转换Jekyll博客记录", "url": "/posts/siyuan-to-jekyll/", "categories": "技术笔记", "tags": "python, jekyll, markdown", "date": "2025-03-12 11:45:00 +0800", "content": " 思源笔记转换Jekyll博客记录 一、项目背景 二、转换脚本实现 2.1 主要功能 2.2 核心代码 三、主要功能说明 3.1 文件名处理 3.2 分类和标签检测 3.3 内容处理 3.4 Front Matter 生成 3.5 图片处理 四、使用方法 五、注意事项 六、后续优化方向 思源笔记转换Jekyll博客记录 一、项目背景 将思源笔记中的 Markdown 文档转换为 Jekyll 博客文章，主要需要处理以下问题： 提取文章标题和分类 生成合适的文件名 处理图片路径 生成文章目录 添加合适的标签 处理 front matter 二、转换脚本实现 2.1 主要功能 自动检测文章分类和标签 处理图片路径，支持本地图片和外部链接 生成文章目录 添加必要的 front matter 处理文件名和日期 2.2 核心代码 #!/usr/bin/env python3 import os import re import shutil from datetime import datetime import yaml import hashlib import logging # 设置日志 logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s') def sanitize_filename(title): \"\"\"将中文标题转换为合法的文件名\"\"\" # 移除特殊字符，用连字符替换空格 filename = re.sub(r'[^\\w\\s-]', '', title) filename = re.sub(r'[-\\s]+', '-', filename).strip('-') return filename.lower() def detect_categories_and_tags(content): \"\"\"从内容中检测可能的分类和标签\"\"\" categories = [] tags = [] # 从一级标题检测分类 category_match = re.search(r'^#\\s+(.+?)(?:\\n|$)', content, re.MULTILINE) if category_match: categories.append(category_match.group(1).strip()) # 检测技术关键词作为标签 tech_keywords = ['spring', 'java', 'mybatis', 'maven', 'framework', 'boot', 'mvc', 'python', 'javascript', 'typescript', 'react', 'vue', 'angular', 'docker', 'kubernetes', 'linux', 'git', 'database', 'sql'] for keyword in tech_keywords: if keyword.lower() in content.lower(): tags.append(keyword) return list(set(categories)), list(set(tags)) def process_markdown_content(content, assets_dir): \"\"\"处理 Markdown 内容\"\"\" # 在文章开头添加目录 content = \"* TOC\\n{:toc}\\n\\n\" + content # 处理思源图片路径 def replace_image(match): image_url = match.group(2) if image_url.startswith('http'): return match.group(0) # 保持外部链接不变 # 为本地图片生成唯一文件名 image_name = hashlib.md5(image_url.encode()).hexdigest()[:8] if '.' in image_url: ext = image_url.rsplit('.', 1)[1].lower() if ext not in ['jpg', 'jpeg', 'png', 'gif', 'svg']: ext = 'png' new_name = f\"{image_name}.{ext}\" else: new_name = f\"{image_name}.png\" return f\"![{match.group(1)}](/assets/images/{new_name})\" content = re.sub(r'!\\[(.*?)\\]\\((.*?)\\)', replace_image, content) # 处理内部链接 content = re.sub(r'\\[\\[(.*?)\\]\\]', r'\\1', content) # 移除多余的空行 content = re.sub(r'\\n{3,}', '\\n\\n', content) return content def create_front_matter(title, date, categories=None, tags=None): \"\"\"创建 Jekyll front matter\"\"\" front_matter = { 'title': title, 'date': date.strftime('%Y-%m-%d %H:%M:%S +0800'), 'categories': categories or ['未分类'], 'tags': tags or [], 'author': 'lixiao', 'layout': 'post', 'toc': True } return f\"---\\n{yaml.dump(front_matter, allow_unicode=True, sort_keys=False)}---\\n\\n\" def convert_siyuan_to_jekyll(siyuan_dir, jekyll_dir): \"\"\"转换思源笔记到 Jekyll 博客格式\"\"\" try: # 确保路径是绝对路径 siyuan_dir = os.path.abspath(siyuan_dir) jekyll_dir = os.path.abspath(jekyll_dir) if not os.path.exists(siyuan_dir): logging.error(f\"思源笔记目录不存在: {siyuan_dir}\") return # 创建必要的目录 posts_dir = os.path.join(jekyll_dir, '_posts') assets_dir = os.path.join(jekyll_dir, 'assets', 'images') os.makedirs(posts_dir, exist_ok=True) os.makedirs(assets_dir, exist_ok=True) logging.info(f\"开始转换，源目录: {siyuan_dir}\") logging.info(f\"目标目录: {jekyll_dir}\") # 遍历思源笔记目录 for root, dirs, files in os.walk(siyuan_dir): for file in files: if file.endswith('.md'): try: # 读取原始文件 file_path = os.path.join(root, file) with open(file_path, 'r', encoding='utf-8') as f: content = f.read() # 提取标题 title_match = re.search(r'^#\\s+(.+?)(?:\\n|$)', content) if title_match: title = title_match.group(1).strip() else: title = os.path.splitext(file)[0] # 检测分类和标签 categories, tags = detect_categories_and_tags(content) # 使用文件修改时间作为文章日期 date = datetime.fromtimestamp(os.path.getmtime(file_path)) # 生成文件名 filename = f\"{date.strftime('%Y-%m-%d')}-{sanitize_filename(title)}.md\" # 处理内容 content = process_markdown_content(content, assets_dir) # 添加 front matter content = create_front_matter(title, date, categories, tags) + content # 保存新文件 new_file_path = os.path.join(posts_dir, filename) with open(new_file_path, 'w', encoding='utf-8') as f: f.write(content) logging.info(f\"已转换: {filename}\") except Exception as e: logging.error(f\"处理文件 {file} 时出错: {str(e)}\") # 复制资源文件 assets_src = os.path.join(siyuan_dir, 'assets') if os.path.exists(assets_src): for root, dirs, files in os.walk(assets_src): for file in files: if file.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.svg')): try: src_path = os.path.join(root, file) image_name = hashlib.md5(file.encode()).hexdigest()[:8] ext = file.rsplit('.', 1)[1].lower() new_name = f\"{image_name}.{ext}\" dst_path = os.path.join(assets_dir, new_name) shutil.copy2(src_path, dst_path) logging.info(f\"已复制资源: {new_name}\") except Exception as e: logging.error(f\"复制资源文件 {file} 时出错: {str(e)}\") except Exception as e: logging.error(f\"转换过程中出错: {str(e)}\") if __name__ == '__main__': import sys if len(sys.argv) != 3: print(\"用法: python convert_siyuan.py &lt;思源笔记目录&gt; &lt;Jekyll博客目录&gt;\") sys.exit(1) siyuan_dir = sys.argv[1] jekyll_dir = sys.argv[2] convert_siyuan_to_jekyll(siyuan_dir, jekyll_dir) 三、主要功能说明 3.1 文件名处理 使用 sanitize_filename 函数将中文标题转换为合法的文件名： 移除特殊字符 用连字符替换空格 转换为小写 3.2 分类和标签检测 使用 detect_categories_and_tags 函数自动检测文章的分类和标签： 从一级标题提取分类 从内容中检测技术关键词作为标签 去重处理 3.3 内容处理 使用 process_markdown_content 函数处理 Markdown 内容： 添加文章目录标记 处理图片路径 处理内部链接 清理多余空行 3.4 Front Matter 生成 使用 create_front_matter 函数生成 Jekyll 所需的 front matter： 设置标题、日期、分类和标签 添加作者和布局信息 启用目录功能 3.5 图片处理 支持外部链接图片 本地图片生成唯一文件名 自动复制图片文件到博客目录 四、使用方法 将脚本保存为 convert_siyuan.py 在命令行中运行： python convert_siyuan.py \"思源笔记目录\" \"Jekyll博客目录\" 例如： python tools/convert_siyuan.py \"E:/siyuanmd\" \"E:/lixiao90s.github.io\" 五、注意事项 确保思源笔记目录存在 确保 Jekyll 博客目录有写入权限 图片文件需要在 assets 目录下 文章日期使用文件修改时间 标签根据预定义的技术关键词自动生成 六、后续优化方向 支持更多图片格式 添加更多技术关键词 支持自定义标签规则 优化目录生成 添加更多错误处理 支持批量转换和增量转换 " }, { "title": "SSM整合", "url": "/posts/ssminteract/", "categories": "SSM整合", "tags": "spring, vue, framework, sql, database, react, git, kubernetes, mybatis, javascript, java, docker, python, mvc, maven, angular", "date": "2025-02-01 10:44:29 +0800", "content": " SSM整合 一、SSM整合理解 1.1 什么是SSM整合？ 1.2 SSM整合核心问题明确 二、SSM整合配置实战 2.1 依赖整合和添加 2.2 控制层配置编写(SpringMVC整合) 2.3 业务层配置编写(AOP / TX整合） 2.4 持久层配置编写(MyBatis整合) 2.5 容器初始化配置类 2.6 整合测试 三、《任务列表案例》前端程序搭建和运行 3.1 整合案例介绍和接口分析 3.2 前端工程导入 3.3 启动测试 四、《任务列表案例》后端程序实现和测试 4.1 准备工作 4.2 功能实现 4.3 前后联调 SSM整合 一、SSM整合理解 1.1 什么是SSM整合？ **微观**：将学习的Spring SpringMVC Mybatis框架应用到项目中! - SpringMVC框架负责控制层 - Spring 框架负责整体和业务层的声明式事务管理 - MyBatis框架负责数据库访问层 **宏观**：Spring接管一切（将框架核心组件交给Spring进行IoC管理），代码更加简洁。 - SpringMVC管理表述层、SpringMVC相关组件 - Spring管理业务层、持久层、以及数据库相关（DataSource,MyBatis）的组件 - 使用IoC的方式管理一切所需组件 **实施**：通过编写配置文件，实现SpringIoC容器接管一切组件。 1.2 SSM整合核心问题明确 #### 1.2.1 第一问：SSM整合需要几个IoC容器？ 两个容器 本质上说，整合就是将三层架构和框架核心API组件交给SpringIoC容器管理！ 一个容器可能就够了，但是我们常见的操作是创建两个IoC容器（web容器和root容器），组件分类管理！ 这种做法有以下好处和目的： 1. 分离关注点：通过初始化两个容器，可以将各个层次的关注点进行分离。这种分离使得各个层次的组件能够更好地聚焦于各自的责任和功能。 2. 解耦合：各个层次组件分离装配不同的IoC容器，这样可以进行解耦。这种解耦合使得各个模块可以独立操作和测试，提高了代码的可维护性和可测试性。 3. 灵活配置：通过使用两个容器，可以为每个容器提供各自的配置，以满足不同层次和组件的特定需求。每个配置文件也更加清晰和灵活。 总的来说，初始化两个容器在SSM整合中可以实现关注点分离、解耦合、灵活配置等好处。它们各自负责不同的层次和功能，并通过合适的集成方式协同工作，提供一个高效、可维护和可扩展的应用程序架构！ #### 1.2.2 第二问：每个IoC容器对应哪些类型组件？ 图解： ![](https://secure2.wostatic.cn/static/w2NYE3xCxPHJgjjQWFUVc9/image.png?auth_key=1741057663-wxysCsRqKr8Y75ALdytm86-0-5081eb50cbeba3ac218d6e59ce790a99)​ 总结：     容器名 盛放组件 web容器 web相关组件（controller,springmvc核心组件） root容器 业务和持久层相关组件（service,aop,tx,dataSource,mybatis,mapper等） #### 1.2.3 第三问：IoC容器之间关系和调用方向？ 情况1：两个无关联IoC容器之间的组件无法注入！ ![](https://secure2.wostatic.cn/static/vMfLzz8fAT5feTQFNQk2Ck/image.png?auth_key=1741057675-sYSipL18i8isbETuE7EvDW-0-8e29369e0f98dff5dcd088988d18e460)​ 情况2：子IoC容器可以单向的注入父IoC容器的组件！ ![](https://secure2.wostatic.cn/static/uxEKuZFmyxEeSQeSKUNHFQ/image.png?auth_key=1741057675-jnKKZx5t5s8kg3qanBX33-0-3ae37ddd944ae2676b9a3f167c055b72)​ 结论：web容器是root容器的子容器，父子容器关系。 - 父容器：root容器，盛放service、mapper、mybatis等相关组件 - 子容器：web容器，盛放controller、web相关组件 源码体现： FrameworkServlet 655行！ protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) { Class&lt;?&gt; contextClass = getContextClass(); if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) { throw new ApplicationContextException( \"Fatal initialization error in servlet with name '\" + getServletName() + \"': custom WebApplicationContext class [\" + contextClass.getName() + \"] is not of type ConfigurableWebApplicationContext\"); } ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass); wac.setEnvironment(getEnvironment()); //wac 就是web ioc容器 //parent 就是root ioc容器 //web容器设置root容器为父容器，所以web容器可以引用root容器 wac.setParent(parent); String configLocation = getContextConfigLocation(); if (configLocation != null) { wac.setConfigLocation(configLocation); } configureAndRefreshWebApplicationContext(wac); return wac; } 调用流程图解： ![](https://secure2.wostatic.cn/static/pQrtrPTd58c7H4pWVDh7ZP/image.png?auth_key=1741057675-kKPR5Bxc5ohpenv688mxkE-0-c11c5650fb0f1bf90abf3f0308090940)​ #### 1.2.4 第四问：具体多少配置类以及对应容器关系？ 配置类的数量不是固定的，但是至少要两个，为了方便编写，我们可以三层架构每层对应一个配置类，分别指定两个容器加载即可！ ![](https://secure2.wostatic.cn/static/wM8R1HinFEYDuGfbRi5xjD/image.png?auth_key=1741057675-w4cVMVJzqjKYvoxgRiuDYP-0-42510d30cf52906918d88fecb7d70256)​ 建议配置文件：       配置名 对应内容 对应容器 WebJavaConfig controller,springmvc相关 web容器 ServiceJavaConfig service,aop,tx相关 root容器 MapperJavaConfig mapper,datasource,mybatis相关 root容器 #### 1.2.5 第五问：IoC初始化方式和配置位置？ 在web项目下，我们可以选择web.xml和配置类方式进行ioc配置，推荐配置类。 对于使用基于 web 的 Spring 配置的应用程序，建议这样做，如以下示例所示： public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { //指定root容器对应的配置类 //root容器的配置类 @Override protected Class&lt;?&gt;[] getRootConfigClasses() { return new Class&lt;?&gt;[] { ServiceJavaConfig.class,MapperJavaConfig.class }; } //指定web容器对应的配置类 webioc容器的配置类 @Override protected Class&lt;?&gt;[] getServletConfigClasses() { return new Class&lt;?&gt;[] { WebJavaConfig.class }; } //指定dispatcherServlet处理路径，通常为 / @Override protected String[] getServletMappings() { return new String[] { \"/\" }; } } 图解配置类和容器配置： ![](https://secure2.wostatic.cn/static/wEKxog3yiwNGhcfNwg6Aug/image.png?auth_key=1741057674-2bmaj28BNpa1DBpaJ9XYb-0-c286cdd3402a0ac41d047c6057b9c5ac)​ 二、SSM整合配置实战 2.1 依赖整合和添加 1. 数据库准备 依然沿用mybatis数据库测试脚本！ CREATE DATABASE `mybatis-example`; USE `mybatis-example`; CREATE TABLE `t_emp`( emp_id INT AUTO_INCREMENT, emp_name CHAR(100), emp_salary DOUBLE(10,5), PRIMARY KEY(emp_id) ); INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(\"tom\",200.33); INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(\"jerry\",666.66); INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(\"andy\",777.77); 2. 准备项目 part04-ssm-integration 转成web项目 3. 依赖导入 pom.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;part04-ssm-integration&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;spring.version&gt;6.0.6&lt;/spring.version&gt; &lt;jakarta.annotation-api.version&gt;2.1.1&lt;/jakarta.annotation-api.version&gt; &lt;jakarta.jakartaee-web-api.version&gt;9.1.0&lt;/jakarta.jakartaee-web-api.version&gt; &lt;jackson-databind.version&gt;2.15.0&lt;/jackson-databind.version&gt; &lt;hibernate-validator.version&gt;8.0.0.Final&lt;/hibernate-validator.version&gt; &lt;mybatis.version&gt;3.5.11&lt;/mybatis.version&gt; &lt;mysql.version&gt;8.0.25&lt;/mysql.version&gt; &lt;pagehelper.version&gt;5.1.11&lt;/pagehelper.version&gt; &lt;druid.version&gt;1.2.8&lt;/druid.version&gt; &lt;mybatis-spring.version&gt;3.0.2&lt;/mybatis-spring.version&gt; &lt;jakarta.servlet.jsp.jstl-api.version&gt;3.0.0&lt;/jakarta.servlet.jsp.jstl-api.version&gt; &lt;logback.version&gt;1.2.3&lt;/logback.version&gt; &lt;lombok.version&gt;1.18.26&lt;/lombok.version&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;!-- 需要依赖清单分析: spring ioc/di spring-context / 6.0.6 jakarta.annotation-api / 2.1.1 jsr250 aop spring-aspects / 6.0.6 tx spring-tx / 6.0.6 spring-jdbc / 6.0.6 springmvc spring-webmvc 6.0.6 jakarta.jakartaee-web-api 9.1.0 jackson-databind 2.15.0 hibernate-validator / hibernate-validator-annotation-processor 8.0.0.Final mybatis mybatis / 3.5.11 mysql / 8.0.25 pagehelper / 5.1.11 整合需要 加载spring容器 spring-web / 6.0.6 整合mybatis mybatis-spring x x 数据库连接池 druid / x lombok lombok / 1.18.26 logback logback/ 1.2.3 --&gt; &lt;dependencies&gt; &lt;!--spring pom.xml依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;${jakarta.annotation-api.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springmvc spring-webmvc 6.0.6 jakarta.jakartaee-web-api 9.1.0 jackson-databind 2.15.0 hibernate-validator / hibernate-validator-annotation-processor 8.0.0.Final --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.platform&lt;/groupId&gt; &lt;artifactId&gt;jakarta.jakartaee-web-api&lt;/artifactId&gt; &lt;version&gt;${jakarta.jakartaee-web-api.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jsp需要依赖! jstl--&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl-api&lt;/artifactId&gt; &lt;version&gt;${jakarta.servlet.jsp.jstl-api.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;${jackson-databind.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;${hibernate-validator.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt; &lt;version&gt;${hibernate-validator.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis mybatis / 3.5.11 mysql / 8.0.25 pagehelper / 5.1.11 --&gt; &lt;!-- mybatis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 mybatis底层依赖jdbc驱动实现,本次不需要导入连接池,mybatis自带! --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;${mysql.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;${pagehelper.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 整合第三方特殊依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;${mybatis-spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 ， 会自动传递slf4j门面--&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;${logback.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;${lombok.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;${druid.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 4. 实体类添加 com.atguigu.pojo @Data public class Employee { private Integer empId; private String empName; private Double empSalary; } 5. logback配置 位置：resources/logback.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;configuration debug=\"true\"&gt; &lt;!-- 指定日志输出的位置，ConsoleAppender表示输出到控制台 --&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;!-- 日志输出的格式 --&gt; &lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt; &lt;pattern&gt;[%d{HH:mm:ss.SSS}] [%-5level] [%thread] [%logger] [%msg]%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 设置全局日志级别。日志级别按顺序分别是：TRACE、DEBUG、INFO、WARN、ERROR --&gt; &lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt; &lt;root level=\"DEBUG\"&gt; &lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/root&gt; &lt;!-- 根据特殊需求指定局部日志级别，可也是包名或全类名。 --&gt; &lt;logger name=\"com.atguigu.mybatis\" level=\"DEBUG\" /&gt; &lt;/configuration&gt; 2.2 控制层配置编写(SpringMVC整合) &gt; 主要配置controller,springmvc相关组件配置 位置：WebJavaConfig.java(命名随意) /** * projectName: com.atguigu.config * * 1.实现Springmvc组件声明标准化接口WebMvcConfigurer 提供了各种组件对应的方法 * 2.添加配置类注解@Configuration * 3.添加mvc复合功能开关@EnableWebMvc * 4.添加controller层扫描注解 * 5.开启默认处理器,支持静态资源处理 */ @Configuration @EnableWebMvc @ComponentScan(\"com.atguigu.controller\") public class WebJavaConfig implements WebMvcConfigurer { //开启静态资源 @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { configurer.enable(); } } 2.3 业务层配置编写(AOP / TX整合） &gt; 主要配置service,注解aop和声明事务相关配置 位置：ServiceJavaConfig.java(命名随意) /** * projectName: com.atguigu.config * * 1. 声明@Configuration注解,代表配置类 * 2. 声明@EnableTransactionManagement注解,开启事务注解支持 * 3. 声明@EnableAspectJAutoProxy注解,开启aspect aop注解支持 * 4. 声明@ComponentScan(\"com.atguigu.service\")注解,进行业务组件扫描 * 5. 声明transactionManager(DataSource dataSource)方法,指定具体的事务管理器 */ @EnableTransactionManagement @EnableAspectJAutoProxy @Configuration @ComponentScan(\"com.atguigu.service\") public class ServiceJavaConfig { @Bean public DataSourceTransactionManager transactionManager(DataSource dataSource){ DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } } 2.4 持久层配置编写(MyBatis整合) &gt; 主要配置mapper代理对象，连接池和mybatis核心组件配置 1. **mybatis整合思路** mybatis核心api使用回顾： //1.读取外部配置文件 InputStream ips = Resources.getResourceAsStream(\"mybatis-config.xml\"); //2.创建sqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(ips); //3.创建sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); //4.获取mapper代理对象 EmpMapper empMapper = sqlSession.getMapper(EmpMapper.class); //5.数据库方法调用 int rows = empMapper.deleteEmpById(1); System.out.println(\"rows = \" + rows); //6.提交和回滚 sqlSession.commit(); sqlSession.close(); mybatis核心api介绍回顾： - SqlSessionFactoryBuilder 这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 无需ioc容器管理！ - SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，因此 SqlSessionFactory 的最佳作用域是应用作用域。 **需要ioc容器管理！** - SqlSession 每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 无需ioc容器管理！ - Mapper映射器实例 映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 从作用域的角度来说，映射器实例不应该交给ioc容器管理！ 但是从使用的角度来说，业务类（service）需要注入mapper接口，**所以mapper应该交给ioc容器管理！** ![](https://secure2.wostatic.cn/static/hH8ePatRVZGh9moumizi2s/image.png?auth_key=1741057663-ubcu9ARaqNGopEmNJWyMmR-0-78e67883a4ac97afb568731e3c2bf74e) - 总结 - 将SqlSessionFactory实例存储到IoC容器 - 将Mapper实例存储到IoC容器 mybatis整合思路理解： mybatis的api实例化需要复杂的过程。 例如，自己实现sqlSessionFactory加入ioc容器： @Bean public SqlSessionFactory sqlSessionFactory(){ //1.读取外部配置文件 InputStream ips = Resources.getResourceAsStream(\"mybatis-config.xml\"); //2.创建sqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(ips); return sqlSessionFactory; } 过程比较繁琐，为了提高整合效率，mybatis提供了提供封装SqlSessionFactory和Mapper实例化的逻辑的FactoryBean组件，我们只需要声明和指定少量的配置即可！ SqlSessionFactoryBean源码展示(mybatis提供)： package org.mybatis.spring; public class SqlSessionFactoryBean implements FactoryBean&lt;SqlSessionFactory&gt;, InitializingBean, ApplicationListener&lt;ContextRefreshedEvent&gt; { //封装了实例化流程 public SqlSessionFactory getObject() throws Exception { if (this.sqlSessionFactory == null) { //实例化对象逻辑 afterPropertiesSet(); } //返回对象逻辑 return this.sqlSessionFactory; } } mybatis整合思路总结： - 需要将SqlSessionFactory和Mapper实例加入到IoC容器 - 使用mybatis整合包提供的FactoryBean快速整合 2. **准备外部配置文件** &gt; 数据库连接信息 位置：resources/jdbc.properties jdbc.user=root jdbc.password=root jdbc.url=jdbc:mysql:///mybatis-example jdbc.driver=com.mysql.cj.jdbc.Driver 3. **整合方式1** （保留mybatis-config.xml） 1. 介绍 依然保留mybatis的外部配置文件（xml）, 但是数据库连接信息交给Druid连接池配置！ ![](https://secure2.wostatic.cn/static/gAu9k8yPfZDhYCSQHCLbC8/image.png?auth_key=1741057665-mJe6Ni3M2C8Q3XmB2uu4jJ-0-649b9e6aa25c6c76935edc8fe1ae0dfe)​ 缺点：依然需要mybatis-config.xml文件，进行xml文件解析，效率偏低！ 2. mybatis配置文件 &gt; 数据库信息以及mapper扫描包设置使用Java配置类处理！mybatis其他的功能（别名、settings、插件等信息）依然在mybatis-config.xml配置！ &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; &lt;configuration&gt; &lt;settings&gt; &lt;!-- 开启驼峰式映射--&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;!-- 开启logback日志输出--&gt; &lt;setting name=\"logImpl\" value=\"SLF4J\"/&gt; &lt;!--开启resultMap自动映射 --&gt; &lt;setting name=\"autoMappingBehavior\" value=\"FULL\"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!-- 给实体类起别名 --&gt; &lt;package name=\"com.atguigu.pojo\"/&gt; &lt;/typeAliases&gt; &lt;plugins&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;!-- helperDialect：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值： oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby （完整内容看 PageAutoDialect） 特别注意：使用 SqlServer2012 数据库时， https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%B9%E8%A8%80 --&gt; &lt;property name=\"helperDialect\" value=\"mysql\"/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/configuration&gt; 3. mybatis和持久层配置类 &gt; 持久层Mapper配置、数据库配置、Mybatis配置信息 位置：MapperJavaConfig.java(命名随意) @Configuration @PropertySource(\"classpath:jdbc.properties\") public class MapperJavaConfig { @Value(\"${jdbc.user}\") private String user; @Value(\"${jdbc.password}\") private String password; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.driver}\") private String driver; //数据库连接池配置 @Bean public DataSource dataSource(){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setUsername(user); dataSource.setPassword(password); dataSource.setUrl(url); dataSource.setDriverClassName(driver); return dataSource; } /** * 配置SqlSessionFactoryBean,指定连接池对象和外部配置文件即可 * @param dataSource 需要注入连接池对象 * @return 工厂Bean */ @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){ //实例化SqlSessionFactory工厂 SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); //设置连接池 sqlSessionFactoryBean.setDataSource(dataSource); //设置配置文件 //包裹外部配置文件地址对象 Resource resource = new ClassPathResource(\"mybatis-config.xml\"); sqlSessionFactoryBean.setConfigLocation(resource); return sqlSessionFactoryBean; } /** * 配置Mapper实例扫描工厂,配置 &lt;mapper &lt;package 对应接口和mapperxml文件所在的包 * @return */ @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); //设置mapper接口和xml文件所在的共同包 mapperScannerConfigurer.setBasePackage(\"com.atguigu.mapper\"); return mapperScannerConfigurer; } } 问题： 当你在Spring配置类中添加了`sqlSessionFactoryBean`​和`mapperScannerConfigurer`​配置方法时，可能会导致`@Value`​注解读取不到值为null的问题。这是因为`SqlSessionFactoryBean`​和`MapperScannerConfigurer`​是基于MyBatis框架的配置，它们的初始化顺序可能会导致属性注入的问题。 `SqlSessionFactoryBean`​和`MapperScannerConfigurer`​在配置类中通常是用来配置MyBatis相关的Bean，例如数据源、事务管理器、Mapper扫描等。这些配置类通常在`@Configuration`​注解下定义，并且使用`@Value`​注解来注入属性值。 当配置类被加载时，Spring容器会首先处理Bean的定义和初始化，其中包括`sqlSessionFactoryBean`​和`mapperScannerConfigurer`​的初始化。在这个过程中，如果`@Value`​注解所在的Bean还没有被完全初始化，可能会导致注入的属性值为null。 解决方案： 分成两个配置类独立配置，互不影响，数据库提取一个配置类，mybatis提取一个配置类即可解决！ 4. 拆分配置 数据库配置类（DataSourceJavaConfig.java） @Configuration @PropertySource(\"classpath:jdbc.properties\") public class DataSourceJavaConfig { @Value(\"${jdbc.user}\") private String user; @Value(\"${jdbc.password}\") private String password; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.driver}\") private String driver; //数据库连接池配置 @Bean public DataSource dataSource(){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setUsername(user); dataSource.setPassword(password); dataSource.setUrl(url); dataSource.setDriverClassName(driver); return dataSource; } } mybatis配置类（MapperJavaConfig.java） @Configuration public class MapperJavaConfig { /** * 配置SqlSessionFactoryBean,指定连接池对象和外部配置文件即可 * @param dataSource 需要注入连接池对象 * @return 工厂Bean */ @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){ //实例化SqlSessionFactory工厂 SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); //设置连接池 sqlSessionFactoryBean.setDataSource(dataSource); //设置配置文件 //包裹外部配置文件地址对象 Resource resource = new ClassPathResource(\"mybatis-config.xml\"); sqlSessionFactoryBean.setConfigLocation(resource); return sqlSessionFactoryBean; } /** * 配置Mapper实例扫描工厂,配置 &lt;mapper &lt;package 对应接口和mapperxml文件所在的包 * @return */ @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); //设置mapper接口和xml文件所在的共同包 mapperScannerConfigurer.setBasePackage(\"com.atguigu.mapper\"); return mapperScannerConfigurer; } } 4. **整合方式2（完全配置类 去掉mybatis-config.xml）** 1. 介绍 不在保留mybatis的外部配置文件（xml）, 所有配置信息（settings、插件、别名等）全部在声明SqlSessionFactoryBean的代码中指定！数据库信息依然使用DruidDataSource实例替代！ ![](https://secure2.wostatic.cn/static/2JhkSCyCAyAihmQGsjw7zd/image.png?auth_key=1741057672-ns5bTNDx3nziMQnpAvEAaQ-0-bb10045114ba2d1c105ab74ff1058dbb)​ 优势：全部配置类，避免了XML文件解析效率低问题！ 2. mapper配置类 /** * projectName: com.atguigu.config * * description: 持久层配置和Druid和Mybatis配置 使用一个配置文件 */ @Configuration public class MapperJavaConfigNew { /** * 配置SqlSessionFactoryBean,指定连接池对象和外部配置文件即可 * @param dataSource 需要注入连接池对象 * @return 工厂Bean */ @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){ //实例化SqlSessionFactory工厂 SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); //设置连接池 sqlSessionFactoryBean.setDataSource(dataSource); //TODO: 替代xml文件的java配置 /* &lt;settings&gt; &lt;!-- 开启驼峰式映射--&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;!-- 开启logback日志输出--&gt; &lt;setting name=\"logImpl\" value=\"SLF4J\"/&gt; &lt;!--开启resultMap自动映射 --&gt; &lt;setting name=\"autoMappingBehavior\" value=\"FULL\"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!-- 给实体类起别名 --&gt; &lt;package name=\"com.atguigu.pojo\"/&gt; &lt;/typeAliases&gt; &lt;plugins&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;!-- helperDialect：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值： oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby （完整内容看 PageAutoDialect） 特别注意：使用 SqlServer2012 数据库时， https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%B9%E8%A8%80 --&gt; &lt;property name=\"helperDialect\" value=\"mysql\"/&gt; &lt;/plugin&gt; &lt;/plugins&gt; */ //settings [包裹到一个configuration对象,切记别倒错包] org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration(); configuration.setMapUnderscoreToCamelCase(true); configuration.setLogImpl(Slf4jImpl.class); configuration.setAutoMappingBehavior(AutoMappingBehavior.FULL); sqlSessionFactoryBean.setConfiguration(configuration); //typeAliases sqlSessionFactoryBean.setTypeAliasesPackage(\"com.atguigu.pojo\"); //分页插件配置 PageInterceptor pageInterceptor = new PageInterceptor(); Properties properties = new Properties(); properties.setProperty(\"helperDialect\",\"mysql\"); pageInterceptor.setProperties(properties); sqlSessionFactoryBean.addPlugins(pageInterceptor); return sqlSessionFactoryBean; } /** * 配置Mapper实例扫描工厂,配置 &lt;mapper &lt;package 对应接口和mapperxml文件所在的包 * @return */ @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); //设置mapper接口和xml文件所在的共同包 mapperScannerConfigurer.setBasePackage(\"com.atguigu.mapper\"); return mapperScannerConfigurer; } } 2.5 容器初始化配置类 public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { //指定root容器对应的配置类 @Override protected Class&lt;?&gt;[] getRootConfigClasses() { return new Class&lt;?&gt;[] {MapperJavaConfig.class, ServiceJavaConfig.class, DataSourceJavaConfig.class }; } //指定web容器对应的配置类 @Override protected Class&lt;?&gt;[] getServletConfigClasses() { return new Class&lt;?&gt;[] { WebJavaConfig.class }; } //指定dispatcherServlet处理路径，通常为 / @Override protected String[] getServletMappings() { return new String[] { \"/\" }; } } 2.6 整合测试 1. 需求 查询所有员工信息,返回对应json数据！ 2. controller @Slf4j @RestController @RequestMapping(\"/employee\") public class EmployeeController { @Autowired private EmployeeService employeeService; @GetMapping(\"list\") public List&lt;Employee&gt; retList(){ List&lt;Employee&gt; employees = employeeService.findAll(); log.info(\"员工数据:{}\",employees); return employees; } } 3. service @Service public class EmployeeServiceImpl implements EmployeeService { @Autowired private EmployeeMapper employeeMapper; /** * 查询所有员工信息 */ @Override public List&lt;Employee&gt; findAll() { List&lt;Employee&gt; employeeList = employeeMapper.queryAll(); return employeeList; } } 4. mapper mapper接口 包：com.atguigu.mapper public interface EmployeeMapper { List&lt;Employee&gt; queryAll(); } mapper XML 文件位置： resources/mappers &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"https://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt; &lt;mapper namespace=\"com.atguigu.mapper.EmployeeMapper\"&gt; &lt;select id=\"queryAll\" resultType=\"employee\"&gt; &lt;!-- #{empId}代表动态传入的参数,并且进行赋值!后面详细讲解 --&gt; select emp_id empId,emp_name empName, emp_salary empSalary from t_emp &lt;/select&gt; &lt;/mapper&gt; 三、《任务列表案例》前端程序搭建和运行 3.1 整合案例介绍和接口分析 #### 3.1.1 案例功能预览 ![](https://secure2.wostatic.cn/static/7zSuCEEGmTUA6ErSHyy8ga/image.png?auth_key=1741057693-u5HNs2jqgcbYQeH6STKRxF-0-44cbb587e7523d6a0256870f10c11e23)​ #### 3.1.2接口分析 1. 学习计划分页查询 /* 需求说明 查询全部数据页数据 请求uri schedule/{pageSize}/{currentPage} 请求方式 get 响应的json { \"code\":200, \"flag\":true, \"data\":{ //本页数据 data: [ {id:1,title:'学习java',completed:true}, {id:2,title:'学习html',completed:true}, {id:3,title:'学习css',completed:true}, {id:4,title:'学习js',completed:true}, {id:5,title:'学习vue',completed:true} ], //分页参数 pageSize:5, // 每页数据条数 页大小 total:0 , // 总记录数 currentPage:1 // 当前页码 } } */ 2. 学习计划删除 /* 需求说明 根据id删除日程 请求uri schedule/{id} 请求方式 delete 响应的json { \"code\":200, \"flag\":true, \"data\":null } */ 3. 学习计划保存 /* 需求说明 增加日程 请求uri schedule 请求方式 post 请求体中的JSON { title: '', completed: false } 响应的json { \"code\":200, \"flag\":true, \"data\":null } */ 4. 学习计划修改 /* 需求说明 根据id修改数据 请求uri schedule 请求方式 put 请求体中的JSON { id: 1, title: '', completed: false } 响应的json { \"code\":200, \"flag\":true, \"data\":null } */ 3.2 前端工程导入 #### 3.2.1 前端环境搭建 &gt; Node.js 是前端程序运行的服务器，类似Java程序运行的服务器Tomcat Npm 是前端依赖包管理工具，类似maven依赖管理工具软件 1. node安装 课程node版本：16.16.0 https://nodejs.org/download/release/v16.16.0/ **node安装和测试：** 1. 打开官网 [https://nodejs.org/en/](https://nodejs.org/en/) 下载对应操作系统的 LTS 版本。（16.16.0） 2. 双击安装包进行安装，安装过程中遵循默认选项即可。安装完成后，可以在命令行终端输入 `node -v`​ 和 `npm -v`​ 查看 Node.js 和 npm 的版本号。 2. npm使用 （maven） &gt; NPM全称Node Package Manager，是Node.js包管理工具，是全球最大的模块生态系统，里面所有的模块都是开源免费的；也是Node.js的包管理工具，相当于后端的Maven 。 1. 配置阿里镜像 npm config set registry https://registry.npmjs.org/ 2. 更新npm版本 &gt; node16.16.0对应的npm版本过低！需要升级！ npm install -g npm@9.6.6 3. npm依赖下载命令 npm install 依赖名 / npm install 依赖名@版本 3. 安装vscode #### 3.2.2 导入前端程序 点击加载前端程序！ ![](https://secure2.wostatic.cn/static/a35sFbX59L9HWAFkUznjQ/image.png?auth_key=1741057682-c2vNN57NLT5VerWYypqpeV-0-09fe040bf33b85545cdf9dfac26a99c1)​ 3.3 启动测试 npm install //安装依赖 npm run dev //运行测试 四、《任务列表案例》后端程序实现和测试 4.1 准备工作 1. 准备数据库脚本 CREATE TABLE schedule ( id INT NOT NULL AUTO_INCREMENT, title VARCHAR(255) NOT NULL, completed BOOLEAN NOT NULL, PRIMARY KEY (id) ); INSERT INTO schedule (title, completed) VALUES ('学习java', true), ('学习Python', false), ('学习C++', true), ('学习JavaScript', false), ('学习HTML5', true), ('学习CSS3', false), ('学习Vue.js', true), ('学习React', false), ('学习Angular', true), ('学习Node.js', false), ('学习Express', true), ('学习Koa', false), ('学习MongoDB', true), ('学习MySQL', false), ('学习Redis', true), ('学习Git', false), ('学习Docker', true), ('学习Kubernetes', false), ('学习AWS', true), ('学习Azure', false); 2. 准备pojo 包：com.atguigu.pojo /** * projectName: com.atguigu.pojo * * description: 任务实体类 */ @Data public class Schedule { private Integer id; private String title; private Boolean completed; } 3. 准备 R 包：com.atguigu.utils ** * projectName: com.atguigu.utils * * description: 返回结果类 */ public class R { private int code = 200; //200成功状态码 private boolean flag = true; //返回状态 private Object data; //返回具体数据 public static R ok(Object data){ R r = new R(); r.data = data; return r; } public static R fail(Object data){ R r = new R(); r.code = 500; //错误码 r.flag = false; //错误状态 r.data = data; return r; } public int getCode() { return code; } public void setCode(int code) { this.code = code; } public boolean isFlag() { return flag; } public void setFlag(boolean flag) { this.flag = flag; } public Object getData() { return data; } public void setData(Object data) { this.data = data; } } 4. 准备 PageBean 包：com.atguigu.utils @Data @NoArgsConstructor @AllArgsConstructor public class PageBean&lt;T&gt; { private int currentPage; // 当前页码 private int pageSize; // 每页显示的数据量 private long total; // 总数据条数 private List&lt;T&gt; data; // 当前页的数据集合 } 4.2 功能实现 1. 分页查询 1. controller /* @CrossOrigin 注释在带注释的控制器方法上启用跨源请求 */ @CrossOrigin @RequestMapping(\"schedule\") @RestController public class ScheduleController { @Autowired private ScheduleService scheduleService; @GetMapping(\"/{pageSize}/{currentPage}\") public R showList(@PathVariable(name = \"pageSize\") int pageSize, @PathVariable(name = \"currentPage\") int currentPage){ PageBean&lt;Schedule&gt; pageBean = scheduleService.findByPage(pageSize,currentPage); return R.ok(pageBean); } } 2. service @Slf4j @Service public class ScheduleServiceImpl implements ScheduleService { @Autowired private ScheduleMapper scheduleMapper; /** * 分页数据查询,返回分页pageBean * * @param pageSize * @param currentPage * @return */ @Override public PageBean&lt;Schedule&gt; findByPage(int pageSize, int currentPage) { //1.设置分页参数 PageHelper.startPage(currentPage,pageSize); //2.数据库查询 List&lt;Schedule&gt; list = scheduleMapper.queryPage(); //3.结果获取 PageInfo&lt;Schedule&gt; pageInfo = new PageInfo&lt;&gt;(list); //4.pageBean封装 PageBean&lt;Schedule&gt; pageBean = new PageBean&lt;&gt;(pageInfo.getPageNum(),pageInfo.getPageSize(),pageInfo.getTotal(),pageInfo.getList()); log.info(\"分页查询结果:{}\",pageBean); return pageBean; } } 3. mapper mapper接口 public interface ScheduleMapper { List&lt;Schedule&gt; queryPage(); } mapperxml文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"https://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt; &lt;mapper namespace=\"com.atguigu.mapper.ScheduleMapper\"&gt; &lt;select id=\"queryPage\" resultType=\"schedule\"&gt; select * from schedule &lt;/select&gt; &lt;/mapper&gt; 2. 计划添加 1. controller @PostMapping public R saveSchedule(@RequestBody Schedule schedule){ scheduleService.saveSchedule(schedule); return R.ok(null); } 2. service /** * 保存学习计划 * * @param schedule */ @Override public void saveSchedule(Schedule schedule) { scheduleMapper.insert(schedule); } 3. mapper mapper接口 void insert(Schedule schedule); mapperxml文件 &lt;insert id=\"insert\"&gt; insert into schedule (title, completed) values (#{title}, #{completed}); &lt;/insert&gt; 3. 计划删除 1. controller @DeleteMapping(\"/{id}\") public R removeSchedule(@PathVariable Integer id){ scheduleService.removeById(id); return R.ok(null); } 2. service /** * 移除学习计划 * * @param id */ @Override public void removeById(Integer id) { scheduleMapper.delete(id); } 3. mapper mapper接口 void delete(Integer id); mapperxml文件 &lt;delete id=\"delete\"&gt; delete from schedule where id = #{id} &lt;/delete&gt; 4. 计划修改 1. controller @PutMapping public R changeSchedule(@RequestBody Schedule schedule){ scheduleService.updateSchedule(schedule); return R.ok(null); } 2. service /** * 更新学习计划 * * @param schedule */ @Override public void updateSchedule(Schedule schedule) { scheduleMapper.update(schedule); } 3. mapper mapper接口 void update(Schedule schedule); mapperxml文件 &lt;update id=\"update\"&gt; update schedule set title = #{title} , completed = #{completed} where id = #{id} &lt;/update&gt; 4.3 前后联调 1. 后台项目根路径设计 ![](https://secure2.wostatic.cn/static/54wi7bwJfuF1Dc5Z6vLbPq/image.png) 2. 启动测试即可 " }, { "title": "Springboot", "url": "/posts/springboot/", "categories": "Springboot", "tags": "spring, sql, framework, database, mybatis, javascript, java, mvc, maven, boot", "date": "2025-01-07 10:44:29 +0800", "content": " Springboot 一、SpringBoot3介绍 1.1 SpringBoot3简介 1.2 系统要求 1.3 快速入门 1.4 入门总结 二、SpringBoot3配置文件 2.1 统一配置管理概述 2.2 属性配置文件使用 2.3 YAML配置文件使用 2.4 批量配置文件注入 2.5 多环境配置和使用 三、SpringBoot3整合SpringMVC 3.1 实现过程 3.2 web相关配置 3.3 静态资源处理 3.4 自定义拦截器(SpringMVC配置) 四、SpringBoot3整合Druid数据源 五、SpringBoot3整合Mybatis 5.1 MyBatis整合步骤 5.2 Mybatis整合实践 5.3 声明式事务整合配置 5.4 AOP整合配置 六、SpringBoot3项目打包和运行 6.1 添加打包插件 6.2 执行打包 6.3 命令启动和参数说明 Springboot 一、SpringBoot3介绍 1.1 SpringBoot3简介 &gt; 课程使用SpringBoot版本：3.0.5 https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.introducing-spring-boot 到目前为止，你已经学习了多种配置Spring程序的方式。但是无论使用XML、注解、Java配置类还是他们的混合用法，你都会觉得配置文件过于复杂和繁琐，让人头疼！ ![](https://secure2.wostatic.cn/static/v2iCQCZMNTcknu8qgRYmT8/image.png?auth_key=1741057749-3vqUipXsycfyghQ1orj4TE-0-ed68c793ad4f152fa575d5ec51e708b9)​ SpringBoot 帮我们简单、快速地创建一个独立的、生产级别的 **Spring 应用（说明：SpringBoot底层是Spring）** ，大多数 SpringBoot 应用只需要编写少量配置即可快速整合 Spring 平台以及第三方技术！ SpringBoot的主要目标是： - 为所有 Spring 开发提供更快速、可广泛访问的入门体验。 - 开箱即用，设置合理的默认值，但是也可以根据需求进行适当的调整。 - 提供一系列大型项目通用的非功能性程序（如嵌入式服务器、安全性、指标、运行检查等）。 - 约定大于配置，基本不需要主动编写配置类、也不需要 XML 配置文件。 **总结：简化开发，简化配置，简化整合，简化部署，简化监控，简化运维。** 1.2 系统要求     技术&amp;工具 版本（or later） maven 3.6.3 or later 3.6.3 或更高版本 Tomcat 10.0+ Servlet 9.0+ JDK 17+ 1.3 快速入门 &gt; 场景：浏览器发送 **/hello**请求，返回\"**Hello,Spring Boot 3!** \" 1. 开发步骤 1. **创建Maven工程** 2. **添加依赖(springboot父工程依赖 , web启动器依赖)** 3. **编写启动引导类(springboot项目运行的入口)** 4. **编写处理器Controller** 5. **启动项目** 2. 创建项目 ![](https://secure2.wostatic.cn/static/foJ38Y4ug97TQBT8sacjeS/image-20230620112943613.png?auth_key=1741057748-6hYZ3HUt9Sc9zQtEKEFi7a-0-8b6c3d82f587d52b69b11512fb7fc818) 3. 添加依赖 3.1 添加父工程坐标 SpringBoot可以帮我们方便的管理项目依赖 , 在Spring Boot提供了一个名为**spring-boot-starter-parent**的工程，里面已经对各种常用依赖的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标(不需要添加版本)即可！ &lt;!--所有springboot项目都必须继承自 spring-boot-starter-parent--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/parent&gt; 3.2 添加web启动器 为了让Spring Boot帮我们完成各种自动配置，我们必须引入Spring Boot提供的**自动配置依赖**，我们称为**启动器**。因为我们是web项目，这里我们引入web启动器，在 pom.xml 文件中加入如下依赖： &lt;dependencies&gt; &lt;!--web开发的场景启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 4. 创建启动类 创建package：com.atguigu 创建启动类：MainApplication package com.atguigu; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; /** * @SpringBootApplication是一个特殊的注解，用于标识一个Spring Boot应用程序的入口类。它的主要作用是将三个常用注解组合在一起，简化了配置的过程。 * * 具体而言，@SpringBootApplication注解包含以下三个注解的功能： * @Configuration：将该类标识为应用程序的配置类。它允许使用Java代码定义和配置Bean。 * @EnableAutoConfiguration：启用Spring Boot的自动配置机制。它根据项目的依赖项自动配置Spring应用程序的行为。自动配置根据类路径、注解和配置属性等条件来决定要使用的功能和配置。 * @ComponentScan：自动扫描并加载应用程序中的组件，如控制器、服务、存储库等。它默认扫描@SpringBootApplication注解所在类的包及其子包中的组件。 * * 使用@SpringBootApplication注解，可以将上述三个注解的功能集中在一个注解上，简化了配置文件的编写和组件的加载和扫描过程。它是Spring Boot应用程序的入口点，标识了应用程序的主类， * 并告诉Spring Boot在启动时应如何配置和加载应用程序。 */ @SpringBootApplication public class MainApplication { //SpringApplication.run() 方法是启动 Spring Boot 应用程序的关键步骤。它创建应用程序上下文、 // 自动配置应用程序、启动应用程序，并处理命令行参数，使应用程序能够运行和提供所需的功能 public static void main(String[] args) { SpringApplication.run(MainApplication.class,args); } } 5. 编写处理器Controller 创建package：com.atguigu.controller 创建类：HelloController 注意： IoC和DI注解需要在启动类的同包或者子包下方可生效！无需指定，约束俗称。 package com.atguigu.controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @GetMapping(\"/hello\") public String hello(){ return \"Hello,Spring Boot 3!\"; } } 6. 启动测试 ![](https://secure2.wostatic.cn/static/sXdXQCXzfb9gE7YxfN7gZm/image-20230620094218277.png?auth_key=1741057748-hP9vFmoNyV5j6vVaJdG5C5-0-045cdde58c9d0c24bb3299ec8b374dcc)​ 1.4 入门总结 1. 为什么依赖不需要写版本？ - 每个boot项目都有一个父项目`spring-boot-starter-parent`​ - parent的父项目是`spring-boot-dependencies`​ - 父项目 **版本仲裁中心**，把所有常见的jar的依赖版本都声明好了。 - 比如：`mysql-connector-j`​ ![](https://secure2.wostatic.cn/static/mprL4dA8PhidURuMKVS36c/1679294529375-4ee1cd26-8ebc-4abf-bff9-f8775e10c927.png?auth_key=1741057747-EibQZ46yphFd1Z9mcjpfS-0-c062c581ee1e94771280ab03143857b0) 2. 启动器(Starter)是何方神圣？ Spring Boot提供了一种叫做Starter的概念，它是一组预定义的依赖项集合，旨在简化Spring应用程序的配置和构建过程。Starter包含了一组相关的依赖项，以便在启动应用程序时自动引入所需的库、配置和功能。 主要作用如下： 1. 简化依赖管理：Spring Boot Starter通过捆绑和管理一组相关的依赖项，减少了手动解析和配置依赖项的工作。只需引入一个相关的Starter依赖，即可获取应用程序所需的全部依赖。 2. 自动配置：Spring Boot Starter在应用程序启动时自动配置所需的组件和功能。通过根据类路径和其他设置的自动检测，Starter可以自动配置Spring Bean、数据源、消息传递等常见组件，从而使应用程序的配置变得简单和维护成本降低。 3. 提供约定优于配置：Spring Boot Starter遵循“约定优于配置”的原则，通过提供一组默认设置和约定，减少了手动配置的需要。它定义了标准的配置文件命名约定、默认属性值、日志配置等，使得开发者可以更专注于业务逻辑而不是繁琐的配置细节。 4. 快速启动和开发应用程序：Spring Boot Starter使得从零开始构建一个完整的Spring Boot应用程序变得容易。它提供了主要领域（如Web开发、数据访问、安全性、消息传递等）的Starter，帮助开发者快速搭建一个具备特定功能的应用程序原型。 5. 模块化和可扩展性：Spring Boot Starter的组织结构使得应用程序的不同模块可以进行分离和解耦。每个模块可以有自己的Starter和依赖项，使得应用程序的不同部分可以按需进行开发和扩展。 ![](https://secure2.wostatic.cn/static/o2gKapMUgTbdEwgGoYEdY4/image.png?auth_key=1741057747-kw2B5H5Z4mzayJ65rBxYv8-0-e2814f4ecf6c630e866334138d2a2214)​ Spring Boot提供了许多预定义的Starter，例如spring-boot-starter-web用于构建Web应用程序，spring-boot-starter-data-jpa用于使用JPA进行数据库访问，spring-boot-starter-security用于安全认证和授权等等。 使用Starter非常简单，只需要在项目的构建文件（例如Maven的pom.xml）中添加所需的Starter依赖，Spring Boot会自动处理依赖管理和配置。 通过使用Starter，开发人员可以方便地引入和配置应用程序所需的功能，避免了手动添加大量的依赖项和编写冗长的配置文件的繁琐过程。同时，Starter也提供了一致的依赖项版本管理，确保依赖项之间的兼容性和稳定性。 spring boot提供的全部启动器地址： [https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters) 命名规范： - 官方提供的场景：命名为：`spring-boot-starter-*`​ - 第三方提供场景：命名为：`*-spring-boot-starter`​ 3. @SpringBootApplication注解的功效？ @SpringBootApplication添加到启动类上，是一个组合注解，他的功效有具体的子注解实现！ @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan public @interface SpringBootApplication {} @SpringBootApplication注解是Spring Boot框架中的核心注解，它的主要作用是简化和加速Spring Boot应用程序的配置和启动过程。 具体而言，@SpringBootApplication注解起到以下几个主要作用： 1. 自动配置：@SpringBootApplication注解包含了@EnableAutoConfiguration注解，用于启用Spring Boot的自动配置机制。自动配置会根据应用程序的依赖项和类路径，自动配置各种常见的Spring配置和功能，减少开发者的手动配置工作。它通过智能地分析类路径、加载配置和条件判断，为应用程序提供适当的默认配置。 2. 组件扫描：@SpringBootApplication注解包含了@ComponentScan注解，用于自动扫描并加载应用程序中的组件，例如控制器（Controllers）、服务（Services）、存储库（Repositories）等。它默认会扫描@SpringBootApplication注解所在类的包及其子包中的组件，并将它们纳入Spring Boot应用程序的上下文中，使它们可被自动注入和使用。 3. 声明配置类：@SpringBootApplication注解本身就是一个组合注解，它包含了@Configuration注解，将被标注的类声明为配置类。配置类可以包含Spring框架相关的配置、Bean定义，以及其他的自定义配置。通过@SpringBootApplication注解，开发者可以将配置类与启动类合并在一起，使得配置和启动可以同时发生。 总的来说，@SpringBootApplication注解的主要作用是简化Spring Boot应用程序的配置和启动过程。它自动配置应用程序、扫描并加载组件，并将配置和启动类合二为一，简化了开发者的工作量，提高了开发效率。 二、SpringBoot3配置文件 2.1 统一配置管理概述 SpringBoot工程下，进行统一的配置管理，你想设置的任何参数（端口号、项目根路径、数据库连接信息等等)都集中到一个固定位置和命名的配置文件（`application.properties`​或`application.yml`​）中！ 配置文件应该放置在Spring Boot工程的`src/main/resources`​目录下。这是因为`src/main/resources`​目录是Spring Boot默认的类路径（classpath），配置文件会被自动加载并可供应用程序访问。 ![](https://secure2.wostatic.cn/static/b3fN9UqQkJkcKzMrCMQmwb/image.png?auth_key=1741057745-3BfWM17XhLLhZ9cG1hNJi6-0-42a923e4aa5b53d2a929b7ee7275d461)​ 功能配置参数说明： [https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties](https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties) 细节总结： - 集中式管理配置。统一在一个文件完成程序功能参数设置和自定义参数声明 。 - 位置：resources文件夹下，必须命名application 后缀 .properties / .yaml / .yml 。 - 如果同时存在application.properties | application.yml(.yaml) , properties的优先级更高。 - 配置基本都有默认值。 ![](https://secure2.wostatic.cn/static/cAcu1Js5uZsVntZWqd2buQ/image.png?auth_key=1741057746-duzaAirb9A5zAK9qB4cuiR-0-c99f929935f6cccf71eb84d4b02167f9)​ 2.2 属性配置文件使用 1. 配置文件 在 resource 文件夹下面新建 application.properties 配置文件 # application.properties 为统一配置文件 # 内部包含: 固定功能的key,自定义的key # 此处的配置信息,我们都可以在程序中@Value等注解读取 # 固定的key # 启动端口号 server.port=80 # 自定义 spring.jdbc.datasource.driverClassName=com.mysql.cj.jdbc.driver spring.jdbc.datasource.url=jdbc:mysql:///springboot_01 spring.jdbc.datasource.username=root spring.jdbc.datasource.password=root 2. 读取配置文件 package com.atguigu.properties; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component public class DataSourceProperties { @Value(\"${spring.jdbc.datasource.driverClassName}\") private String driverClassName; @Value(\"${spring.jdbc.datasource.url}\") private String url; @Value(\"${spring.jdbc.datasource.username}\") private String username; @Value(\"${spring.jdbc.datasource.password}\") private String password; // 生成get set 和 toString方法 public String getDriverClassName() { return driverClassName; } public void setDriverClassName(String driverClassName) { this.driverClassName = driverClassName; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return \"DataSourceProperties{\" + \"driverClassName='\" + driverClassName + '\\'' + \", url='\" + url + '\\'' + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; } } 3. 测试效果 在controller注入，输出进行测试 @Autowired private DataSourceProperties dataSourceProperties ; @RequestMapping(path = \"/hello\") public String sayHello() { System.out.println(dataSourceProperties); return \"Hello Spring Boot ! \" ; } 浏览器访问路径，控制台查看效果 ![](https://secure2.wostatic.cn/static/vCb6myPBNpMgVjF6nAXATV/image.png?auth_key=1741057745-8bpgaFERDaKT5PNB2iBP4v-0-e6b0b6f8f1ff6c742c35aaa4b6053b62)​ 2.3 YAML配置文件使用 1. yaml格式介绍 YAML（YAML Ain’t Markup Language）是一种基于层次结构的数据序列化格式，旨在提供一种易读、人类友好的数据表示方式。 与`.properties`​文件相比，YAML格式有以下优势： 1. 层次结构：YAML文件使用缩进和冒号来表示层次结构，使得数据之间的关系更加清晰和直观。这样可以更容易理解和维护复杂的配置，特别适用于深层次嵌套的配置情况。 2. 自我描述性：YAML文件具有自我描述性，字段和值之间使用冒号分隔，并使用缩进表示层级关系。这使得配置文件更易于阅读和理解，并且可以减少冗余的标点符号和引号。 3. 注释支持：YAML格式支持注释，可以在配置文件中添加说明性的注释，使配置更具可读性和可维护性。相比之下，`.properties`​文件不支持注释，无法提供类似的解释和说明。 4. 多行文本：YAML格式支持多行文本的表示，可以更方便地表示长文本或数据块。相比之下，`.properties`​文件需要使用转义符或将长文本拆分为多行。 5. 类型支持：YAML格式天然支持复杂的数据类型，如列表、映射等。这使得在配置文件中表示嵌套结构或数据集合更加容易，而不需要进行额外的解析或转换。 6. 更好的可读性：由于YAML格式的特点，它更容易被人类读懂和解释。它减少了配置文件中需要的特殊字符和语法，让配置更加清晰明了，从而减少了错误和歧义。 综上所述，YAML格式相对于`.properties`​文件具有更好的层次结构表示、自我描述性、注释支持、多行文本表示、复杂数据类型支持和更好的可读性。这些特点使YAML成为一种有力的配置文件格式，尤其适用于复杂的配置需求和人类可读的场景。然而，选择使用YAML还是`.properties`​取决于实际需求和团队的偏好，简单的配置可以使用`.properties`​，而复杂的配置可以选择YAML以获得更多的灵活性和可读性 2. yaml语法说明 1. 数据结构用树形结构呈现，通过缩进来表示层级， 2. 连续的项目（集合）通过减号 ” - ” 来表示 3. 键值结构里面的key/value对用冒号 ” : ” 来分隔。 4. YAML配置文件的扩展名是yaml 或 yml 5. 例如： # YAML配置文件示例 app_name: 我的应用程序 version: 1.0.0 author: 张三 database: host: localhost port: 5432 username: admin password: password123 features: - 登录 - 注册 - 仪表盘 settings: analytics: true theme: dark 3. 配置文件 spring: jdbc: datasource: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql:///springboot_02 username: root password: root server: port: 80 4. 读取配置文件 &gt; 读取方式和properties一致 package com.atguigu.properties; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component public class DataSourceProperties { @Value(\"${spring.jdbc.datasource.driverClassName}\") private String driverClassName; @Value(\"${spring.jdbc.datasource.url}\") private String url; @Value(\"${spring.jdbc.datasource.username}\") private String username; @Value(\"${spring.jdbc.datasource.password}\") private String password; // 生成get set 和 toString方法 public String getDriverClassName() { return driverClassName; } public void setDriverClassName(String driverClassName) { this.driverClassName = driverClassName; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return \"DataSourceProperties{\" + \"driverClassName='\" + driverClassName + '\\'' + \", url='\" + url + '\\'' + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; } } 5. 测试效果 在controller注入，输出进行测试 @Autowired private DataSourceProperties dataSourceProperties ; @RequestMapping(path = \"/hello\") public String sayHello() { System.out.println(dataSourceProperties); return \"Hello Spring Boot ! \" ; } 浏览器访问路径，控制台查看效果 ![](https://secure2.wostatic.cn/static/vCb6myPBNpMgVjF6nAXATV/image.png?auth_key=1741057744-hDKapNFiQPMqbJw2Fy7j81-0-cc836b2323dfec98ea35954588372f5a)​ 2.4 批量配置文件注入 &gt; **@ConfigurationProperties**是SpringBoot提供的重要注解, 他可以将一些配置属性批量注入到bean对象。 1. 创建类，添加属性和注解 在类上通过@ConfigurationProperties注解声明该类要读取属性配置 prefix=\"spring.jdbc.datasource\" 读取属性文件中前缀为spring.jdbc.datasource的值。前缀和属性名称和配置文件中的key必须要保持一致才可以注入成功 package com.atguigu.properties; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; @Component @ConfigurationProperties(prefix = \"spring.jdbc.datasource\") public class DataSourceConfigurationProperties { private String driverClassName; private String url; private String username; private String password; public String getDriverClassName() { return driverClassName; } public void setDriverClassName(String driverClassName) { this.driverClassName = driverClassName; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return \"DataSourceConfigurationProperties{\" + \"driverClassName='\" + driverClassName + '\\'' + \", url='\" + url + '\\'' + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; } } 2. 测试效果 @RestController public class HelloController { @Autowired private DataSourceProperties dataSourceProperties; @Autowired private DataSourceConfigurationProperties dataSourceConfigurationProperties; @GetMapping(\"/hello\") public String hello(){ System.out.println(\"dataSourceProperties = \" + dataSourceProperties); System.out.println(\"dataSourceConfigurationProperties = \" + dataSourceConfigurationProperties); return \"Hello,Spring Boot 3!\"; } } 浏览器访问路径，控制台查看效果 ![](https://secure2.wostatic.cn/static/vCb6myPBNpMgVjF6nAXATV/image.png?auth_key=1741057744-eHvc6ZQFNZARGdAaw2yDCk-0-d5e2d68835be09530be5cac9bd6c40e5)​ 2.5 多环境配置和使用 1. 需求 在Spring Boot中，可以使用多环境配置来根据不同的运行环境（如开发、测试、生产）加载不同的配置。SpringBoot支持多环境配置让应用程序在不同的环境中使用不同的配置参数，例如数据库连接信息、日志级别、缓存配置等。 以下是实现Spring Boot多环境配置的常见方法： 1. 属性文件分离：将应用程序的配置参数分离到不同的属性文件中，每个环境对应一个属性文件。例如，可以创建`application-dev.properties`​、`application-prod.properties`​和`application-test.properties`​等文件。在这些文件中，可以定义各自环境的配置参数，如数据库连接信息、端口号等。然后，在`application.properties`​中通过`spring.profiles.active`​属性指定当前使用的环境。Spring Boot会根据该属性来加载对应环境的属性文件，覆盖默认的配置。 2. YAML配置文件：与属性文件类似，可以将配置参数分离到不同的YAML文件中，每个环境对应一个文件。例如，可以创建`application-dev.yml`​、`application-prod.yml`​和`application-test.yml`​等文件。在这些文件中，可以使用YAML语法定义各自环境的配置参数。同样，通过`spring.profiles.active`​属性指定当前的环境，Spring Boot会加载相应的YAML文件。 3. 命令行参数(动态)：可以通过命令行参数来指定当前的环境。例如，可以使用`--spring.profiles.active=dev`​来指定使用开发环境的配置。 通过上述方法，Spring Boot会根据当前指定的环境来加载相应的配置文件或参数，从而实现多环境配置。这样可以简化在不同环境之间的配置切换，并且确保应用程序在不同环境中具有正确的配置。 2. 多环境配置（基于方式b实践） &gt; 创建开发、测试、生产三个环境的配置文件 application-dev.yml（开发） spring: jdbc: datasource: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///dev username: root password: root application-test.yml（测试） spring: jdbc: datasource: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///test username: root password: root application-prod.yml（生产） spring: jdbc: datasource: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///prod username: root password: root 3. 环境激活 spring: profiles: active: dev 4. 测试效果 ![](https://secure2.wostatic.cn/static/iE4SKEAYTwZ6Vay7HYUFAu/image.png?auth_key=1741057743-gzNGphCPDPRhtnJgHBperh-0-bff91fe587043b5743ce6a02bea625d0)​ **注意 :** 如果设置了spring.profiles.active，并且和application有重叠属性，以active设置优先。 如果设置了spring.profiles.active，和application无重叠属性，application设置依然生效！ 三、SpringBoot3整合SpringMVC 3.1 实现过程 1. 创建程序 2. 引入依赖 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;springboot-starter-springmvc-03&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- web开发的场景启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 3. 创建启动类 @SpringBootApplication public class MainApplication { public static void main(String[] args) { SpringApplication.run(MainApplication.class,args); } } 4. 创建实体类 package com.atguigu.pojo; public class User { private String username ; private String password ; private Integer age ; private String sex ; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } 5. 编写Controller package com.atguigu.controller; import com.atguigu.pojo.User; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; @Controller @RequestMapping(\"/user\") public class UserController { @GetMapping(\"/getUser\") @ResponseBody public User getUser(){ User user = new User(); user.setUsername(\"杨过\"); user.setPassword(\"123456\"); user.setAge(18); user.setSex(\"男\"); return user; } } 6. 访问测试 ![](https://secure2.wostatic.cn/static/eL6F4rj639fKpc7AZ4oDxS/image.png)​ 3.2 web相关配置 位置：application.yml # web相关的配置 # https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.server server: # 端口号设置 port: 80 # 项目根路径 servlet: context-path: /boot 当涉及Spring Boot的Web应用程序配置时，以下是五个重要的配置参数： 1. `server.port`​: 指定应用程序的HTTP服务器端口号。默认情况下，Spring Boot使用8080作为默认端口。您可以通过在配置文件中设置`server.port`​来更改端口号。 2. `server.servlet.context-path`​: 设置应用程序的上下文路径。这是应用程序在URL中的基本路径。默认情况下，上下文路径为空。您可以通过在配置文件中设置`server.servlet.context-path`​属性来指定自定义的上下文路径。 3. `spring.mvc.view.prefix`​和`spring.mvc.view.suffix`​: 这两个属性用于配置视图解析器的前缀和后缀。视图解析器用于解析控制器返回的视图名称，并将其映射到实际的视图页面。`spring.mvc.view.prefix`​定义视图的前缀，`spring.mvc.view.suffix`​定义视图的后缀。 4. `spring.resources.static-locations`​: 配置静态资源的位置。静态资源可以是CSS、JavaScript、图像等。默认情况下，Spring Boot会将静态资源放在`classpath:/static`​目录下。您可以通过在配置文件中设置`spring.resources.static-locations`​属性来自定义静态资源的位置。 5. `spring.http.encoding.charset`​和`spring.http.encoding.enabled`​: 这两个属性用于配置HTTP请求和响应的字符编码。`spring.http.encoding.charset`​定义字符编码的名称（例如UTF-8），`spring.http.encoding.enabled`​用于启用或禁用字符编码的自动配置。 这些是在Spring Boot的配置文件中与Web应用程序相关的一些重要配置参数。根据您的需求，您可以在配置文件中设置这些参数来定制和配置您的Web应用程序 3.3 静态资源处理 &gt; 在WEB开发中我们需要引入一些静态资源 , 例如 : HTML , CSS , JS , 图片等 , 如果是普通的项目静态资源可以放在项目的webapp目录下。现在使用Spring Boot做开发 , 项目中没有webapp目录 , 我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？ 1. 默认路径 在springboot中就定义了静态资源的默认查找路径： package org.springframework.boot.autoconfigure.web; //.................. public static class Resources { private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{\"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\"}; private String[] staticLocations; private boolean addMappings; private boolean customized; private final Chain chain; private final Cache cache; public Resources() { this.staticLocations = CLASSPATH_RESOURCE_LOCATIONS; this.addMappings = true; this.customized = false; this.chain = new Chain(); this.cache = new Cache(); } //........... **默认的静态资源路径为：** **· classpath:/META-INF/resources/** **· classpath:/resources/** **· classpath:/static/** **· classpath:/public/** 我们只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。 我们习惯会把静态资源放在classpath:/static/ 目录下。在resources目录下创建index.html文件 ![](https://secure2.wostatic.cn/static/whoDp3vndysPK89ybUfmJf/image.png?auth_key=1741057740-o3RXBKkCQv8JtDNacotGJ9-0-bbd4a45fd596ea4a8188d4b33656ed42)​ 打开浏览器输入 : [http://localhost:8080/index.html](http://localhost:8080/index.html) 2. 覆盖路径 # web相关的配置 # https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.server server: # 端口号设置 port: 80 # 项目根路径 servlet: context-path: /boot spring: web: resources: # 配置静态资源地址,如果设置,会覆盖默认值 static-locations: classpath:/webapp ![](https://secure2.wostatic.cn/static/iAmdM5vRon6g3VUanf5uEW/image.png?auth_key=1741057740-rBvzhV3pP7iRbh95e4jKia-0-bb0b71f0af0d91e9d0aeb62895b4e77b)​ 访问地址：[http://localhost/boot/login.html](http://localhost/boot/login.html) 3.4 自定义拦截器(SpringMVC配置) 1. 拦截器声明 package com.atguigu.interceptor; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import org.springframework.stereotype.Component; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; @Component public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"MyInterceptor拦截器的preHandle方法执行....\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"MyInterceptor拦截器的postHandle方法执行....\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"MyInterceptor拦截器的afterCompletion方法执行....\"); } } 2. 拦截器配置 正常使用配置类，只要保证，**配置类要在启动类的同包或者子包方可生效！** package com.atguigu.config; import com.atguigu.interceptor.MyInterceptor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class MvcConfig implements WebMvcConfigurer { @Autowired private MyInterceptor myInterceptor ; /** * /** 拦截当前目录及子目录下的所有路径 /user/** /user/findAll /user/order/findAll * /* 拦截当前目录下的以及子路径 /user/* /user/findAll * @param registry */ @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(myInterceptor).addPathPatterns(\"/**\"); } } 3. 拦截器效果测试 ![](https://secure2.wostatic.cn/static/heZ1qWvsGKs2yLmEEN7fz/image.png?auth_key=1741057739-n8LDzcD3Rqe9o8KxhMMdqE-0-7de56773c5ad84709e9b2392b5313c18)​ 四、SpringBoot3整合Druid数据源 1. 创建程序 2. 引入依赖 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;springboot-starter-druid-04&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- web开发的场景启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 数据库相关配置启动器 jdbctemplate 事务相关--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- druid启动器的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-3-starter&lt;/artifactId&gt; &lt;version&gt;1.2.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 驱动类--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.28&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- SpringBoot应用打包插件--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 3. 启动类 @SpringBootApplication public class MainApplication { public static void main(String[] args) { SpringApplication.run(MainApplication.class,args); } } 4. 配置文件编写 &gt; 添加druid连接池的基本配置 spring: datasource: # 连接池类型 type: com.alibaba.druid.pool.DruidDataSource # Druid的其他属性配置 springboot3整合情况下,数据库连接信息必须在Druid属性下! druid: url: jdbc:mysql://localhost:3306/day01 username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver # 初始化时建立物理连接的个数 initial-size: 5 # 连接池的最小空闲数量 min-idle: 5 # 连接池最大连接数量 max-active: 20 # 获取连接时最大等待时间，单位毫秒 max-wait: 60000 # 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 test-while-idle: true # 既作为检测的间隔时间又作为testWhileIdel执行的依据 time-between-eviction-runs-millis: 60000 # 销毁线程时检测当前连接的最后活动时间和当前时间差大于该值时，关闭当前连接(配置连接在池中的最小生存时间) min-evictable-idle-time-millis: 30000 # 用来检测数据库连接是否有效的sql 必须是一个查询语句(oracle中为 select 1 from dual) validation-query: select 1 # 申请连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true test-on-borrow: false # 归还连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true test-on-return: false # 是否缓存preparedStatement, 也就是PSCache,PSCache对支持游标的数据库性能提升巨大，比如说oracle,在mysql下建议关闭。 pool-prepared-statements: false # 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 max-pool-prepared-statement-per-connection-size: -1 # 合并多个DruidDataSource的监控数据 use-global-data-source-stat: true logging: level: root: debug 5. 编写Controller @Slf4j @Controller @RequestMapping(\"/user\") public class UserController { @Autowired private JdbcTemplate jdbcTemplate; @GetMapping(\"/getUser\") @ResponseBody public User getUser(){ String sql = \"select * from users where id = ? ; \"; User user = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(User.class), 1); log.info(\"查询的user数据为:{}\",user.toString()); return user; } } 6. 启动测试 7. 问题解决 通过源码分析，druid-spring-boot-3-starter目前最新版本是1.2.18，虽然适配了SpringBoot3，但缺少自动装配的配置文件，需要手动在resources目录下创建META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports，文件内容如下! com.alibaba.druid.spring.boot3.autoconfigure.DruidDataSourceAutoConfigure ![](https://secure2.wostatic.cn/static/emBrGSESbCgeAmKY6cjYtU/image.png?auth_key=1741057737-ekRjCihL4z2dpkNBPBRoJ2-0-a35f703e8af9102e99c6ee3aa8e2484d)​ 五、SpringBoot3整合Mybatis 5.1 MyBatis整合步骤 1. 导入依赖：在您的Spring Boot项目的构建文件（如pom.xml）中添加MyBatis和数据库驱动的相关依赖。例如，如果使用MySQL数据库，您需要添加MyBatis和MySQL驱动的依赖。 2. 配置数据源：在`application.properties`​或`application.yml`​中配置数据库连接信息，包括数据库URL、用户名、密码、mybatis的功能配置等。 3. 创建实体类：创建与数据库表对应的实体类。 4. 创建Mapper接口：创建与数据库表交互的Mapper接口。 5. 创建Mapper接口SQL实现： 可以使用mapperxml文件或者注解方式 6. 创建程序启动类 7. 注解扫描：在Spring Boot的主应用类上添加`@MapperScan`​注解，用于扫描和注册Mapper接口。 8. 使用Mapper接口：在需要使用数据库操作的地方，通过依赖注入或直接实例化Mapper接口，并调用其中的方法进行数据库操作。 5.2 Mybatis整合实践 1. 创建项目 2. 导入依赖 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库相关配置启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- druid启动器的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-3-starter&lt;/artifactId&gt; &lt;version&gt;1.2.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 驱动类--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.28&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3. 配置文件 server: port: 80 servlet: context-path: / spring: datasource: type: com.alibaba.druid.pool.DruidDataSource druid: url: jdbc:mysql:///day01 username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver mybatis: configuration: # setting配置 auto-mapping-behavior: full map-underscore-to-camel-case: true log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl type-aliases-package: com.atguigu.pojo # 配置别名 mapper-locations: classpath:/mapper/*.xml # mapperxml位置 4. 实体类准备 package com.atguigu.pojo; public class User { private String account ; private String password ; private Integer id ; public String getAccount() { return account; } public void setAccount(String account) { this.account = account; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } @Override public String toString() { return \"User{\" + \"account='\" + account + '\\'' + \", password='\" + password + '\\'' + \", id=\" + id + '}'; } } 5. Mapper接口准备 public interface UserMapper { List&lt;User&gt; queryAll(); } 6. Mapper接口实现（XML） 位置：resources/mapper/UserMapper.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"https://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!-- namespace = 接口的全限定符 --&gt; &lt;mapper namespace=\"com.atguigu.mapper.UserMapper\"&gt; &lt;select id=\"queryAll\" resultType=\"user\"&gt; select * from users &lt;/select&gt; &lt;/mapper&gt; 7. 编写三层架构代码 &gt; 伪代码，不添加业务接口！ 1. controller @Slf4j @Controller @RequestMapping(\"/user\") public class UserController { @Autowired private UserService userService; @GetMapping(\"/list\") @ResponseBody public List&lt;User&gt; getUser(){ List&lt;User&gt; userList = userService.findList(); log.info(\"查询的user数据为:{}\",userList); return userList; } } 2. service @Slf4j @Service public class UserService { @Autowired private UserMapper userMapper; public List&lt;User&gt; findList(){ List&lt;User&gt; users = userMapper.queryAll(); log.info(\"查询全部数据:{}\",users); return users; } } 8. 启动类和接口扫描 @MapperScan(\"com.atguigu.mapper\") //mapper接口扫描配置 @SpringBootApplication public class MainApplication { public static void main(String[] args) { SpringApplication.run(MainApplication.class,args); } } 9. 启动测试 5.3 声明式事务整合配置 依赖导入: &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; 注：SpringBoot项目会自动配置一个 DataSourceTransactionManager，所以我们只需在方法（或者类）加上 @Transactional 注解，就自动纳入 Spring 的事务管理了 @Transactional public void update(){ User user = new User(); user.setId(1); user.setPassword(\"test2\"); user.setAccount(\"test2\"); userMapper.update(user); } 5.4 AOP整合配置 依赖导入: &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; 直接使用aop注解即可: @Component @Aspect public class LogAdvice { @Before(\"execution(* com..service.*.*(..))\") public void before(JoinPoint joinPoint){ System.out.println(\"LogAdvice.before\"); System.out.println(\"joinPoint = \" + joinPoint); } } 六、SpringBoot3项目打包和运行 6.1 添加打包插件 &gt; 在Spring Boot项目中添加`spring-boot-maven-plugin`​插件是为了支持将项目打包成可执行的可运行jar包。如果不添加`spring-boot-maven-plugin`​插件配置，使用常规的`java -jar`​命令来运行打包后的Spring Boot项目是无法找到应用程序的入口点，因此导致无法运行。 &lt;!-- SpringBoot应用打包插件--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 6.2 执行打包 在idea点击package进行打包 可以在编译的target文件中查看jar包 ![](https://secure2.wostatic.cn/static/urL95X3WjtThkZFM3Hy8Ft/image.png?auth_key=1741057731-p98C63nZ7Bw5MVcN92Ge87-0-8d50b0077cb119c3b38d9eacf75160f9)​ 6.3 命令启动和参数说明 `java -jar`​命令用于在Java环境中执行可执行的JAR文件。下面是关于`java -jar`​命令的说明： 命令格式：java -jar [选项] [参数] &lt;jar文件名&gt; 1. `-D&lt;name&gt;=&lt;value&gt;`​：设置系统属性，可以通过`System.getProperty()`​方法在应用程序中获取该属性值。例如：`java -jar -Dserver.port=8080 myapp.jar`​。 2. `-X`​：设置JVM参数，例如内存大小、垃圾回收策略等。常用的选项包括： - `-Xmx&lt;size&gt;`​：设置JVM的最大堆内存大小，例如 `-Xmx512m`​ 表示设置最大堆内存为512MB。 - `-Xms&lt;size&gt;`​：设置JVM的初始堆内存大小，例如 `-Xms256m`​ 表示设置初始堆内存为256MB。 3. `-Dspring.profiles.active=&lt;profile&gt;`​：指定Spring Boot的激活配置文件，可以通过`application-&lt;profile&gt;.properties`​或`application-&lt;profile&gt;.yml`​文件来加载相应的配置。例如：`java -jar -Dspring.profiles.active=dev myapp.jar`​。 启动和测试： ![](https://secure2.wostatic.cn/static/66fP6WRTExeyyKpybyBx7B/image.png?auth_key=1741057730-iBjqHGG7cjjS9g8486kpGB-0-535d2626f8df6b1e24a75dfbce1df01f)​ 注意： -D 参数必须要在jar之前！否者不生效！ " }, { "title": "SpringMVC", "url": "/posts/springmvc/", "categories": "SpringMVC", "tags": "spring, vue, framework, javascript, java, mvc, maven", "date": "2025-01-01 10:44:29 +0800", "content": " SpringMVC SpringMVC 四、SpringMVC实战：构建高效表述层框架 一、SpringMVC简介和体验 1.1 介绍 ​Spring Web MVC :: Spring Frameworkdocs.spring.io Spring Web MVC是基于Servlet API构建的原始Web框架，从一开始就包含在Spring Framework中。正式名称“Spring Web MVC”来自其源模块的名称（ spring-webmvc ），但它通常被称为“Spring MVC”。 在控制层框架历经Strust、WebWork、Strust2等诸多产品的历代更迭之后，目前业界普遍选择了SpringMVC作为Java EE项目表述层开发的首选方案。之所以能做到这一点，是因为SpringMVC具备如下显著优势： Spring 家族原生产品，与IOC容器等基础设施无缝对接 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案 代码清新简洁，大幅度提升开发效率 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 性能卓著，尤其适合现代大型、超大型互联网项目要求 原生Servlet API开发代码片段 Java 复制 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String userName = request.getParameter(“userName”);System.out.println(“userName=”+userName);} 基于SpringMVC开发代码片段 Java 复制 @RequestMapping(“/user/login”)public String login(@RequestParam(“userName”) String userName,Sting password){log.debug(“userName=”+userName);//调用业务即可return “result”;} 1.2 主要作用 ​​ SSM框架构建起单体项目的技术栈需求！其中的SpringMVC负责表述层（控制层）实现简化！ SpringMVC的作用主要覆盖的是表述层，例如： 请求映射 数据输入 视图界面 请求分发 表单回显 会话控制 过滤拦截 异步交互 文件上传 文件下载 数据校验 类型转换 等等等 最终总结： 1 简化前端参数接收( 形参列表 ) 2 简化后端数据响应(返回值) 3 以及其他…… 1.3 核心组件和调用流程理解 Spring MVC与许多其他Web框架一样，是围绕前端控制器模式设计的，其中中央 Servlet DispatcherServlet 做整体请求处理调度！ 除了DispatcherServletSpringMVC还会提供其他特殊的组件协作完成请求处理和响应呈现。 SpringMVC处理请求流程： ​​ SpringMVC涉及组件理解： 1 DispatcherServlet : SpringMVC提供，我们需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发！[ CEO ] 2 HandlerMapping : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler！[秘书] 3 HandlerAdapter : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理响应数据数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，他是handler和DispatcherServlet之间的适配器！[经理] 4 Handler : handler又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，向后调用业务，最终返回响应结果！[打工人] 5 ViewResovler : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的！[财务] 1.4 快速体验 1 体验场景需求 ​​ 2 配置分析 a DispatcherServlet，设置处理所有请求！ b HandlerMapping,HandlerAdapter,Handler需要加入到IoC容器，供DS调用！ c Handler自己声明（Controller）需要配置到HandlerMapping中供DS查找！ 3 准备项目 a 创建项目 springmvc-base-quick 注意：需要转成maven/web程序！！ b 导入依赖 XML 复制 6.0.69.1.01717UTF-8 org.springframeworkspring-context${spring.version}jakarta.platformjakarta.jakartaee-web-api${servlet.api}providedorg.springframeworkspring-webmvc${spring.version} 4 Controller声明 Java 复制 @Controllerpublic class HelloController {//handlers/** * handler就是controller内部的具体方法 * @RequestMapping(“/springmvc/hello”) 就是用来向handlerMapping中注册的方法注解! * @ResponseBody 代表向浏览器直接返回数据! */@RequestMapping(“/springmvc/hello”)@ResponseBodypublic String hello(){System.out.println(“HelloController.hello”);return “hello springmvc!!”;}} 5 Spring MVC核心组件配置类 声明springmvc涉及组件信息的配置类 Java 复制 //TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]//TODO: 导入handlerMapping和handlerAdapter的三种方式//1.自动导入handlerMapping和handlerAdapter [推荐]//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载//3.使用@Bean方式配置handlerMapper和handlerAdapter@EnableWebMvc @Configuration@ComponentScan(basePackages = “com.atguigu.controller”) //TODO: 进行controller扫//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer {@Beanpublic HandlerMapping handlerMapping(){return new RequestMappingHandlerMapping();}@Beanpublic HandlerAdapter handlerAdapter(){return new RequestMappingHandlerAdapter();}} 6 SpringMVC环境搭建 对于使用基于 Java 的 Spring 配置的应用程序，建议这样做，如以下示例所示： Java 复制 //TODO: SpringMVC提供的接口,是替代web.xml的方案,更方便实现完全注解方式ssm处理!//TODO: Springmvc框架会自动检查当前类的实现类,会自动加载 getRootConfigClasses / getServletConfigClasses 提供的配置类//TODO: getServletMappings 返回的地址 设置DispatherServlet对应处理的地址public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {/** * 指定service / mapper层的配置类 /@Overrideprotected Class&lt;?&gt;[] getRootConfigClasses() {return null;}/** * 指定springmvc的配置类 * @return */@Overrideprotected Class&lt;?&gt;[] getServletConfigClasses() {return new Class&lt;?&gt;[] { SpringMvcConfig.class };}/ * * 设置dispatcherServlet的处理路径! * 一般情况下为 / 代表处理所有请求! */@Overrideprotected String[] getServletMappings() {return new String[] { “/” };}} 7 启动测试 注意： tomcat应该是10+版本！方可支持 Jakarta EE API! ​​ 二、SpringMVC接收数据 2.1 访问路径设置 @RequestMapping注解的作用就是将请求的 URL 地址和处理请求的方式（handler方法）关联起来，建立映射关系。 SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的方法来处理这个请求。 1 精准路径匹配 在@RequestMapping注解指定 URL 地址时，不使用任何通配符，按照请求地址进行精确匹配。 Java 复制 @Controllerpublic class UserController {/** * 精准设置访问地址 /user/login /@RequestMapping(value = {\"/user/login\"})@ResponseBodypublic String login(){System.out.println(\"UserController.login\");return \"login success!!\";}/ * * 精准设置访问地址 /user/register */@RequestMapping(value = {“/user/register”})@ResponseBodypublic String register(){System.out.println(“UserController.register”);return “register success!!”;}} 2 模糊路径匹配 在@RequestMapping注解指定 URL 地址时，通过使用通配符，匹配多个类似的地址。 Java 复制 @Controllerpublic class ProductController {/** * 路径设置为 /product/* * /* 为单层任意字符串 /product/a /product/aaa 可以访问此handler * /product/a/a 不可以 * 路径设置为 /product/** * /** 为任意层任意字符串 /product/a /product/aaa 可以访问此handler * /product/a/a 也可以访问 /@RequestMapping(\"/product/ “)@ResponseBodypublic String show(){System.out.println(“ProductController.show”);return “product show!”;}} 纯文本 复制 单层匹配和多层匹配： / ：只能匹配URL地址中的一层，如果想准确匹配两层，那么就写“/ /*”以此类推。 /**：可以匹配URL地址中的多层。 其中所谓的一层或多层是指一个URL地址字符串被“/”划分出来的各个层次 这个知识点虽然对于@RequestMapping注解来说实用性不大，但是将来配置拦截器的时候也遵循这个规则。 3 类和方法级别区别 @RequestMapping 注解可以用于类级别和方法级别，它们之间的区别如下： a 设置到类级别：@RequestMapping 注解可以设置在控制器类上，用于映射整个控制器的通用请求路径。这样，如果控制器中的多个方法都需要映射同一请求路径，就不需要在每个方法上都添加映射路径。 b 设置到方法级别：@RequestMapping 注解也可以单独设置在控制器方法上，用于更细粒度地映射请求路径和处理方法。当多个方法处理同一个路径的不同操作时，可以使用方法级别的 @RequestMapping 注解进行更精细的映射。 Java 复制 //1.标记到handler方法@RequestMapping(“/user/login”)@RequestMapping(“/user/register”)@RequestMapping(“/user/logout”)//2.优化标记类+handler方法//类上@RequestMapping(“/user”)//handler方法上@RequestMapping(“/login”)@RequestMapping(“/register”)@RequestMapping(“/logout”) 4 附带请求方式限制 HTTP 协议定义了八种请求方式，在 SpringMVC 中封装到了下面这个枚举类： Java 复制 public enum RequestMethod {GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE} 默认情况下：@RequestMapping(“/logout”) 任何请求方式都可以访问！ 如果需要特定指定： Java 复制 @Controllerpublic class UserController {/** * 精准设置访问地址 /user/login * method = RequestMethod.POST 可以指定单个或者多个请求方式! * 注意:违背请求方式会出现405异常! /@RequestMapping(value = {\"/user/login\"} , method = RequestMethod.POST)@ResponseBodypublic String login(){System.out.println(\"UserController.login\");return \"login success!!\";}/ * * 精准设置访问地址 /user/register */@RequestMapping(value = {“/user/register”},method = {RequestMethod.POST,RequestMethod.GET})@ResponseBodypublic String register(){System.out.println(“UserController.register”);return “register success!!”;}} 注意：违背请求方式，会出现405异常！！！ 5 进阶注解 还有 @RequestMapping 的 HTTP 方法特定快捷方式变体： @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping Java 复制 @RequestMapping(value=”/login”,method=RequestMethod.GET)   @GetMapping(value=”/login”) 注意：进阶注解只能添加到handler方法上，无法添加到类上！ 6 常见配置问题 出现原因：多个 handler 方法映射了同一个地址，导致 SpringMVC 在接收到这个地址的请求时该找哪个 handler 方法处理。 There is already ‘demo03MappingMethodHandler’ bean method com.atguigu.mvc.handler.Demo03MappingMethodHandler#empGet() mapped. 2.2 接收参数（重点） 2.2.1 param 和 json参数比较 在 HTTP 请求中，我们可以选择不同的参数类型，如 param 类型和 JSON 类型。下面对这两种参数类型进行区别和对比： 1 参数编码： param 类型的参数会被编码为 ASCII 码。例如，假设 name=john doe，则会被编码为 name=john%20doe。而 JSON 类型的参数会被编码为 UTF-8。 2 参数顺序： param 类型的参数没有顺序限制。但是，JSON 类型的参数是有序的。JSON 采用键值对的形式进行传递，其中键值对是有序排列的。 3 数据类型： param 类型的参数仅支持字符串类型、数值类型和布尔类型等简单数据类型。而 JSON 类型的参数则支持更复杂的数据类型，如数组、对象等。 4 嵌套性： param 类型的参数不支持嵌套。但是，JSON 类型的参数支持嵌套，可以传递更为复杂的数据结构。 5 可读性： param 类型的参数格式比 JSON 类型的参数更加简单、易读。但是，JSON 格式在传递嵌套数据结构时更加清晰易懂。 总的来说，param 类型的参数适用于单一的数据传递，而 JSON 类型的参数则更适用于更复杂的数据结构传递。根据具体的业务需求，需要选择合适的参数类型。在实际开发中，常见的做法是：在 GET 请求中采用 param 类型的参数，而在 POST 请求中采用 JSON 类型的参数传递。 2.2.2 param参数接收 1 直接接值 客户端请求 ​​ handler接收参数 只要形参数名和类型与传递参数相同，即可自动接收! Java 复制 @Controller@RequestMapping(“param”)public class ParamController {/** * 前端请求: http://localhost:8080/param/value?name=xx&amp;age=18 * * 可以利用形参列表,直接接收前端传递的param参数! * 要求: 参数名 = 形参名 * 类型相同 * 出现乱码正常，json接收具体解决！！ * @return 返回前端数据 */@GetMapping(value=”/value”)@ResponseBodypublic String setupForm(String name,int age){System.out.println(“name = “ + name + “, age = “ + age);return name + age;}} 2 @RequestParam注解 可以使用 @RequestParam 注释将 Servlet 请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。 @RequestParam使用场景： 指定绑定的请求参数名 要求请求参数必须传递 为请求参数提供默认值 基本用法： Java 复制 /** * 前端请求: http://localhost:8080/param/data?name=xx&amp;stuAge=18 * * 使用@RequestParam注解标记handler方法的形参 * 指定形参对应的请求参数@RequestParam(请求参数名称) */@GetMapping(value=”/data”)@ResponseBodypublic Object paramForm(@RequestParam(“name”) String name, @RequestParam(“stuAge”) int age){System.out.println(“name = “ + name + “, age = “ + age);return name+age;} 默认情况下，使用此批注的方法参数是必需的，但您可以通过将 @RequestParam 批注的 required 标志设置为 false！ 如果没有没有设置非必须，也没有传递参数会出现： ​​ 将参数设置非必须，并且设置默认值： Java 复制 @GetMapping(value=”/data”)@ResponseBodypublic Object paramForm(@RequestParam(“name”) String name, @RequestParam(value = “stuAge”,required = false,defaultValue = “18”) int age){System.out.println(“name = “ + name + “, age = “ + age);return name+age;} 3 特殊场景接值 a 一名多值 多选框，提交的数据的时候一个key对应多个值，我们可以使用集合进行接收！ Java 复制 /** * 前端请求: http://localhost:8080/param/mul?hbs=吃&amp;hbs=喝 * * 一名多值,可以使用集合接收即可!但是需要使用@RequestParam注解指定 */@GetMapping(value=”/mul”)@ResponseBodypublic Object mulForm(@RequestParam List hbs){System.out.println(\"hbs = \" + hbs);return hbs;} b 实体接收 Spring MVC 是 Spring 框架提供的 Web 框架，它允许开发者使用实体对象来接收 HTTP 请求中的参数。通过这种方式，可以在方法内部直接使用对象的属性来访问请求参数，而不需要每个参数都写一遍。下面是一个使用实体对象接收参数的示例： 定义一个用于接收参数的实体类： Java 复制 public class User {private String name;private int age = 18;// getter 和 setter 略} 在控制器中，使用实体对象接收，示例代码如下： Java 复制 @Controller@RequestMapping(“param”)public class ParamController {@RequestMapping(value = “/user”, method = RequestMethod.POST)@ResponseBodypublic String addUser(User user) {// 在这里可以使用 user 对象的属性来接收请求参数System.out.println(“user = “ + user);return “success”;}} 在上述代码中，将请求参数name和age映射到实体类属性上！要求属性名必须等于参数名！否则无法映射！ 使用postman传递参数测试： ​​ 2.2.3 路径 参数接收 路径传递参数是一种在 URL 路径中传递参数的方式。在 RESTful 的 Web 应用程序中，经常使用路径传递参数来表示资源的唯一标识符或更复杂的表示方式。而 Spring MVC 框架提供了 @PathVariable 注解来处理路径传递参数。 @PathVariable 注解允许将 URL 中的占位符映射到控制器方法中的参数。 例如，如果我们想将 /user/{id} 路径下的 {id} 映射到控制器方法的一个参数中，则可以使用 @PathVariable 注解来实现。 下面是一个使用 @PathVariable 注解处理路径传递参数的示例： Java 复制 /** * 动态路径设计: /user/{动态部分}/{动态部分} 动态部分使用{}包含即可! {}内部动态标识! * 形参列表取值: @PathVariable Long id 如果形参名 = {动态标识} 自动赋值! * @PathVariable(“动态标识”) Long id 如果形参名 != {动态标识} 可以通过指定动态标识赋值! * * 访问测试: /param/user/1/root -&gt; id = 1 uname = root */@GetMapping(“/user/{id}/{name}”)@ResponseBodypublic String getUser(@PathVariable Long id, @PathVariable(“name”) String uname) {System.out.println(“id = “ + id + “, uname = “ + uname);return “user_detail”;} 2.2.4 json参数接收 前端传递 JSON 数据时，Spring MVC 框架可以使用 @RequestBody 注解来将 JSON 数据转换为 Java 对象。@RequestBody 注解表示当前方法参数的值应该从请求体中获取，并且需要指定 value 属性来指示请求体应该映射到哪个参数上。其使用方式和示例代码如下： 1 前端发送 JSON 数据的示例：（使用postman测试） JSON 复制 {“name”: “张三”,”age”: 18,”gender”: “男”} 2 定义一个用于接收 JSON 数据的 Java 类，例如： Java 复制 public class Person {private String name;private int age;private String gender;// getter 和 setter 略} 3 在控制器中，使用 @RequestBody 注解来接收 JSON 数据，并将其转换为 Java 对象，例如： Java 复制 @PostMapping(“/person”)@ResponseBodypublic String addPerson(@RequestBody Person person) {// 在这里可以使用 person 对象来操作 JSON 数据中包含的属性return “success”;} 在上述代码中，@RequestBody 注解将请求体中的 JSON 数据映射到 Person 类型的 person 参数上，并将其作为一个对象来传递给 addPerson() 方法进行处理。 4 完善配置 测试： ​​ 问题： org.springframework.web.HttpMediaTypeNotSupportedException: Content-Type ‘application/json;charset=UTF-8’ is not supported] ​​ 原因： 不支持json数据类型处理 没有json类型处理的工具（jackson） 解决： springmvc handlerAdpater配置json转化器,配置类需要明确： Java 复制 //TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]//TODO: 导入handlerMapping和handlerAdapter的三种方式//1.自动导入handlerMapping和handlerAdapter [推荐]//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载//3.使用@Bean方式配置handlerMapper和handlerAdapter@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = “com.atguigu.controller”) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer {} pom.xml 加入jackson依赖 XML 复制 com.fasterxml.jackson.corejackson-databind2.15.0 5 @EnableWebMvc注解说明 @EnableWebMvc注解效果等同于在 XML 配置中，可以使用 mvc:annotation-driven 元素！我们来解析mvc:annotation-driven对应的解析工作！ 让我们来查看下mvc:annotation-driven具体的动作！ 先查看mvc:annotation-driven标签最终对应解析的Java类 ​​ 查看解析类中具体的动作即可 打开源码：org.springframework.web.servlet.config.MvcNamespaceHandler ​​ 打开源码：org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser Java 复制 class AnnotationDrivenBeanDefinitionParser implements BeanDefinitionParser {public static final String HANDLER_MAPPING_BEAN_NAME = RequestMappingHandlerMapping.class.getName();public static final String HANDLER_ADAPTER_BEAN_NAME = RequestMappingHandlerAdapter.class.getName();static {ClassLoader classLoader = AnnotationDrivenBeanDefinitionParser.class.getClassLoader();javaxValidationPresent = ClassUtils.isPresent(“jakarta.validation.Validator”, classLoader);romePresent = ClassUtils.isPresent(“com.rometools.rome.feed.WireFeed”, classLoader);jaxb2Present = ClassUtils.isPresent(“jakarta.xml.bind.Binder”, classLoader);jackson2Present = ClassUtils.isPresent(“com.fasterxml.jackson.databind.ObjectMapper”, classLoader) &amp;&amp;ClassUtils.isPresent(“com.fasterxml.jackson.core.JsonGenerator”, classLoader);jackson2XmlPresent = ClassUtils.isPresent(“com.fasterxml.jackson.dataformat.xml.XmlMapper”, classLoader);jackson2SmilePresent = ClassUtils.isPresent(“com.fasterxml.jackson.dataformat.smile.SmileFactory”, classLoader);jackson2CborPresent = ClassUtils.isPresent(“com.fasterxml.jackson.dataformat.cbor.CBORFactory”, classLoader);gsonPresent = ClassUtils.isPresent(“com.google.gson.Gson”, classLoader);}@Override@Nullablepublic BeanDefinition parse(Element element, ParserContext context) {//handlerMapping加入到ioc容器readerContext.getRegistry().registerBeanDefinition(HANDLER_MAPPING_BEAN_NAME, handlerMappingDef);//添加jackson转化器addRequestBodyAdvice(handlerAdapterDef);addResponseBodyAdvice(handlerAdapterDef);//handlerAdapter加入到ioc容器readerContext.getRegistry().registerBeanDefinition(HANDLER_ADAPTER_BEAN_NAME, handlerAdapterDef);return null;}//具体添加jackson转化对象方法protected void addRequestBodyAdvice(RootBeanDefinition beanDef) {if (jackson2Present) {beanDef.getPropertyValues().add(“requestBodyAdvice”,new RootBeanDefinition(JsonViewRequestBodyAdvice.class));}}protected void addResponseBodyAdvice(RootBeanDefinition beanDef) {if (jackson2Present) {beanDef.getPropertyValues().add(“responseBodyAdvice”,new RootBeanDefinition(JsonViewResponseBodyAdvice.class));}} 2.3 接收Cookie数据 可以使用 @CookieValue 注释将 HTTP Cookie 的值绑定到控制器中的方法参数。 考虑使用以下 cookie 的请求： Java 复制 JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84 下面的示例演示如何获取 cookie 值： Java 复制 @GetMapping(“/demo”)public void handle(@CookieValue(“JSESSIONID”) String cookie) { //…} 2.4 接收请求头数据 可以使用 @RequestHeader 批注将请求标头绑定到控制器中的方法参数。 请考虑以下带有标头的请求： Java 复制 Host localhost:8080Accept text/html,application/xhtml+xml,application/xml;q=0.9Accept-Language fr,en-gb;q=0.7,en;q=0.3Accept-Encoding gzip,deflateAccept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7Keep-Alive 300 下面的示例获取 Accept-Encoding 和 Keep-Alive 标头的值： Java 复制 @GetMapping(“/demo”)public void handle(@RequestHeader(“Accept-Encoding”) String encoding, @RequestHeader(“Keep-Alive”) long keepAlive) { //…} 2.5 原生Api对象操作 ​Method Arguments :: Spring Frameworkdocs.spring.io 下表描述了支持的控制器方法参数 Controller method argument 控制器方法参数 Description jakarta.servlet.ServletRequest,jakarta.servlet.ServletResponse 请求/响应对象 jakarta.servlet.http.HttpSession 强制存在会话。因此，这样的参数永远不会为null。 java.io.InputStream,java.io.Reader 用于访问由 Servlet API 公开的原始请求正文。 java.io.OutputStream,java.io.Writer 用于访问由 Servlet API 公开的原始响应正文。 @PathVariable 接收路径参数注解 @RequestParam 用于访问 Servlet 请求参数，包括多部分文件。参数值将转换为声明的方法参数类型。 @RequestHeader 用于访问请求标头。标头值将转换为声明的方法参数类型。 @CookieValue 用于访问Cookie。Cookie 值将转换为声明的方法参数类型。 @RequestBody 用于访问 HTTP 请求正文。正文内容通过使用HttpMessageConverter实现转换为声明的方法参数类型。 java.util.Map,org.springframework.ui.Model,org.springframework.ui.ModelMap 共享域对象，并在视图呈现过程中向模板公开。 Errors,BindingResult 验证和数据绑定中的错误信息获取对象！ 获取原生对象示例： Java 复制 /** * 如果想要获取请求或者响应对象,或者会话等,可以直接在形参列表传入,并且不分先后顺序! * 注意: 接收原生对象,并不影响参数接收! */@GetMapping(“api”)@ResponseBodypublic String api(HttpSession session , HttpServletRequest request,HttpServletResponse response){String method = request.getMethod();System.out.println(“method = “ + method);return “api”;} 2.6 共享域对象操作 三、SpringMVC响应数据 3.1 handler方法分析 理解handler方法的作用和组成： Java 复制 /** * TODO: 一个controller的方法是控制层的一个处理器,我们称为handler * TODO: handler需要使用@RequestMapping/@GetMapping系列,声明路径,在HandlerMapping中注册,供DS查找! * TODO: handler作用总结: * 1.接收请求参数(param,json,pathVariable,共享域等) * 2.调用业务逻辑 * 3.响应前端数据(页面（不讲解模版页面跳转）,json,转发和重定向等) * TODO: handler如何处理呢 * 1.接收参数: handler(形参列表: 主要的作用就是用来接收参数) * 2.调用业务: { 方法体 可以向后调用业务方法 service.xx() } * 3.响应数据: return 返回结果,可以快速响应前端数据 */@GetMappingpublic Object handler(简化请求参数接收){调用业务方法 返回的结果 （页面跳转，返回数据（json））return 简化响应前端数据;} 总结： 请求数据接收，我们都是通过handler的形参列表 前端数据响应，我们都是通过handler的return关键字快速处理！ springmvc简化了参数接收和响应！ 3.2 页面跳转控制 3.2.1 快速返回模板视图 1 开发模式回顾 在 Web 开发中，有两种主要的开发模式：前后端分离和混合开发。 前后端分离模式：[重点] 指将前端的界面和后端的业务逻辑通过接口分离开发的一种方式。开发人员使用不同的技术栈和框架，前端开发人员主要负责页面的呈现和用户交互，后端开发人员主要负责业务逻辑和数据存储。前后端通信通过 API 接口完成，数据格式一般使用 JSON 或 XML。前后端分离模式可以提高开发效率，同时也有助于代码重用和维护。 混合开发模式： 指将前端和后端的代码集成在同一个项目中，共享相同的技术栈和框架。这种模式在小型项目中比较常见，可以减少学习成本和部署难度。但是，在大型项目中，这种模式会导致代码耦合性很高，维护和升级难度较大。 对于混合开发，我们就需要使用动态页面技术，动态展示Java的共享域数据！！ 2 jsp技术了解 JSP（JavaServer Pages）是一种动态网页开发技术，它是由 Sun 公司提出的一种基于 Java 技术的 Web 页面制作技术，可以在 HTML 文件中嵌入 Java 代码，使得生成动态内容的编写更加简单。 JSP 最主要的作用是生成动态页面。它允许将 Java 代码嵌入到 HTML 页面中，以便使用 Java 进行数据库查询、处理表单数据和生成 HTML 等动态内容。另外，JSP 还可以与 Servlet 结合使用，实现更加复杂的 Web 应用程序开发。 JSP 的主要特点包括： a 简单：JSP 通过将 Java 代码嵌入到 HTML 页面中，使得生成动态内容的编写更加简单。 b 高效：JSP 首次运行时会被转换为 Servlet，然后编译为字节码，从而可以启用 Just-in-Time（JIT）编译器，实现更高效的运行。 c 多样化：JSP 支持多种标准标签库，包括 JSTL（JavaServer Pages 标准标签库）、EL（表达式语言）等，可以帮助开发人员更加方便的处理常见的 Web 开发需求。 总之，JSP 是一种简单高效、多样化的动态网页开发技术，它可以方便地生成动态页面和与 Servlet 结合使用，是 Java Web 开发中常用的技术之一。 3 准备jsp页面和依赖 pom.xml依赖 XML 复制 jakarta.servlet.jsp.jstljakarta.servlet.jsp.jstl-api3.0.0 jsp页面创建 建议位置：/WEB-INF/下，避免外部直接访问！ 位置：/WEB-INF/views/home.jsp Java 复制 &lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;&lt;html&gt;&lt;head&gt;Title&lt;/head&gt;&lt;body&gt;${msg}&lt;/body&gt;&lt;/html&gt; 4 快速响应模版页面 a 配置jsp视图解析器 Java 复制 @EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = “com.atguigu.controller”) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer {//配置jsp对应的视图解析器@Overridepublic void configureViewResolvers(ViewResolverRegistry registry) {//快速配置jsp模板语言对应的registry.jsp(“/WEB-INF/views/”,”.jsp”);}} b handler返回视图 Java 复制 /** * 跳转到提交文件页面 /save/jump * * 如果要返回jsp页面! * 1.方法返回值改成字符串类型 * 2.返回逻辑视图名即可 * * + 逻辑视图名 + * */@GetMapping(“jump”)public String jumpJsp(Model model){System.out.println(“FileController.jumpJsp”);model.addAttribute(“msg”,”request data!!”);return “home”;} 3.2.2 转发和重定向 在 Spring MVC 中，Handler 方法返回值来实现快速转发，可以使用 redirect 或者 forward 关键字来实现重定向。 Java 复制 @RequestMapping(“/redirect-demo”)public String redirectDemo() {// 重定向到 /demo 路径 return “redirect:/demo”;}@RequestMapping(“/forward-demo”)public String forwardDemo() {// 转发到 /demo 路径return “forward:/demo”;}//注意： 转发和重定向到项目下资源路径都是相同，都不需要添加项目根路径！填写项目下路径即可！ 总结： 将方法的返回值，设置String类型 转发使用forward关键字，重定向使用redirect关键字 关键字: /路径 注意：如果是项目下的资源，转发和重定向都一样都是项目下路径！都不需要添加项目根路径！ 3.3 返回JSON数据（重点） 3.3.1 前置准备 3.3.2 @ResponseBody 1 方法上使用@ResponseBody 可以在方法上使用 @ResponseBody注解，用于将方法返回的对象序列化为 JSON 或 XML 格式的数据，并发送给客户端。在前后端分离的项目中使用！ 测试方法： Java 复制 @GetMapping(“/accounts/{id}”)@ResponseBodypublic Object handle() {// …return obj;} 具体来说，@ResponseBody 注解可以用来标识方法或者方法返回值，表示方法的返回值是要直接返回给客户端的数据，而不是由视图解析器来解析并渲染生成响应体（viewResolver没用）。 测试方法： Java 复制 @RequestMapping(value = “/user/detail”, method = RequestMethod.POST)@ResponseBodypublic User getUser(@RequestBody User userParam) {System.out.println(“userParam = “ + userParam);User user = new User();user.setAge(18);user.setName(“John”);//返回的对象,会使用jackson的序列化工具,转成json返回给前端!return user;} 返回结果： ​​ 2 类上使用@ResponseBody 如果类中每个方法上都标记了 @ResponseBody 注解，那么这些注解就可以提取到类上。 Java 复制 @ResponseBody //responseBody可以添加到类上,代表默认类中的所有方法都生效!@Controller@RequestMapping(“param”)public class ParamController { 3.3.3 @RestController 类上的 @ResponseBody 注解可以和 @Controller 注解合并为 @RestController 注解。所以使用了 @RestController 注解就相当于给类中的每个方法都加了 @ResponseBody 注解。 RestController源码: Java 复制 @Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Controller@ResponseBodypublic @interface RestController {/** * The value may indicate a suggestion for a logical component name, * to be turned into a Spring bean in case of an autodetected component. * @return the suggested component name, if any (or empty String otherwise) * @since 4.0.1 */@AliasFor(annotation = Controller.class)String value() default “”;} 3.4 返回静态资源处理 1 静态资源概念 资源本身已经是可以直接拿到浏览器上使用的程度了，不需要在服务器端做任何运算、处理。典型的静态资源包括： 纯HTML文件 图片 CSS文件 JavaScript文件 …… 2 静态资源访问和问题解决 web应用加入静态资源 ​​ 手动构建确保编译 ​​ ​​ ​​ 访问静态资源 ​​ 问题分析 DispatcherServlet 的 url-pattern 配置的是“/” url-pattern 配置“/”表示整个 Web 应用范围内所有请求都由 SpringMVC 来处理 对 SpringMVC 来说，必须有对应的 @RequestMapping 才能找到处理请求的方法 现在 images/mi.jpg 请求没有对应的 @RequestMapping 所以返回 404 问题解决 在 SpringMVC 配置配置类： Java 复制 @EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = “com.atguigu.controller”) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer {//配置jsp对应的视图解析器@Overridepublic void configureViewResolvers(ViewResolverRegistry registry) {//快速配置jsp模板语言对应的registry.jsp(“/WEB-INF/views/”,”.jsp”);}//开启静态资源处理 mvc:default-servlet-handler/@Overridepublic void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {configurer.enable();}} 再次测试访问图片： ​​ 新的问题：其他原本正常的handler请求访问不了了 handler无法访问 解决方案： XML 复制 @EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器 四、RESTFul风格设计和实战 4.1 RESTFul风格概述 4.1.1 RESTFul风格简介 4.1.2 RESTFul风格特点 4.1.3 RESTFul风格设计规范 4.1.4 RESTFul风格好处 4.2 RESTFul风格实战 五、SpringMVC其他扩展 5.1 全局异常处理机制 5.2 拦截器使用 5.3 参数校验 六、SpringMVC总结 核心点 掌握目标 springmvc框架 主要作用、核心组件、调用流程 简化参数接收 路径设计、参数接收、请求头接收、cookie接收 简化数据响应 模板页面、转发和重定向、JSON数据、静态资源 restful风格设计 主要作用、具体规范、请求方式和请求参数选择 功能扩展 全局异常处理、拦截器、参数校验注解 标题目录 一、SpringMVC简介和体验 1.1 介绍 1.2 主要作用 1.3 核心组件和调用流程理解 1.4 快速体验 二、SpringMVC接收数据 2.1 访问路径设置 2.2 接收参数（重点） 2.2.1 param 和 json参数比较 2.2.2 param参数接收 2.2.3 路径 参数接收 2.2.4 json参数接收 2.3 接收Cookie数据 2.4 接收请求头数据 2.5 原生Api对象操作 2.6 共享域对象操作 2.6.1 属性（共享）域作用回顾 2.6.2 Request级别属性（共享）域 2.6.3 Session级别属性（共享）域 2.6.4 Application级别属性（共享）域 三、SpringMVC响应数据 3.1 handler方法分析 3.2 页面跳转控制 3.2.1 快速返回模板视图 3.2.2 转发和重定向 3.3 返回JSON数据（重点） 3.3.1 前置准备 3.3.2 @ResponseBody 3.3.3 @RestController 3.4 返回静态资源处理 四、RESTFul风格设计和实战 4.1 RESTFul风格概述 4.1.1 RESTFul风格简介 4.1.2 RESTFul风格特点 4.1.3 RESTFul风格设计规范 4.1.4 RESTFul风格好处 4.2 RESTFul风格实战 4.2.1 需求分析 4.2.2 RESTFul风格接口设计 4.2.3 后台接口实现 五、SpringMVC其他扩展 5.1 全局异常处理机制 5.1.1 异常处理两种方式 5.1.2 基于注解异常声明异常处理 5.2 拦截器使用 5.2.1 拦截器概念 5.2.2 拦截器使用 5.3 参数校验 六、SpringMVC总结 本页内容由用户通过 wolai 发布，并不代表 wolai 立场，如有违规侵权，请投诉/举报 或提交 侵权通知 ​Ctrl+M 解释 " }, { "title": "Spring FrameWork", "url": "/posts/spring-framework/", "categories": "Spring FrameWork", "tags": "spring, sql, framework, database, git, mybatis, java, mvc, maven, boot", "date": "2024-11-17 10:44:29 +0800", "content": " Spring FrameWork 一、技术体系结构 1.1 总体技术体系 1.2 框架概念和理解 二、SpringFramework介绍 2.1 Spring 和 SpringFramework概念 2.2 SpringFramework主要功能模块 2.3 SpringFramework 主要优势 三、Spring IoC容器和核心概念 3.1 组件和组件管理概念 3.2 Spring IoC容器和容器实现 3.3 Spring IoC / DI概念总结 四、Spring IoC实践和应用 4.1 Spring IoC / DI 实现步骤 4.2 基于XML配置方式组件管理 4.3 基于 注解 方式管理 Bean 4.4 基于 配置类 方式管理 Bean 4.5 三种配置方式总结 4.6 整合Spring5-Test5搭建测试环境 五、Spring AOP面向切面编程 5.1 场景设定和问题复现 5.2 解决技术代理模式 5.3 面向切面编程思维（AOP） 5.4 Spring AOP框架介绍和关系梳理 5.5 Spring AOP基于注解方式实现和细节 5.6 Spring AOP基于XML方式实现(了解) 5.7 Spring AOP对获取Bean的影响理解 六、Spring 声明式事务 6.1 声明式事务概念 6.2 基于注解的声明式事务 七、Spring核心掌握总结 Spring FrameWork 一、技术体系结构 1.1 总体技术体系 - 单一架构 一个项目，一个工程，导出为一个war包，在一个Tomcat上运行。也叫all in one。 ![](https://secure2.wostatic.cn/static/bnm9zUQo34z7FgXA9vAmfm/image.png?auth_key=1741057312-eU7yN2SoSUrBJhbkCXjLmV-0-47971bb92efb02183939134af5084edc)​ 单一架构，项目主要应用技术框架为：Spring , SpringMVC , Mybatis - 分布式架构 一个项目（对应 IDEA 中的一个 project），拆分成很多个模块，每个模块是一个 IDEA 中的一个 module。每一个工程都是运行在自己的 Tomcat 上。模块之间可以互相调用。每一个模块内部可以看成是一个单一架构的应用。 ![](https://secure2.wostatic.cn/static/9NxDdZATsg76FfXNgskTFE/image.png?auth_key=1741057312-wXnm6hqeb3fCom82xtcG34-0-540d6a0a385d55c564efe60effa90a67)​ 分布式架构，项目主要应用技术框架：SpringBoot (SSM), SpringCloud , 中间件等 1.2 框架概念和理解 框架( Framework )是一个集成了基本结构、规范、设计模式、编程语言和程序库等基础组件的软件系统，它可以用来构建更高级别的应用程序。框架的设计和实现旨在解决特定领域中的常见问题，帮助开发人员更高效、更稳定地实现软件开发目标。 ![](https://secure2.wostatic.cn/static/wVRd8tTgKZYHJi3DGoWEpk/image.png?auth_key=1741057310-noQmCintKDCxiB4gATPSZ2-0-2af387a2f93e8e7ba9df9c2ec12be6d4)​ 框架的优点包括以下几点： 1. 提高开发效率：框架提供了许多预先设计好了的组件和工具，能够帮助开发人员快速进行开发。相较于传统手写代码，在框架提供的规范化环境中，开发者可以更快地实现项目的各种要求。 2. 降低开发成本：框架的提供标准化的编程语言、数据操作等代码片段，避免了重复开发的问题，降低了开发成本，提供深度优化的系统，降低了维护成本，增强了系统的可靠性。 3. 提高应用程序的稳定性：框架通常经过了很长时间的开发和测试，其中的许多组件、代码片段和设计模式都得到了验证。重复利用这些组件有助于减少bug的出现，从而提高了应用程序的稳定性。 4. 提供标准化的解决方案：框架通常是针对某个特定领域的，通过提供标准化的解决方案，可以为开发人员提供一种共同的语言和思想基础，有助于更好地沟通和协作。 框架的缺点包括以下几个方面： 1. 学习成本高：框架通常具有特定的语言和编程范式。对于开发人员而言，需要花费时间学习其背后的架构、模式和逻辑，这对于新手而言可能会耗费较长时间。 2. 可能存在局限性：虽然框架提高了开发效率并可以帮助开发人员解决常见问题，但是在某些情况下，特定的应用需求可能超出框架的范围，从而导致应用程序无法满足要求。开发人员可能需要更多的控制权和自由度，同时需要在框架和应用程序之间进行权衡取舍。 3. 版本变更和兼容性问题：框架的版本发布和迭代通常会导致代码库的大规模变更，进而导致应用程序出现兼容性问题和漏洞。当框架变更时，需要考虑框架是否向下兼容，以及如何进行适当的测试、迁移和升级。 4. 架构风险：框架涉及到很多抽象和概念，如果开发者没有足够的理解和掌握其架构，可能会导致系统出现设计和架构缺陷，从而影响系统的健康性和安全性。 站在文件结构的角度理解框架，可以将框架总结：**框架 = jar包+配置文件** ![](https://secure2.wostatic.cn/static/mVVMygbUkcQx9Loxs21XdC/image.png?auth_key=1741057310-cdZXrp7hWF2GaxqzG4f26C-0-a1030a434454e68c5ebd13fb76192ede)​ 莎士比亚说,\"一千个观众眼中有一千个哈姆雷特\" 即仁者见仁,智者见智.说每个人都会对作品有不同的理解，每个人对待任何事物都有自己的看法，同样的技术解决同样的问题会产生不同流程和风格的解决方案，而采用一种框架其实就是限制用户必须使用其规定的方案来实现，可以降低程序员之间沟通以及日后维护的成本！ 常用的单一架构JavaEE项目框架演进，从SSH、SSH2过渡到了SSM：SpringMVC、Spring、MyBatis。 总之，框架已经对基础的代码进行了封装并提供相应的API，开发者在使用框架是直接调用封装好的API可以省去很多代码编写，从而提高工作效率和开发速度。 二、SpringFramework介绍 2.1 Spring 和 SpringFramework概念 https://spring.io/projects **广义的 Spring：Spring 技术栈**（全家桶） 广义上的 Spring 泛指以 Spring Framework 为基础的 Spring 技术栈。 经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。 这些子项目涵盖了从企业级应用开发到云计算等各方面的内容，能够帮助开发人员解决软件发展过程中不断产生的各种实际问题，给开发人员带来了更好的开发体验。 **狭义的 Spring：Spring Framework**（基础框架） 狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring 框架。 Spring Framework（Spring框架）是一个开源的应用程序框架，由SpringSource公司开发，最初是为了解决企业级开发中各种常见问题而创建的。它提供了很多功能，例如：依赖注入（Dependency Injection）、面向切面编程（AOP）、声明式事务管理（TX）等。其主要目标是使企业级应用程序的开发变得更加简单和快速，并且Spring框架被广泛应用于Java企业开发领域。 Spring全家桶的其他框架都是以SpringFramework框架为基础！ **对比理解：** QQ 和 腾讯 腾讯 = Spring QQ = SpringFramework 2.2 SpringFramework主要功能模块 SpringFramework框架结构图： ![](https://secure-bigfile.wostatic.cn/static/5D6E8yWCFE2pUa3koBp4ra/image.png?auth_key=1741057304-7JhhfceMbJqYqiTEFvvmuB-0-516acad8ad0c98c15aeadc3ae8b3377b)​ 功能模块 功能介绍 Core Container 核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器。 AOP&amp;Aspects 面向切面编程 TX 声明式事务管理。 Spring MVC 提供了面向Web应用程序的集成功能。 2.3 SpringFramework 主要优势 1. 丰富的生态系统：Spring 生态系统非常丰富，支持许多模块和库，如 Spring Boot、Spring Security、Spring Cloud 等等，可以帮助开发人员快速构建高可靠性的企业应用程序。 2. 模块化的设计：框架组件之间的松散耦合和模块化设计使得 Spring Framework 具有良好的可重用性、可扩展性和可维护性。开发人员可以轻松地选择自己需要的模块，根据自己的需求进行开发。 3. 简化 Java 开发：Spring Framework 简化了 Java 开发，提供了各种工具和 API，可以降低开发复杂度和学习成本。同时，Spring Framework 支持各种应用场景，包括 Web 应用程序、RESTful API、消息传递、批处理等等。 4. 不断创新和发展：Spring Framework 开发团队一直在不断创新和发展，保持与最新技术的接轨，为开发人员提供更加先进和优秀的工具和框架。 因此，这些优点使得 Spring Framework 成为了一个稳定、可靠、且创新的框架，为企业级 Java 开发提供了一站式的解决方案。 Spring 使创建 Java 企业应用程序变得容易。它提供了在企业环境中采用 Java 语言所需的一切，支持 Groovy 和 Kotlin 作为 JVM 上的替代语言，并且可以根据应用程序的需求灵活地创建多种架构。从Spring Framework 6.0.6开始，Spring 需要 Java 17+。 三、Spring IoC容器和核心概念 3.1 组件和组件管理概念 - **3.1.1 什么是组件?** 回顾常规的三层架构处理请求流程： ![](https://secure2.wostatic.cn/static/i5cYp4uqLG3mVEKEv2qofF/image.png)​ 整个项目就是由各种组件搭建而成的： ![](https://secure2.wostatic.cn/static/8LSuy5YWXmufYmPWM894rN/image.png)​ - **3.1.2 我们的期待** - 有人替我们创建组件的对象 - 有人帮我们保存组件的对象 - 有人帮助我们自动组装 - 有人替我们管理事务 - 有人协助我们整合其他框架 - ...... - **3.1.3 Spring充当组件管理角色（IoC）** 那么谁帮我们完成我们的期待，帮我们管理组件呢？ 当然是Spring 框架了！ 组件可以完全交给Spring 框架进行管理，Spring框架替代了程序员原有的new对象和对象属性赋值动作等！ Spring具体的组件管理动作包含： - 组件对象实例化 - 组件属性属性赋值 - 组件对象之间引用 - 组件对象存活周期管理 - ...... 我们只需要编写元数据（配置文件）告知Spring 管理哪些类组件和他们的关系即可！ 注意：组件是映射到应用程序中所有可重用组件的Java对象，应该是可复用的功能对象！ - 组件一定是对象 - 对象不一定是组件 综上所述，Spring 充当一个组件容器，创建、管理、存储组件，减少了我们的编码压力，让我们更加专注进行业务编写！ - **3.1.4 组件交给Spring管理优势**! 1. 降低了组件之间的耦合性：Spring IoC容器通过依赖注入机制，将组件之间的依赖关系削弱，减少了程序组件之间的耦合性，使得组件更加松散地耦合。 2. 提高了代码的可重用性和可维护性：将组件的实例化过程、依赖关系的管理等功能交给Spring IoC容器处理，使得组件代码更加模块化、可重用、更易于维护。 3. 方便了配置和管理：Spring IoC容器通过XML文件或者注解，轻松的对组件进行配置和管理，使得组件的切换、替换等操作更加的方便和快捷。 4. 交给Spring管理的对象（组件），方可享受Spring框架的其他功能（AOP,声明事务管理）等 3.2 Spring IoC容器和容器实现 - **3.2.1 普通和复杂容器** **普通容器** 生活中的普通容器 ![](https://secure2.wostatic.cn/static/t65AXJYvxmQdZB9qcKKy2H/img002.png?auth_key=1741057299-sfZKx8fbnMkLgT8Kz4yovY-0-816df66763790d6347343cb9f521bddc)​ &gt; 普通容器只能用来存储，没有更多功能。 程序中的普通容器 - 数组 - 集合：List - 集合：Set **复杂容器** 生活中的复杂容器 ![](https://secure2.wostatic.cn/static/9DRSuBo1GprKVtd5Gu2GqU/img003.png?auth_key=1741057299-exUUeT1f7nZjzXXjoUui67-0-58896d606d41305e20528fdb2e18620c)​ &gt; 政府管理我们的一生，生老病死都和政府有关。 程序中的复杂容器 Servlet 容器能够管理 Servlet(init,service,destroy)、Filter、Listener 这样的组件的一生，所以它是一个复杂容器。 名称 时机 次数 创建对象 默认情况：接收到第一次请求 修改启动顺序后：Web应用启动过程中 一次 初始化操作 创建对象之后 一次 处理请求 接收到请求 多次 销毁操作 Web应用卸载之前 一次 我们即将要学习的 SpringIoC 容器也是一个复杂容器。它们不仅要负责创建组件的对象、存储组件的对象，还要负责调用组件的方法让它们工作，最终在特定情况下销毁组件。 总结：Spring管理组件的容器，就是一个复杂容器，不仅存储组件，也可以管理组件之间依赖关系，并且创建和销毁组件等！ - **3.2.2 SpringIoC容器介绍** Spring IoC 容器，负责实例化、配置和组装 bean（组件）。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。配置元数据以 XML、Java 注解或 Java 代码形式表现。它允许表达组成应用程序的组件以及这些组件之间丰富的相互依赖关系。 ![](https://secure2.wostatic.cn/static/mFt9PQ2ggCqB193CC57AKi/image.png?auth_key=1741057297-nJMBoRE7xUnjGQYxdes42N-0-e2c62959e5f70d30114b450f69bb251b)​ 上图显示了 Spring 容器工作原理的高级视图。应用程序类与配置元数据相结合，您拥有完全配置且可执行的系统或应用程序。 - **3.2.3 SpringIoC容器具体接口和实现类** **SpringIoc容器接口**： `BeanFactory`​ 接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！ `ApplicationContext`​ 是 `BeanFactory`​ 的子接口。它扩展了以下功能： - 更容易与 Spring 的 AOP 功能集成 - 消息资源处理（用于国际化） - 特定于应用程序给予此接口实现，例如Web 应用程序的 `WebApplicationContext`​ 简而言之， `BeanFactory`​ 提供了配置框架和基本功能，而 `ApplicationContext`​ 添加了更多特定于企业的功能。 `ApplicationContext`​ 是 `BeanFactory`​ 的完整超集！ **ApplicationContext容器实现类**： 类型名 简介 ClassPathXmlApplicationContext 通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象 FileSystemXmlApplicationContext 通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象 AnnotationConfigApplicationContext 通过读取Java配置类创建 IOC 容器对象 WebApplicationContext 专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。 - **3.2.4 SpringIoC容器管理配置方式** Spring IoC 容器使用多种形式的配置元数据。此配置元数据表示您作为应用程序开发人员如何告诉 Spring 容器实例化、配置和组装应用程序中的对象。 ![](https://secure2.wostatic.cn/static/mFt9PQ2ggCqB193CC57AKi/image.png?auth_key=1741057294-2cqNtZeXNHTEbrj7bxuxuE-0-b1811233da7d7a0cade150f05db99865)​ Spring框架提供了多种配置方式：XML配置方式、注解方式和Java配置类方式 1. XML配置方式：是Spring框架最早的配置方式之一，通过在XML文件中定义Bean及其依赖关系、Bean的作用域等信息，让Spring IoC容器来管理Bean之间的依赖关系。该方式从Spring框架的第一版开始提供支持。 2. 注解方式：从Spring 2.5版本开始提供支持，可以通过在Bean类上使用注解来代替XML配置文件中的配置信息。通过在Bean类上加上相应的注解（如@Component, @Service, @Autowired等），将Bean注册到Spring IoC容器中，这样Spring IoC容器就可以管理这些Bean之间的依赖关系。 3. **Java配置类**方式：从Spring 3.0版本开始提供支持，通过Java类来定义Bean、Bean之间的依赖关系和配置信息，从而代替XML配置文件的方式。Java配置类是一种使用Java编写配置信息的方式，通过@Configuration、@Bean等注解来实现Bean和依赖关系的配置。 为了迎合当下开发环境，我们将以**配置类+注解方式**为主进行讲解！ 3.3 Spring IoC / DI概念总结 - **IoC容器** Spring IoC 容器，负责实例化、配置和组装 bean（组件）核心容器。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。 - **IoC（Inversion of Control）控制反转** IoC 主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序直接创建该对象，而是由 IoC 容器来创建和管理，即控制权由应用程序转移到 IoC 容器中，也就是“反转”了控制权。这种方式基本上是通过依赖查找的方式来实现的，即 IoC 容器维护着构成应用程序的对象，并负责创建这些对象。 - **DI (Dependency Injection) 依赖注入** DI 是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在 Spring 中，DI 是通过 XML 配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter 方法注入和接口注入。 四、Spring IoC实践和应用 4.1 Spring IoC / DI 实现步骤 &gt; 我们总结下，组件交给Spring IoC容器管理，并且获取和使用的基本步骤！ 1. **配置元数据（配置）** 配置元数据，既是编写交给SpringIoC容器管理组件的信息，配置方式有三种。 基于 XML 的配置元数据的基本结构： &lt;bean id=\"...\" [1] class=\"...\" [2]&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!-- 此处要添加一些约束，配置文件的标签并不是随意命名 --&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"...\" [1] class=\"...\" [2]&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id=\"...\" class=\"...\"&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions go here --&gt; &lt;/beans&gt; Spring IoC 容器管理一个或多个组件。这些 组件是使用你提供给容器的配置元数据（例如，以 XML `&lt;bean/&gt;`​ 定义的形式）创建的。 &lt;bean /&gt; 标签 == 组件信息声明 - `id`​ 属性是标识单个 Bean 定义的字符串。 - `class`​ 属性定义 Bean 的类型并使用完全限定的类名。 2. **实例化IoC容器** 提供给 `ApplicationContext`​ 构造函数的位置路径是资源字符串地址，允许容器从各种外部资源（如本地文件系统、Java `CLASSPATH`​ 等）加载配置元数据。 我们应该选择一个合适的容器实现类，进行IoC容器的实例化工作： //实例化ioc容器,读取外部配置文件,最终会在容器内进行ioc和di动作 ApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\"); 3. **获取Bean（组件）** `ApplicationContext`​ 是一个高级工厂的接口，能够维护不同 bean 及其依赖项的注册表。通过使用方法 `T getBean(String name, Class&lt;T&gt; requiredType)`​ ，您可以检索 bean 的实例。 允许读取 Bean 定义并访问它们，如以下示例所示： //创建ioc容器对象，指定配置文件，ioc也开始实例组件对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\"); //获取ioc容器的组件对象 PetStoreService service = context.getBean(\"petStore\", PetStoreService.class); //使用组件对象 List&lt;String&gt; userList = service.getUsernameList(); 4.2 基于XML配置方式组件管理 #### 4.2.1 实验一： 组件（Bean）信息声明配置（IoC） 1. 目标 Spring IoC 容器管理一个或多个 bean。这些 Bean 是使用您提供给容器的配置元数据创建的（例如，以 XML `&lt;bean/&gt;`​ 定义的形式）。 我们学习，如何通过定义XML配置文件，声明组件类信息，交给 Spring 的 IoC 容器进行组件管理！ 2. 思路 ![](https://secure2.wostatic.cn/static/rMxd5wJzZ4WaVCyCt5Tazm/img006.png?auth_key=1741057282-7RmhTn2FJqcLqz1zUqgpFd-0-9e2a82e9ff947ebce2c5a1728af8cd98) 3. 准备项目 1. 创建maven工程（spring-ioc-xml-01） 2. 导入SpringIoC相关依赖 pom.xml &lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 4. 基于无参数构造函数 &gt; 当通过构造函数方法创建一个 bean（组件对象） 时，所有普通类都可以由 Spring 使用并与之兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。只需指定 Bean 类信息就足够了。但是，默认情况下，我们需要一个默认（空）构造函数。 1. 准备组件类 package com.atguigu.ioc; public class HappyComponent { //默认包含无参数构造函数 public void doWork() { System.out.println(\"HappyComponent.doWork\"); } } 2. xml配置文件编写 创建携带spring约束的xml配置文件 ![](https://secure2.wostatic.cn/static/7eC1WeTyXz1oLaGkPfJBfh/image.png?auth_key=1741057282-izoT5pzboCTWf6HU8RwPHh-0-6db50097f19d15a4c9d2f6f16d03ebc6)​ 编写配置文件： 文件：resources/spring-bean-01.xml &lt;!-- 实验一 [重要]创建bean --&gt; &lt;bean id=\"happyComponent\" class=\"com.atguigu.ioc.HappyComponent\"/&gt; - bean标签：通过配置bean标签告诉IOC容器需要创建对象的组件信息 - id属性：bean的唯一标识,方便后期获取Bean！ - class属性：组件类的全限定符！ - 注意：要求当前组件类必须包含无参数构造函数！ 5. 基于静态工厂方法实例化 &gt; 除了使用构造函数实例化对象，还有一类是通过工厂模式实例化对象。接下来我们讲解如何定义使用静态工厂方法创建Bean的配置 ！ 1. 准备组件类 public class ClientService { private static ClientService clientService = new ClientService(); private ClientService() {} public static ClientService createInstance() { return clientService; } } 2. xml配置文件编写 文件：resources/spring-bean-01.xml &lt;bean id=\"clientService\" class=\"examples.ClientService\" factory-method=\"createInstance\"/&gt; - class属性：指定工厂类的全限定符！ - factory-method: 指定静态工厂方法，注意，该方法必须是static方法。 6. 基于实例工厂方法实例化 &gt; 接下来我们讲解下如何定义使用实例工厂方法创建Bean的配置 ！ 1. 准备组建类 public class DefaultServiceLocator { private static ClientServiceImplclientService = new ClientServiceImpl(); public ClientService createClientServiceInstance() { return clientService; } } 2. xml配置文件编写 文件：resources/spring-bean-01.xml &lt;!-- 将工厂类进行ioc配置 --&gt; &lt;bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\"&gt; &lt;/bean&gt; &lt;!-- 根据工厂对象的实例工厂方法进行实例化组件对象 --&gt; &lt;bean id=\"clientService\" factory-bean=\"serviceLocator\" factory-method=\"createClientServiceInstance\"/&gt; - factory-bean属性：指定当前容器中工厂Bean 的名称。 - factory-method: 指定实例工厂方法名。注意，实例方法必须是非static的！ 7. 图解IoC配置流程 ![](https://secure2.wostatic.cn/static/mpqqiD6Bmbno45SpRwBNom/image.png?auth_key=1741057282-dBao28DaXjRVuAHPxJrCjf-0-4d3867c4c6abf84423cc3016ee6e9f10)​ #### 4.2.2 实验二： 组件（Bean）依赖注入配置（DI） 1. 目标 通过配置文件,实现IoC容器中Bean之间的引用（依赖注入DI配置）。 主要涉及注入场景：基于构造函数的依赖注入和基于 Setter 的依赖注入。 2. 思路 ![](https://secure2.wostatic.cn/static/opfLAb8XnCZDyPMm9BuiMc/image.png?auth_key=1741057282-3Wg4AauZ6LvsDEQ3tbiDTx-0-b25ddea82404fe003499bd5d488add95) 3. 基于构造函数的依赖注入（单个构造参数） 1. 介绍 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。 下面的示例演示一个只能通过构造函数注入进行依赖项注入的类！ 2. 准备组件类 public class UserDao { } public class UserService { private UserDao userDao; public UserService(UserDao userDao) { this.userDao = userDao; } } 3. 编写配置文件 文件：resources/spring-02.xml &lt;beans&gt; &lt;!-- 引用类bean声明 --&gt; &lt;bean id=\"userService\" class=\"x.y.UserService\"&gt; &lt;!-- 构造函数引用 --&gt; &lt;constructor-arg ref=\"userDao\"/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=\"userDao\" class=\"x.y.UserDao\"/&gt; &lt;/beans&gt; - constructor-arg标签：可以引用构造参数 ref引用其他bean的标识。 4. 基于构造函数的依赖注入（多构造参数解析） 1. 介绍 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。 下面的示例演示通过构造函数注入多个参数，参数包含其他bean和基本数据类型！ 2. 准备组件类 public class UserDao { } public class UserService { private UserDao userDao; private int age; private String name; public UserService(int age , String name ,UserDao userDao) { this.userDao = userDao; this.age = age; this.name = name; } } 3. 编写配置文件 &lt;!-- 场景1: 多参数，可以按照相应构造函数的顺序注入数据 --&gt; &lt;beans&gt; &lt;bean id=\"userService\" class=\"x.y.UserService\"&gt; &lt;!-- value直接注入基本类型值 --&gt; &lt;constructor-arg value=\"18\"/&gt; &lt;constructor-arg value=\"赵伟风\"/&gt; &lt;constructor-arg ref=\"userDao\"/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=\"userDao\" class=\"x.y.UserDao\"/&gt; &lt;/beans&gt; &lt;!-- 场景2: 多参数，可以按照相应构造函数的名称注入数据 --&gt; &lt;beans&gt; &lt;bean id=\"userService\" class=\"x.y.UserService\"&gt; &lt;!-- value直接注入基本类型值 --&gt; &lt;constructor-arg name=\"name\" value=\"赵伟风\"/&gt; &lt;constructor-arg name=\"userDao\" ref=\"userDao\"/&gt; &lt;constructor-arg name=\"age\" value=\"18\"/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=\"userDao\" class=\"x.y.UserDao\"/&gt; &lt;/beans&gt; &lt;!-- 场景2: 多参数，可以按照相应构造函数的角标注入数据 index从0开始 构造函数(0,1,2....) --&gt; &lt;beans&gt; &lt;bean id=\"userService\" class=\"x.y.UserService\"&gt; &lt;!-- value直接注入基本类型值 --&gt; &lt;constructor-arg index=\"1\" value=\"赵伟风\"/&gt; &lt;constructor-arg index=\"2\" ref=\"userDao\"/&gt; &lt;constructor-arg index=\"0\" value=\"18\"/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=\"userDao\" class=\"x.y.UserDao\"/&gt; &lt;/beans&gt; - constructor-arg标签：指定构造参数和对应的值 - constructor-arg标签：name属性指定参数名、index属性指定参数角标、value属性指定普通属性值 5. **基于Setter方法依赖注入** 1. 介绍 开发中，除了构造函数注入（DI）更多的使用的Setter方法进行注入！ 下面的示例演示一个只能使用纯 setter 注入进行依赖项注入的类。 2. 准备组件类 public Class MovieFinder{ } public class SimpleMovieLister { private MovieFinder movieFinder; private String movieName; public void setMovieFinder(MovieFinder movieFinder) { this.movieFinder = movieFinder; } public void setMovieName(String movieName){ this.movieName = movieName; } // business logic that actually uses the injected MovieFinder is omitted... } 3. 编写配置文件 &lt;bean id=\"simpleMovieLister\" class=\"examples.SimpleMovieLister\"&gt; &lt;!-- setter方法，注入movieFinder对象的标识id name = 属性名 ref = 引用bean的id值 --&gt; &lt;property name=\"movieFinder\" ref=\"movieFinder\" /&gt; &lt;!-- setter方法，注入基本数据类型movieName name = 属性名 value= 基本类型值 --&gt; &lt;property name=\"movieName\" value=\"消失的她\"/&gt; &lt;/bean&gt; &lt;bean id=\"movieFinder\" class=\"examples.MovieFinder\"/&gt; - property标签： 可以给setter方法对应的属性赋值 - property 标签： name属性代表**set方法标识**、ref代表引用bean的标识id、value属性代表基本属性值 **总结：** 依赖注入（DI）包含引用类型和基本数据类型，同时注入的方式也有多种！主流的注入方式为setter方法注入和构造函数注入，两种注入语法都需要掌握！ 需要特别注意：引用其他bean，使用ref属性。直接注入基本类型值，使用value属性。 #### 4.2.3 实验三： IoC容器创建和使用 1. 介绍 上面的实验只是讲解了如何在XML格式的配置文件编写IoC和DI配置！ 如图： ![](https://secure2.wostatic.cn/static/ngQZT7qhVfAzTxrr2oX1ny/image.png?auth_key=1741057282-k6D7WCnby2rimW2zKKvdgM-0-11afba5f78f437cf0bf62ddb16889ed3)​ 想要配置文件中声明组件类信息真正的进行实例化成Bean对象和形成Bean之间的引用关系，我们需要声明IoC容器对象，读取配置文件，实例化组件和关系维护的过程都是在IoC容器中实现的！ 2. 容器实例化 //方式1:实例化并且指定配置文件 //参数：String...locations 传入一个或者多个配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\"); //方式2:先实例化，再指定配置文件，最后刷新容器触发Bean实例化动作 [springmvc源码和contextLoadListener源码方式] ApplicationContext context = new ClassPathXmlApplicationContext(); //设置配置配置文件,方法参数为可变参数,可以设置一个或者多个配置 iocContainer1.setConfigLocations(\"services.xml\", \"daos.xml\"); //后配置的文件,需要调用refresh方法,触发刷新配置 iocContainer1.refresh(); 3. Bean对象读取 //方式1: 根据id获取 //没有指定类型,返回为Object,需要类型转化! HappyComponent happyComponent = (HappyComponent) iocContainer.getBean(\"bean的id标识\"); //使用组件对象 happyComponent.doWork(); //方式2: 根据类型获取 //根据类型获取,但是要求,同类型(当前类,或者之类,或者接口的实现类)只能有一个对象交给IoC容器管理 //配置两个或者以上出现: org.springframework.beans.factory.NoUniqueBeanDefinitionException 问题 HappyComponent happyComponent = iocContainer.getBean(HappyComponent.class); happyComponent.doWork(); //方式3: 根据id和类型获取 HappyComponent happyComponent = iocContainer.getBean(\"bean的id标识\", HappyComponent.class); happyComponent.doWork(); 根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类型』的返回结果， 只要返回的是true就可以认定为和类型匹配，能够获取到。 #### 4.2.4 实验四： 高级特性：组件（Bean）作用域和周期方法配置 1. 组件周期方法配置 1. 周期方法概念 我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！ 类似于Servlet的init/destroy方法,我们可以在周期方法完成初始化和释放资源等工作。 2. 周期方法声明 public class BeanOne { //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表 public void init() { // 初始化逻辑 } } public class BeanTwo { public void cleanup() { // 释放资源逻辑 } } 3. 周期方法配置 &lt;beans&gt; &lt;bean id=\"beanOne\" class=\"examples.BeanOne\" init-method=\"init\" /&gt; &lt;bean id=\"beanTwo\" class=\"examples.BeanTwo\" destroy-method=\"cleanup\" /&gt; &lt;/beans&gt; 2. 组件作用域配置 1. Bean作用域概念 `&lt;bean`​ 标签声明Bean，只是将Bean的信息配置给SpringIoC容器！ 在IoC容器中，这些`&lt;bean`​标签对应的信息转成Spring内部 `BeanDefinition`​ 对象，`BeanDefinition`​ 对象内，包含定义的信息（id,class,属性等等）！ 这意味着，`BeanDefinition`​与`类`​概念一样，SpringIoC容器可以可以根据`BeanDefinition`​对象反射创建多个Bean对象实例。 具体创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！ 2. 作用域可选值 取值 含义 创建对象的时机 默认值 singleton 在 IOC 容器中，这个 bean 的对象始终为单实例 IOC 容器初始化时 是 prototype 这个 bean 在 IOC 容器中有多个实例 获取 bean 时 否 如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）： 取值 含义 创建对象的时机 默认值 request 请求范围内有效的实例 每次请求 否 session 会话范围内有效的实例 每次会话 否 3. 作用域配置 配置scope范围 &lt;!--bean的作用域 准备两个引用关系的组件类即可！！ --&gt; &lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt; &lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt; &lt;bean id=\"happyMachine8\" scope=\"prototype\" class=\"com.atguigu.ioc.HappyMachine\"&gt; &lt;property name=\"machineName\" value=\"happyMachine\"/&gt; &lt;/bean&gt; &lt;bean id=\"happyComponent8\" scope=\"singleton\" class=\"com.atguigu.ioc.HappyComponent\"&gt; &lt;property name=\"componentName\" value=\"happyComponent\"/&gt; &lt;/bean&gt; 4. 作用域测试 @Test public void testExperiment08() { ApplicationContext iocContainer = new ClassPathXmlApplicationContext(\"配置文件名\"); HappyMachine bean = iocContainer.getBean(HappyMachine.class); HappyMachine bean1 = iocContainer.getBean(HappyMachine.class); //多例对比 false System.out.println(bean == bean1); HappyComponent bean2 = iocContainer.getBean(HappyComponent.class); HappyComponent bean3 = iocContainer.getBean(HappyComponent.class); //单例对比 true System.out.println(bean2 == bean3); } #### 4.2.5 实验五： 高级特性：FactoryBean特性和使用 1. FactoryBean简介 `FactoryBean`​ 接口是Spring IoC容器实例化逻辑的可插拔性点。 用于配置复杂的Bean对象，可以将创建过程存储在`FactoryBean`​ 的getObject方法！ `FactoryBean&lt;T&gt;`​ 接口提供三种方法： - `T getObject()`​: 返回此工厂创建的对象的实例。该返回值会被存储到IoC容器！ - `boolean isSingleton()`​: 如果此 `FactoryBean`​ 返回单例，则返回 `true`​ ，否则返回 `false`​ 。此方法的默认实现返回 `true`​ （注意，lombok插件使用，可能影响效果）。 - `Class&lt;?&gt; getObjectType()`​: 返回 `getObject()`​ 方法返回的对象类型，如果事先不知道类型，则返回 `null`​ 。 ![](https://secure2.wostatic.cn/static/5yNzfRW9TqkASMuJafu6Pa/image.png?auth_key=1741057282-tn4gy52j8oMW63pzsxgfDK-0-e309899d11f3ebb677c0252f10e8c6e6) 2. FactoryBean使用场景 1. 代理类的创建 2. 第三方框架整合 3. 复杂对象实例化等 3. Factorybean应用 1. 准备FactoryBean实现类 // 实现FactoryBean接口时需要指定泛型 // 泛型类型就是当前工厂要生产的对象的类型 public class HappyFactoryBean implements FactoryBean&lt;HappyMachine&gt; { private String machineName; public String getMachineName() { return machineName; } public void setMachineName(String machineName) { this.machineName = machineName; } @Override public HappyMachine getObject() throws Exception { // 方法内部模拟创建、设置一个对象的复杂过程 HappyMachine happyMachine = new HappyMachine(); happyMachine.setMachineName(this.machineName); return happyMachine; } @Override public Class&lt;?&gt; getObjectType() { // 返回要生产的对象的类型 return HappyMachine.class; } } 2. 配置FactoryBean实现类 &lt;!-- FactoryBean机制 --&gt; &lt;!-- 这个bean标签中class属性指定的是HappyFactoryBean，但是将来从这里获取的bean是HappyMachine对象 --&gt; &lt;bean id=\"happyMachine7\" class=\"com.atguigu.ioc.HappyFactoryBean\"&gt; &lt;!-- property标签仍然可以用来通过setXxx()方法给属性赋值 --&gt; &lt;property name=\"machineName\" value=\"iceCreamMachine\"/&gt; &lt;/bean&gt; 3. 测试读取FactoryBean和FactoryBean.getObject对象 @Test public void testExperiment07() { ApplicationContext iocContainer = new ClassPathXmlApplicationContext(\"spring-bean-07.xml\"); //注意: 直接根据声明FactoryBean的id,获取的是getObject方法返回的对象 HappyMachine happyMachine = iocContainer.getBean(\"happyMachine7\",HappyMachine.class); System.out.println(\"happyMachine = \" + happyMachine); //如果想要获取FactoryBean对象, 直接在id前添加&amp;符号即可! &amp;happyMachine7 这是一种固定的约束 Object bean = iocContainer.getBean(\"&amp;happyMachine7\"); System.out.println(\"bean = \" + bean); } 4. FactoryBean和BeanFactory区别 **FactoryBean **是 Spring 中一种特殊的 bean，可以在 getObject() 工厂方法自定义的逻辑创建Bean！是一种能够生产其他 Bean 的 Bean。FactoryBean 在容器启动时被创建，而在实际使用时则是通过调用 getObject() 方法来得到其所生产的 Bean。因此，FactoryBean 可以自定义任何所需的初始化逻辑，生产出一些定制化的 bean。 一般情况下，整合第三方框架，都是通过定义FactoryBean实现！！！ **BeanFactory** 是 Spring 框架的基础，其作为一个顶级接口定义了容器的基本行为，例如管理 bean 的生命周期、配置文件的加载和解析、bean 的装配和依赖注入等。BeanFactory 接口提供了访问 bean 的方式，例如 getBean() 方法获取指定的 bean 实例。它可以从不同的来源（例如 Mysql 数据库、XML 文件、Java 配置类等）获取 bean 定义，并将其转换为 bean 实例。同时，BeanFactory 还包含很多子类（例如，ApplicationContext 接口）提供了额外的强大功能。 总的来说，FactoryBean 和 BeanFactory 的区别主要在于前者是用于创建 bean 的接口，它提供了更加灵活的初始化定制功能，而后者是用于管理 bean 的框架基础接口，提供了基本的容器功能和 bean 生命周期管理。 #### 4.2.6 实验六： 基于XML方式整合三层架构组件 1. 需求分析 搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用XML方式进行组件管理！ ![](https://secure2.wostatic.cn/static/dMe3en4EMVQ5JEi3PVDjae/image.png?auth_key=1741057282-rzHgiGBbPVhVcB92oiEp2f-0-029f6ba25e0c87b39d1d7dd4d79f0b5f) 2. 数据库准备 create database studb; use studb; CREATE TABLE students ( id INT PRIMARY KEY, name VARCHAR(50) NOT NULL, gender VARCHAR(10) NOT NULL, age INT, class VARCHAR(50) ); INSERT INTO students (id, name, gender, age, class) VALUES (1, '张三', '男', 20, '高中一班'), (2, '李四', '男', 19, '高中二班'), (3, '王五', '女', 18, '高中一班'), (4, '赵六', '女', 20, '高中三班'), (5, '刘七', '男', 19, '高中二班'), (6, '陈八', '女', 18, '高中一班'), (7, '杨九', '男', 20, '高中三班'), (8, '吴十', '男', 19, '高中二班'); 3. 项目准备 1. 项目创建 spring-xml-practice-02 2. 依赖导入 &lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入SpringContext依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库驱动和连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3. 实体类准备 public class Student { private Integer id; private String name; private String gender; private Integer age; private String classes; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getClasses() { return classes; } public void setClasses(String classes) { this.classes = classes; } @Override public String toString() { return \"Student{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", gender='\" + gender + '\\'' + \", age=\" + age + \", classes='\" + classes + '\\'' + '}'; } } 4. JdbcTemplate技术讲解 &gt; 为了在特定领域帮助我们简化代码，Spring 封装了很多 『Template』形式的模板类。例如：RedisTemplate、RestTemplate 等等，包括我们今天要学习的 JdbcTemplate。 jdbc.properties 提取数据库连接信息 atguigu.url=jdbc:mysql://localhost:3306/studb atguigu.driver=com.mysql.cj.jdbc.Driver atguigu.username=root atguigu.password=root springioc配置文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 导入外部属性文件 --&gt; &lt;context:property-placeholder location=\"classpath:jdbc.properties\" /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"url\" value=\"${atguigu.url}\"/&gt; &lt;property name=\"driverClassName\" value=\"${atguigu.driver}\"/&gt; &lt;property name=\"username\" value=\"${atguigu.username}\"/&gt; &lt;property name=\"password\" value=\"${atguigu.password}\"/&gt; &lt;/bean&gt; &lt;!-- 配置 JdbcTemplate --&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;!-- 装配数据源 --&gt; &lt;property name=\"dataSource\" ref=\"druidDataSource\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 基于jdbcTemplate的CRUD使用 public class JdbcTemplateTest { /** * 使用jdbcTemplate进行DML动作 */ @Test public void testDML(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-ioc.xml\"); JdbcTemplate jdbcTemplate = applicationContext.getBean(JdbcTemplate.class); //TODO 执行插入一条学员数据 String sql = \"insert into students (id,name,gender,age,class) values (?,?,?,?,?);\"; /* 参数1: sql语句 参数2: 可变参数,占位符的值 */ int rows = jdbcTemplate.update(sql, 9,\"十一\", \"男\", 18, \"二年三班\"); System.out.println(\"rows = \" + rows); } /** * 查询单条实体对象 * public class Student { * private Integer id; * private String name; * private String gender; * private Integer age; * private String classes; */ @Test public void testDQLForPojo(){ String sql = \"select id , name , age , gender , class as classes from students where id = ? ;\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-ioc.xml\"); JdbcTemplate jdbcTemplate = applicationContext.getBean(JdbcTemplate.class); //根据id查询 Student student = jdbcTemplate.queryForObject(sql, (rs, rowNum) -&gt; { //自己处理结果映射 Student stu = new Student(); stu.setId(rs.getInt(\"id\")); stu.setName(rs.getString(\"name\")); stu.setAge(rs.getInt(\"age\")); stu.setGender(rs.getString(\"gender\")); stu.setClasses(rs.getString(\"classes\")); return stu; }, 2); System.out.println(\"student = \" + student); } /** * 查询实体类集合 */ @Test public void testDQLForListPojo(){ String sql = \"select id , name , age , gender , class as classes from students ;\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-ioc.xml\"); JdbcTemplate jdbcTemplate = applicationContext.getBean(JdbcTemplate.class); /* query可以返回集合! BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可 */ List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class)); System.out.println(\"studentList = \" + studentList); } } 5. 三层架构搭建和实现 1. 持久层 //接口 public interface StudentDao { /** * 查询全部学生数据 * @return */ List&lt;Student&gt; queryAll(); } //实现类 public class StudentDaoImpl implements StudentDao { private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } /** * 查询全部学生数据 * @return */ @Override public List&lt;Student&gt; queryAll() { String sql = \"select id , name , age , gender , class as classes from students ;\"; /* query可以返回集合! BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可 */ List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class)); return studentList; } } 2. 业务层 //接口 public interface StudentService { /** * 查询全部学员业务 * @return */ List&lt;Student&gt; findAll(); } //实现类 public class StudentServiceImpl implements StudentService { private StudentDao studentDao; public void setStudentDao(StudentDao studentDao) { this.studentDao = studentDao; } /** * 查询全部学员业务 * @return */ @Override public List&lt;Student&gt; findAll() { List&lt;Student&gt; studentList = studentDao.queryAll(); return studentList; } } 3. 表述层 public class StudentController { private StudentService studentService; public void setStudentService(StudentService studentService) { this.studentService = studentService; } public void findAll(){ List&lt;Student&gt; studentList = studentService.findAll(); System.out.println(\"studentList = \" + studentList); } } 6. 三层架构IoC配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 导入外部属性文件 --&gt; &lt;context:property-placeholder location=\"classpath:jdbc.properties\" /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"url\" value=\"${atguigu.url}\"/&gt; &lt;property name=\"driverClassName\" value=\"${atguigu.driver}\"/&gt; &lt;property name=\"username\" value=\"${atguigu.username}\"/&gt; &lt;property name=\"password\" value=\"${atguigu.password}\"/&gt; &lt;/bean&gt; &lt;!-- 配置 JdbcTemplate --&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;!-- 装配数据源 --&gt; &lt;property name=\"dataSource\" ref=\"druidDataSource\"/&gt; &lt;/bean&gt; &lt;bean id=\"studentDao\" class=\"com.atguigu.dao.impl.StudentDaoImpl\"&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\" /&gt; &lt;/bean&gt; &lt;bean id=\"studentService\" class=\"com.atguigu.service.impl.StudentServiceImpl\"&gt; &lt;property name=\"studentDao\" ref=\"studentDao\" /&gt; &lt;/bean&gt; &lt;bean id=\"studentController\" class=\"com.atguigu.controller.StudentController\"&gt; &lt;property name=\"studentService\" ref=\"studentService\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 7. 运行测试 public class ControllerTest { @Test public void testRun(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-ioc.xml\"); StudentController studentController = applicationContext.getBean(StudentController.class); studentController.findAll(); } } 8. XMLIoC方式问题总结 1. 注入的属性必须添加setter方法、代码结构乱！ 2. 配置文件和Java代码分离、编写不是很方便！ 3. XML配置文件解析效率低 4.3 基于 注解 方式管理 Bean #### 4.3.1 实验一： Bean注解标记和扫描 (IoC) 1. **注解理解** 和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。 本质上：所有一切的操作都是 Java 代码来完成的，XML 和注解只是告诉框架中的 Java 代码如何执行。 举例：元旦联欢会要布置教室，蓝色的地方贴上元旦快乐四个字，红色的地方贴上拉花，黄色的地方贴上气球。 ![](https://secure2.wostatic.cn/static/4TWRR4uNZ7eas63Ag9fTJS/img015.png?auth_key=1741057274-aNW1jat7VfH6SG2yZjUSfm-0-fa932a70184c4a47e3d4d383f9db4c6b)​ 班长做了所有标记，同学们来完成具体工作。墙上的标记相当于我们在代码中使用的注解，后面同学们做的工作，相当于框架的具体操作。 2. **扫描理解** Spring 为了知道程序员在哪些地方标记了什么注解，就需要通过扫描的方式，来进行检测。然后根据注解进行后续操作。 3. **准备Spring项目和组件** 1. 准备项目pom.xml &lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2. 准备组件类 普通组件 /** * projectName: com.atguigu.components * * description: 普通的组件 */ public class CommonComponent { } Controller组件 /** * projectName: com.atguigu.components * * description: controller类型组件 */ public class XxxController { } Service组件 /** * projectName: com.atguigu.components * * description: service类型组件 */ public class XxxService { } Dao组件 /** * projectName: com.atguigu.components * * description: dao类型组件 */ public class XxxDao { } 4. **组件添加标记注解** 1. 组件标记注解和区别 Spring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。 注解 说明 @Component 该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。 @Repository 该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 @Service 该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 @Controller 该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是在@Component注解的基础上起了三个新的名字。 对于Spring使用IOC容器管理这些组件来说没有区别，也就是语法层面没有区别。所以@Controller、@Service、@Repository这三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。 注意：虽然它们本质上一样，但是为了代码的可读性、程序结构严谨！我们肯定不能随便胡乱标记。 2. 使用注解标记 普通组件 /** * projectName: com.atguigu.components * * description: 普通的组件 */ @Component public class CommonComponent { } Controller组件 /** * projectName: com.atguigu.components * * description: controller类型组件 */ @Controller public class XxxController { } Service组件 /** * projectName: com.atguigu.components * * description: service类型组件 */ @Service public class XxxService { } Dao组件 /** * projectName: com.atguigu.components * * description: dao类型组件 */ @Repository public class XxxDao { } 5. **配置文件确定扫描范围** 情况1：基本扫描配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置自动扫描的包 --&gt; &lt;!-- 1.包要精准,提高性能! 2.会扫描指定的包和子包内容 3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等 --&gt; &lt;context:component-scan base-package=\"com.atguigu.components\"/&gt; &lt;/beans&gt; 情况2：指定排除组件 &lt;!-- 情况三：指定不扫描的组件 --&gt; &lt;context:component-scan base-package=\"com.atguigu.components\"&gt; &lt;!-- context:exclude-filter标签：指定排除规则 --&gt; &lt;!-- type属性：指定根据什么来进行排除，annotation取值表示根据注解来排除 --&gt; &lt;!-- expression属性：指定排除规则的表达式，对于注解来说指定全类名即可 --&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt; 情况3：指定扫描组件 &lt;!-- 情况四：仅扫描指定的组件 --&gt; &lt;!-- 仅扫描 = 关闭默认规则 + 追加规则 --&gt; &lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt; &lt;context:component-scan base-package=\"com.atguigu.ioc.components\" use-default-filters=\"false\"&gt; &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt; 6. **组件BeanName问题** 在我们使用 XML 方式管理 bean 的时候，每个 bean 都有一个唯一标识——id 属性的值，便于在其他地方引用。现在使用注解后，每个组件仍然应该有一个唯一标识。 默认情况： 类名首字母小写就是 bean 的 id。例如：SoldierController 类对应的 bean 的 id 就是 soldierController。 使用value属性指定： @Controller(value = \"tianDog\") public class SoldierController { } 当注解中只设置一个属性时，value属性的属性名可以省略： @Service(\"smallDog\") public class SoldierService { } 7. **总结** 1. 注解方式IoC只是标记哪些类要被Spring管理 2. 最终，我们还需要XML方式或者后面讲解Java配置类方式指定注解生效的包 3. **现阶段配置方式为 注解 （标记）+ XML（扫描）** #### 4.3.2 实验二： 组件（Bean）作用域和周期方法注解 1. 组件周期方法配置 1. 周期方法概念 我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！ 类似于Servlet的init/destroy方法,我们可以在周期方法完成初始化和释放资源等工作。 2. 周期方法声明 public class BeanOne { //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表 @PostConstruct //注解制指定初始化方法 public void init() { // 初始化逻辑 } } public class BeanTwo { @PreDestroy //注解指定销毁方法 public void cleanup() { // 释放资源逻辑 } } 2. 组件作用域配置 1. Bean作用域概念 `&lt;bean`​ 标签声明Bean，只是将Bean的信息配置给SpringIoC容器！ 在IoC容器中，这些`&lt;bean`​标签对应的信息转成Spring内部 `BeanDefinition`​ 对象，`BeanDefinition`​ 对象内，包含定义的信息（id,class,属性等等）！ 这意味着，`BeanDefinition`​与`类`​概念一样，SpringIoC容器可以可以根据`BeanDefinition`​对象反射创建多个Bean对象实例。 具体创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！ 2. 作用域可选值 取值 含义 创建对象的时机 默认值 singleton 在 IOC 容器中，这个 bean 的对象始终为单实例 IOC 容器初始化时 是 prototype 这个 bean 在 IOC 容器中有多个实例 获取 bean 时 否 如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）： 取值 含义 创建对象的时机 默认值 request 请求范围内有效的实例 每次请求 否 session 会话范围内有效的实例 每次会话 否 3. 作用域配置 @Scope(scopeName = ConfigurableBeanFactory.SCOPE_SINGLETON) //单例,默认值 @Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE) //多例 二选一 public class BeanOne { //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表 @PostConstruct //注解制指定初始化方法 public void init() { // 初始化逻辑 } } #### 4.3.3 实验三： Bean属性赋值：引用类型自动装配 (DI) 1. **设定场景** - SoldierController 需要 SoldierService - SoldierService 需要 SoldierDao 同时在各个组件中声明要调用的方法。 - SoldierController中声明方法 import org.springframework.stereotype.Controller; @Controller(value = \"tianDog\") public class SoldierController { private SoldierService soldierService; public void getMessage() { soldierService.getMessage(); } } - SoldierService中声明方法 @Service(\"smallDog\") public class SoldierService { private SoldierDao soldierDao; public void getMessage() { soldierDao.getMessage(); } } - SoldierDao中声明方法 @Repository public class SoldierDao { public void getMessage() { System.out.print(\"I am a soldier\"); } } 2. **自动装配实现** 1. 前提 参与自动装配的组件（需要装配、被装配）全部都必须在IoC容器中。 注意：不区分IoC的方式！XML和注解都可以！ 2. @Autowired注解 在成员变量上直接标记@Autowired注解即可，不需要提供setXxx()方法。以后我们在项目中的正式用法就是这样。 3. 给Controller装配Service @Controller(value = \"tianDog\") public class SoldierController { @Autowired private SoldierService soldierService; public void getMessage() { soldierService.getMessage(); } } 4. 给Service装配Dao @Service(\"smallDog\") public class SoldierService { @Autowired private SoldierDao soldierDao; public void getMessage() { soldierDao.getMessage(); } } 3. **@Autowired注解细节** 1. 标记位置 1. 成员变量 这是最主要的使用方式！ 与xml进行bean ref引用不同，他不需要有set方法！ @Service(\"smallDog\") public class SoldierService { @Autowired private SoldierDao soldierDao; public void getMessage() { soldierDao.getMessage(); } } 2. 构造器 @Controller(value = \"tianDog\") public class SoldierController { private SoldierService soldierService; @Autowired public SoldierController(SoldierService soldierService) { this.soldierService = soldierService; } …… 3. setXxx()方法 @Controller(value = \"tianDog\") public class SoldierController { private SoldierService soldierService; @Autowired public void setSoldierService(SoldierService soldierService) { this.soldierService = soldierService; } …… 2. 工作流程 ![](https://secure2.wostatic.cn/static/t6b5ZcCjFAhvshhZXUHvtp/img018.png?auth_key=1741057272-5dGheuhefe4DPR7iaDbPqD-0-4c91187290ac82b5573273af82300c29)​ - 首先根据所需要的组件类型到 IOC 容器中查找 - 能够找到唯一的 bean：直接执行装配 - 如果完全找不到匹配这个类型的 bean：装配失败 - 和所需类型匹配的 bean 不止一个 - 没有 @Qualifier 注解：根据 @Autowired 标记位置成员变量的变量名作为 bean 的 id 进行匹配 - 能够找到：执行装配 - 找不到：装配失败 - 使用 @Qualifier 注解：根据 @Qualifier 注解中指定的名称作为 bean 的id进行匹配 - 能够找到：执行装配 - 找不到：装配失败 @Controller(value = \"tianDog\") public class SoldierController { @Autowired @Qualifier(value = \"maomiService222\") // 根据面向接口编程思想，使用接口类型引入Service组件 private ISoldierService soldierService; 4. **佛系装配** 给 @Autowired 注解设置 required = false 属性表示：能装就装，装不上就不装。但是实际开发时，基本上所有需要装配组件的地方都是必须装配的，用不上这个属性 @Controller(value = \"tianDog\") public class SoldierController { // 给@Autowired注解设置required = false属性表示：能装就装，装不上就不装 @Autowired(required = false) private ISoldierService soldierService; 5. **扩展JSR-250注解@Resource** - 理解JSR系列注解 JSR（Java Specification Requests）是Java平台标准化进程中的一种技术规范，而JSR注解是其中一部分重要的内容。按照JSR的分类以及注解语义的不同，可以将JSR注解分为不同的系列，主要有以下几个系列： 1. JSR-175: 这个JSR是Java SE 5引入的，是Java注解最早的规范化版本，Java SE 5后的版本中都包含该JSR中定义的注解。主要包括以下几种标准注解： - `@Deprecated`​: 标识一个程序元素（如类、方法或字段）已过时，并且在将来的版本中可能会被删除。 - `@Override`​: 标识一个方法重写了父类中的方法。 - `@SuppressWarnings`​: 抑制编译时产生的警告消息。 - `@SafeVarargs`​: 标识一个有安全性警告的可变参数方法。 - `@FunctionalInterface`​: 标识一个接口只有一个抽象方法，可以作为lambda表达式的目标。 1. JSR-250: 这个JSR主要用于在Java EE 5中定义一些支持注解。该JSR主要定义了一些用于进行对象管理的注解，包括： - `@Resource`​: 标识一个需要注入的资源，是实现Java EE组件之间依赖关系的一种方式。 - `@PostConstruct`​: 标识一个方法作为初始化方法。 - `@PreDestroy`​: 标识一个方法作为销毁方法。 - `@Resource.AuthenticationType`​: 标识注入的资源的身份验证类型。 - `@Resource.AuthenticationType`​: 标识注入的资源的默认名称。 1. JSR-269: 这个JSR主要是Java SE 6中引入的一种支持编译时元数据处理的框架，即使用注解来处理Java源文件。该JSR定义了一些可以用注解标记的注解处理器，用于生成一些元数据，常用的注解有： - `@SupportedAnnotationTypes`​: 标识注解处理器所处理的注解类型。 - `@SupportedSourceVersion`​: 标识注解处理器支持的Java源码版本。 1. JSR-330: 该JSR主要为Java应用程序定义了一个依赖注入的标准，即Java依赖注入标准（javax.inject）。在此规范中定义了多种注解，包括： - `@Named`​: 标识一个被依赖注入的组件的名称。 - `@Inject`​: 标识一个需要被注入的依赖组件。 - `@Singleton`​: 标识一个组件的生命周期只有一个唯一的实例。 1. JSR-250: 这个JSR主要是Java EE 5中定义一些支持注解。该JSR包含了一些支持注解，可以用于对Java EE组件进行管理，包括： - `@RolesAllowed`​: 标识授权角色 - `@PermitAll`​: 标识一个活动无需进行身份验证。 - `@DenyAll`​: 标识不提供针对该方法的访问控制。 - `@DeclareRoles`​: 声明安全角色。 但是你要理解JSR是Java提供的**技术规范**，也就是说，他只是规定了注解和注解的含义，**JSR并不是直接提供特定的实现**，而是提供标准和指导方针，由第三方框架（Spring）和库来实现和提供对应的功能。 - JSR-250 @Resource注解 @Resource注解也可以完成属性注入。那它和@Autowired注解有什么区别？ - @Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。) - @Autowired注解是Spring框架自己的。 - **@Resource注解默认根据Bean名称装配，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型装配。** - **@Autowired注解默认根据类型装配，如果想根据名称装配，需要配合@Qualifier注解一起用。** - @Resource注解用在属性上、setter方法上。 - @Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。 @Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【**高于JDK11或低于JDK8需要引入以下依赖**】 &lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; - @Resource使用 @Controller public class XxxController { /** * 1. 如果没有指定name,先根据属性名查找IoC中组件xxxService * 2. 如果没有指定name,并且属性名没有对应的组件,会根据属性类型查找 * 3. 可以指定name名称查找! @Resource(name='test') == @Autowired + @Qualifier(value='test') */ @Resource private XxxService xxxService; //@Resource(name = \"指定beanName\") //private XxxService xxxService; public void show(){ System.out.println(\"XxxController.show\"); xxxService.show(); } } #### 4.3.4 实验四： Bean属性赋值：基本类型属性赋值 (DI) `@Value`​ 通常用于注入外部化属性 **声明外部配置** application.properties catalog.name=MovieCatalog **xml引入外部配置** &lt;!-- 引入外部配置文件--&gt; &lt;context:property-placeholder location=\"application.properties\" /&gt; **@Value注解读取配置** package com.atguigu.components; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; /** * projectName: com.atguigu.components * * description: 普通的组件 */ @Component public class CommonComponent { /** * 情况1: ${key} 取外部配置key对应的值! * 情况2: ${key:defaultValue} 没有key,可以给与默认值 */ @Value(\"${catalog:hahaha}\") private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } catalog #### 4.3.5 实验五： 基于注解+XML方式整合三层架构组件 1. 需求分析 搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用XML+注解方式进行组件管理！ ![](https://secure2.wostatic.cn/static/6WsK3n5TJvotqmmNNjxY54/image.png?auth_key=1741057270-kKnNwYZCc4xC4MY7At9jHY-0-d81824932d61c615bda9b7e2994ed0e2) 2. 数据库准备 create database studb; use studb; CREATE TABLE students ( id INT PRIMARY KEY, name VARCHAR(50) NOT NULL, gender VARCHAR(10) NOT NULL, age INT, class VARCHAR(50) ); INSERT INTO students (id, name, gender, age, class) VALUES (1, '张三', '男', 20, '高中一班'), (2, '李四', '男', 19, '高中二班'), (3, '王五', '女', 18, '高中一班'), (4, '赵六', '女', 20, '高中三班'), (5, '刘七', '男', 19, '高中二班'), (6, '陈八', '女', 18, '高中一班'), (7, '杨九', '男', 20, '高中三班'), (8, '吴十', '男', 19, '高中二班'); 3. 项目准备 1. 项目创建 spring-annotation-practice-04 2. 依赖导入 &lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入SpringContext依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库驱动和连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3. 实体类准备 public class Student { private Integer id; private String name; private String gender; private Integer age; private String classes; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getClasses() { return classes; } public void setClasses(String classes) { this.classes = classes; } @Override public String toString() { return \"Student{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", gender='\" + gender + '\\'' + \", age=\" + age + \", classes='\" + classes + '\\'' + '}'; } } 4. 三层架构搭建和实现 1. 持久层 //接口 public interface StudentDao { /** * 查询全部学生数据 * @return */ List&lt;Student&gt; queryAll(); } //实现类 @Repository public class StudentDaoImpl implements StudentDao { @Autowired private JdbcTemplate jdbcTemplate; /** * 查询全部学生数据 * @return */ @Override public List&lt;Student&gt; queryAll() { String sql = \"select id , name , age , gender , class as classes from students ;\"; /* query可以返回集合! BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可 */ List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class)); return studentList; } } 2. 业务层 //接口 public interface StudentService { /** * 查询全部学员业务 * @return */ List&lt;Student&gt; findAll(); } //实现类 @Service public class StudentServiceImpl implements StudentService { @Autowired private StudentDao studentDao; /** * 查询全部学员业务 * @return */ @Override public List&lt;Student&gt; findAll() { List&lt;Student&gt; studentList = studentDao.queryAll(); return studentList; } } 3. 表述层 @Controller public class StudentController { @Autowired private StudentService studentService; public void findAll(){ List&lt;Student&gt; studentList = studentService.findAll(); System.out.println(\"studentList = \" + studentList); } } 5. 三层架构IoC配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 导入外部属性文件 --&gt; &lt;context:property-placeholder location=\"classpath:jdbc.properties\" /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"url\" value=\"${atguigu.url}\"/&gt; &lt;property name=\"driverClassName\" value=\"${atguigu.driver}\"/&gt; &lt;property name=\"username\" value=\"${atguigu.username}\"/&gt; &lt;property name=\"password\" value=\"${atguigu.password}\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"druidDataSource\" /&gt; &lt;/bean&gt; &lt;!-- 扫描Ioc/DI注解 --&gt; &lt;context:component-scan base-package=\"com.atguigu.dao,com.atguigu.service,com.atguigu.controller\" /&gt; &lt;/beans&gt; 6. 运行测试 public class ControllerTest { @Test public void testRun(){ ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-ioc.xml\"); StudentController studentController = applicationContext.getBean(StudentController.class); studentController.findAll(); } } 7. 注解+XML IoC方式问题总结 1. 自定义类可以使用注解方式，但是第三方依赖的类依然使用XML方式！ 2. XML格式解析效率低！ 4.4 基于 配置类 方式管理 Bean #### 4.4.1 完全注解开发理解 Spring 完全注解配置（Fully Annotation-based Configuration）是指通过 Java配置类 代码来配置 Spring 应用程序，使用注解来替代原本在 XML 配置文件中的配置。相对于 XML 配置，完全注解配置具有更强的类型安全性和更好的可读性。 **两种方式思维转化**： ![](https://secure2.wostatic.cn/static/uhRgky6LmFBAaYDJfS5SEm/image.png?auth_key=1741057266-oPpT2EGiiNPcdaYWmtrvMd-0-c26957109f6bb11dc57e10013c587103)​ #### 4.4.2 实验一：配置类和扫描注解 **xml+注解方式** 配置文件application.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置自动扫描的包 --&gt; &lt;!-- 1.包要精准,提高性能! 2.会扫描指定的包和子包内容 3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等 --&gt; &lt;context:component-scan base-package=\"com.atguigu.components\"/&gt; &lt;!-- 引入外部配置文件--&gt; &lt;context:property-placeholder location=\"application.properties\" /&gt; &lt;/beans&gt; 测试创建IoC容器 // xml方式配置文件使用ClassPathXmlApplicationContext容器读取 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"application.xml\"); **配置类+注解方式（完全注解方式）** 配置类 使用 @Configuration 注解将一个普通的类标记为 Spring 的配置类。 import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.PropertySource; //标注当前类是配置类，替代application.xml @Configuration //使用注解读取外部配置，替代 &lt;context:property-placeholder标签 @PropertySource(\"classpath:application.properties\") //使用@ComponentScan注解,可以配置扫描包,替代&lt;context:component-scan标签 @ComponentScan(basePackages = {\"com.atguigu.components\"}) public class MyConfiguration { } 测试创建IoC容器 // AnnotationConfigApplicationContext 根据配置类创建 IOC 容器对象 ApplicationContext iocContainerAnnotation = new AnnotationConfigApplicationContext(MyConfiguration.class); 可以使用 no-arg 构造函数实例化 `AnnotationConfigApplicationContext`​ ，然后使用 `register()`​ 方法对其进行配置。此方法在以编程方式生成 `AnnotationConfigApplicationContext`​ 时特别有用。以下示例演示如何执行此操作： // AnnotationConfigApplicationContext-IOC容器对象 ApplicationContext iocContainerAnnotation = new AnnotationConfigApplicationContext(); //外部设置配置类 iocContainerAnnotation.register(MyConfiguration.class); //刷新后方可生效！！ iocContainerAnnotation.refresh(); **总结：** @Configuration指定一个类为配置类，可以添加配置注解，替代配置xml文件 @ComponentScan(basePackages = {\"包\",\"包\"}) 替代&lt;context:component-scan标签实现注解扫描 @PropertySource(\"classpath:配置文件地址\") 替代 &lt;context:property-placeholder标签 配合IoC/DI注解，可以进行完整注解开发！ #### 4.4.3 实验二：@Bean定义组件 **场景需求**：将Druid连接池对象存储到IoC容器 **需求分析**：第三方jar包的类，添加到ioc容器，无法使用@Component等相关注解！因为源码jar包内容为只读模式！ **xml方式实现**： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 引入外部属性文件 --&gt; &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt; &lt;!-- 实验六 [重要]给bean的属性赋值：引入外部属性文件 --&gt; &lt;bean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt; &lt;property name=\"driverClassName\" value=\"${jdbc.driver}\"/&gt; &lt;property name=\"username\" value=\"${jdbc.user}\"/&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;/bean&gt; &lt;/beans&gt; **配置类方式实现**： `@Bean`​ 注释用于指示方法实例化、配置和初始化要由 Spring IoC 容器管理的新对象。对于那些熟悉 Spring 的 `&lt;beans/&gt;`​ XML 配置的人来说， `@Bean`​ 注释与 `&lt;bean/&gt;`​ 元素起着相同的作用。 //标注当前类是配置类，替代application.xml @Configuration //引入jdbc.properties文件 @PropertySource({\"classpath:application.properties\",\"classpath:jdbc.properties\"}) @ComponentScan(basePackages = {\"com.atguigu.components\"}) public class MyConfiguration { //如果第三方类进行IoC管理,无法直接使用@Component相关注解 //解决方案: xml方式可以使用&lt;bean标签 //解决方案: 配置类方式,可以使用方法返回值+@Bean注解 @Bean public DataSource createDataSource(@Value(\"${jdbc.user}\") String username, @Value(\"${jdbc.password}\")String password, @Value(\"${jdbc.url}\")String url, @Value(\"${jdbc.driver}\")String driverClassName){ //使用Java代码实例化 DruidDataSource dataSource = new DruidDataSource(); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setUrl(url); dataSource.setDriverClassName(driverClassName); //返回结果即可 return dataSource; } } #### 4.4.4 实验三：高级特性：@Bean注解细节 1. **@Bean生成BeanName问题** @Bean注解源码： public @interface Bean { //前两个注解可以指定Bean的标识 @AliasFor(\"name\") String[] value() default {}; @AliasFor(\"value\") String[] name() default {}; //autowireCandidate 属性来指示该 Bean 是否候选用于自动装配。 //autowireCandidate 属性默认值为 true，表示该 Bean 是一个默认的装配目标， //可被候选用于自动装配。如果将 autowireCandidate 属性设置为 false，则说明该 Bean 不是默认的装配目标，不会被候选用于自动装配。 boolean autowireCandidate() default true; //指定初始化方法 String initMethod() default \"\"; //指定销毁方法 String destroyMethod() default \"(inferred)\"; } 指定@Bean的名称： @Configuration public class AppConfig { @Bean(\"myThing\") //指定名称 public Thing thing() { return new Thing(); } } `@Bean`​ 注释注释方法。使用此方法在指定为方法返回值的类型的 `ApplicationContext`​ 中注册 Bean 定义。缺省情况下，Bean 名称与方法名称相同。下面的示例演示 `@Bean`​ 方法声明： @Configuration public class AppConfig { @Bean public TransferServiceImpl transferService() { return new TransferServiceImpl(); } } 前面的配置完全等同于下面的Spring XML： &lt;beans&gt; &lt;bean id=\"transferService\" class=\"com.acme.TransferServiceImpl\"/&gt; &lt;/beans&gt; 2. **@Bean 初始化和销毁方法指定** `@Bean`​ 注解支持指定任意初始化和销毁回调方法，非常类似于 Spring XML 在 `bean`​ 元素上的 `init-method`​ 和 `destroy-method`​ 属性，如以下示例所示： public class BeanOne { public void init() { // initialization logic } } public class BeanTwo { public void cleanup() { // destruction logic } } @Configuration public class AppConfig { @Bean(initMethod = \"init\") public BeanOne beanOne() { return new BeanOne(); } @Bean(destroyMethod = \"cleanup\") public BeanTwo beanTwo() { return new BeanTwo(); } } 3. **@Bean Scope作用域** 可以指定使用 `@Bean`​ 注释定义的 bean 应具有特定范围。您可以使用在 Bean 作用域部分中指定的任何标准作用域。 默认作用域为 `singleton`​ ，但您可以使用 `@Scope`​ 注释覆盖此范围，如以下示例所示： @Configuration public class MyConfiguration { @Bean @Scope(\"prototype\") public Encryptor encryptor() { // ... } } 4. **@Bean方法之间依赖** **准备组件** public class HappyMachine { private String machineName; public String getMachineName() { return machineName; } public void setMachineName(String machineName) { this.machineName = machineName; } } public class HappyComponent { //引用新组件 private HappyMachine happyMachine; public HappyMachine getHappyMachine() { return happyMachine; } public void setHappyMachine(HappyMachine happyMachine) { this.happyMachine = happyMachine; } public void doWork() { System.out.println(\"HappyComponent.doWork\"); } } **Java配置类实现：** 方案1： 直接调用方法返回 Bean 实例：在一个 `@Bean`​ 方法中直接调用其他 `@Bean`​ 方法来获取 Bean 实例，虽然是方法调用，也是通过IoC容器获取对应的Bean，例如： @Configuration public class JavaConfig { @Bean public HappyMachine happyMachine(){ return new HappyMachine(); } @Bean public HappyComponent happyComponent(){ HappyComponent happyComponent = new HappyComponent(); //直接调用方法即可! happyComponent.setHappyMachine(happyMachine()); return happyComponent; } } 方案2： 参数引用法：通过方法参数传递 Bean 实例的引用来解决 Bean 实例之间的依赖关系，例如： package com.atguigu.config; import com.atguigu.ioc.HappyComponent; import com.atguigu.ioc.HappyMachine; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * projectName: com.atguigu.config * description: 配置HappyComponent和HappyMachine关系 */ @Configuration public class JavaConfig { @Bean public HappyMachine happyMachine(){ return new HappyMachine(); } /** * 可以直接在形参列表接收IoC容器中的Bean! * 情况1: 直接指定类型即可 * 情况2: 如果有多个bean,(HappyMachine 名称 ) 形参名称等于要指定的bean名称! * 例如: * @Bean * public Foo foo1(){ * return new Foo(); * } * @Bean * public Foo foo2(){ * return new Foo() * } * @Bean * public Component component(Foo foo1 / foo2 通过此处指定引入的bean) */ @Bean public HappyComponent happyComponent(HappyMachine happyMachine){ HappyComponent happyComponent = new HappyComponent(); //赋值 happyComponent.setHappyMachine(happyMachine); return happyComponent; } } #### 4.4.5 实验四：高级特性：@Import扩展 `@Import`​ 注释允许从另一个配置类加载 `@Bean`​ 定义，如以下示例所示： @Configuration public class ConfigA { @Bean public A a() { return new A(); } } @Configuration @Import(ConfigA.class) public class ConfigB { @Bean public B b() { return new B(); } } 现在，在实例化上下文时不需要同时指定 `ConfigA.class`​ 和 `ConfigB.class`​ ，只需显式提供 `ConfigB`​ ，如以下示例所示： public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class); // now both beans A and B will be available... A a = ctx.getBean(A.class); B b = ctx.getBean(B.class); } 此方法简化了容器实例化，因为只需要处理一个类，而不是要求您在构造期间记住可能大量的 `@Configuration`​ 类。 #### 4.4.6 实验五：基于注解+配置类方式整合三层架构组件 1. 需求分析 搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用注解+配置类方式进行组件管理！ ![](https://secure2.wostatic.cn/static/spSLnBnMYbqJXYLqjr2C7y/image.png?auth_key=1741057258-vSXvpqzkBVaRbarPAxZL7p-0-bdf2035f33f8cf70f063e8931e5a3f02) 2. 数据库准备 create database studb; use studb; CREATE TABLE students ( id INT PRIMARY KEY, name VARCHAR(50) NOT NULL, gender VARCHAR(10) NOT NULL, age INT, class VARCHAR(50) ); INSERT INTO students (id, name, gender, age, class) VALUES (1, '张三', '男', 20, '高中一班'), (2, '李四', '男', 19, '高中二班'), (3, '王五', '女', 18, '高中一班'), (4, '赵六', '女', 20, '高中三班'), (5, '刘七', '男', 19, '高中二班'), (6, '陈八', '女', 18, '高中一班'), (7, '杨九', '男', 20, '高中三班'), (8, '吴十', '男', 19, '高中二班'); 3. 项目准备 1. 项目创建 spring-java-practice-06 2. 依赖导入 &lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入SpringContext依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库驱动和连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3. 实体类准备 public class Student { private Integer id; private String name; private String gender; private Integer age; private String classes; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getClasses() { return classes; } public void setClasses(String classes) { this.classes = classes; } @Override public String toString() { return \"Student{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", gender='\" + gender + '\\'' + \", age=\" + age + \", classes='\" + classes + '\\'' + '}'; } } 4. 三层架构搭建和实现 1. 持久层 //接口 public interface StudentDao { /** * 查询全部学生数据 * @return */ List&lt;Student&gt; queryAll(); } //实现类 @Repository public class StudentDaoImpl implements StudentDao { @Autowired private JdbcTemplate jdbcTemplate; /** * 查询全部学生数据 * @return */ @Override public List&lt;Student&gt; queryAll() { String sql = \"select id , name , age , gender , class as classes from students ;\"; /* query可以返回集合! BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可 */ List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class)); return studentList; } } 2. 业务层 //接口 public interface StudentService { /** * 查询全部学员业务 * @return */ List&lt;Student&gt; findAll(); } //实现类 @Service public class StudentServiceImpl implements StudentService { @Autowired private StudentDao studentDao; /** * 查询全部学员业务 * @return */ @Override public List&lt;Student&gt; findAll() { List&lt;Student&gt; studentList = studentDao.queryAll(); return studentList; } } 3. 表述层 @Controller public class StudentController { @Autowired private StudentService studentService; public void findAll(){ List&lt;Student&gt; studentList = studentService.findAll(); System.out.println(\"studentList = \" + studentList); } } 5. 三层架构IoC配置类 @Configuration @ComponentScan(basePackages = \"com.atguigu\") @PropertySource(\"classpath:jdbc.properties\") public class JavaConfig { @Value(\"${atguigu.url}\") private String url; @Value(\"${atguigu.driver}\") private String driver; @Value(\"${atguigu.username}\") private String username; @Value(\"${atguigu.password}\") private String password; @Bean(destroyMethod = \"close\") public DruidDataSource dataSource(){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setDriverClassName(driver); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; } @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource){ JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; } } 6. 运行测试 public class ControllerTest { @Test public void testRun(){ AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(JavaConfig.class); StudentController studentController = applicationContext.getBean(StudentController.class); studentController.findAll(); } } 7. 注解+配置类 IoC方式总结 1. 完全摒弃了XML配置文件 2. 自定义类使用IoC和DI注解标记 3. 第三方类使用配置类声明方法+@Bean方式处理 4. 完全注解方式（配置类+注解）是现在主流配置方式 4.5 三种配置方式总结 #### 4.5.1 XML方式配置总结 1. 所有内容写到xml格式配置文件中 2. 声明bean通过&lt;bean标签 3. &lt;bean标签包含基本信息（id,class）和属性信息 &lt;property name value / ref 4. 引入外部的properties文件可以通过&lt;context:property-placeholder 5. IoC具体容器实现选择ClassPathXmlApplicationContext对象 #### 4.5.2 XML+注解方式配置总结 1. 注解负责标记IoC的类和进行属性装配 2. xml文件依然需要，需要通过&lt;context:component-scan标签指定注解范围 3. 标记IoC注解：@Component,@Service,@Controller,@Repository 4. 标记DI注解：@Autowired @Qualifier @Resource @Value 5. IoC具体容器实现选择ClassPathXmlApplicationContext对象 #### 4.5.3 完全注解方式配置总结 1. 完全注解方式指的是去掉xml文件，使用配置类 + 注解实现 2. xml文件替换成使用@Configuration注解标记的类 3. 标记IoC注解：@Component,@Service,@Controller,@Repository 4. 标记DI注解：@Autowired @Qualifier @Resource @Value 5. &lt;context:component-scan标签指定注解范围使用@ComponentScan(basePackages = {\"com.atguigu.components\"})替代 6. &lt;context:property-placeholder引入外部配置文件使用@PropertySource({\"classpath:application.properties\",\"classpath:jdbc.properties\"})替代 7. &lt;bean 标签使用@Bean注解和方法实现 8. IoC具体容器实现选择AnnotationConfigApplicationContext对象 4.6 整合Spring5-Test5搭建测试环境 1. 整合测试环境作用 好处1：不需要自己创建IOC容器对象了 好处2：任何需要的bean都可以在测试类中直接享受自动装配 2. 导入相关依赖 &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 3. 整合测试注解使用 //@SpringJUnitConfig(locations = {\"classpath:spring-context.xml\"}) //指定配置文件xml @SpringJUnitConfig(value = {BeanConfig.class}) //指定配置类 public class Junit5IntegrationTest { @Autowired private User user; @Test public void testJunit5() { System.out.println(user); } } 五、Spring AOP面向切面编程 5.1 场景设定和问题复现 1. 准备AOP项目 项目名：spring-aop-annotation pom.xml &lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2. 声明接口 /** * + - * / 运算的标准接口! */ public interface Calculator { int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j); } 3. 接口实现 package com.atguigu.proxy; /** * 实现计算接口,单纯添加 + - * / 实现! 掺杂其他功能! */ public class CalculatorPureImpl implements Calculator { @Override public int add(int i, int j) { int result = i + j; return result; } @Override public int sub(int i, int j) { int result = i - j; return result; } @Override public int mul(int i, int j) { int result = i * j; return result; } @Override public int div(int i, int j) { int result = i / j; return result; } } 4. 声明带日志接口实现 新需求： 需要在每个方法中，添加控制台输出，输出参数和输出计算后的返回值！ ![](https://secure2.wostatic.cn/static/rP27XVMnTD1FtCx1maiUuW/aopimg002.png?auth_key=1741057247-hBjmUJhmKzoREgSVMtqtVF-0-f3a8508b77fc6ce55c82ac06483c84db)​ package com.atguigu.proxy; /** * 在每个方法中,输出传入的参数和计算后的返回结果! */ public class CalculatorLogImpl implements Calculator { @Override public int add(int i, int j) { System.out.println(\"参数是：\" + i + \",\" + j); int result = i + j; System.out.println(\"方法内部 result = \" + result); return result; } @Override public int sub(int i, int j) { System.out.println(\"参数是：\" + i + \",\" + j); int result = i - j; System.out.println(\"方法内部 result = \" + result); return result; } @Override public int mul(int i, int j) { System.out.println(\"参数是：\" + i + \",\" + j); int result = i * j; System.out.println(\"方法内部 result = \" + result); return result; } @Override public int div(int i, int j) { System.out.println(\"参数是：\" + i + \",\" + j); int result = i / j; System.out.println(\"方法内部 result = \" + result); return result; } } 5. 代码问题分析 1. 代码缺陷 - 对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力 - 附加功能代码重复，分散在各个业务功能方法中！冗余，且不方便统一维护！ 2. 解决思路 核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。 将重复的代码统一提取，并且动态插入到每个业务方法！ 3. 技术困难 解决问题的困难：提取重复附加功能代码到一个类中，可以实现 但是如何将代码插入到各个方法中，我们不会，我们需要引用新技术！！！ 5.2 解决技术代理模式 1. **代理模式** 二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。 无代理场景： ![](https://secure2.wostatic.cn/static/2KdCVRG7sTJfhNGH3QaB58/aopimg004.png?auth_key=1741057246-ezkwT6orA3hBfNtxYSfQz-0-3330b652f2cf6915937954c4a4229917)​ 有代理场景： ![](https://secure2.wostatic.cn/static/atPYpsBfyndTrgArisWrag/aopimg005.png?auth_key=1741057246-nYgguELZWeRqexXgRvZFc3-0-977c67509f4f5369181bec5f0a08f8cd)​ 生活中的代理： - 广告商找大明星拍广告需要经过经纪人 - 合作伙伴找大老板谈合作要约见面时间需要经过秘书 - 房产中介是买卖双方的代理 - 太监是大臣和皇上之间的代理 相关术语： - 代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。(中介) - 动词：指做代理这个动作，或这项工作 - 名词：扮演代理这个角色的类、对象、方法 - 目标：**被代理**“套用”了核心逻辑代码的类、对象、方法。(房东) 代理在开发中实现的方式具体有两种：静态代理，[动态代理技术] 2. **静态代理** 主动创建代理类： public class CalculatorStaticProxy implements Calculator { // 将被代理的目标对象声明为成员变量 private Calculator target; public CalculatorStaticProxy(Calculator target) { this.target = target; } @Override public int add(int i, int j) { // 附加功能由代理类中的代理方法来实现 System.out.println(\"参数是：\" + i + \",\" + j); // 通过目标对象来实现核心业务逻辑 int addResult = target.add(i, j); System.out.println(\"方法内部 result = \" + result); return addResult; } …… 静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。 提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。 3. **动态代理** 动态代理技术分类 - JDK动态代理：JDK原生的实现方式，需要被代理的目标类必须**实现接口**！他会根据目标类的接口动态生成一个代理对象！代理对象和目标对象有相同的接口！（拜把子） - cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口！（认干爹） JDK动态代理技术实现（了解） ![](https://secure2.wostatic.cn/static/23QMoxyYUoz7qSJeAnRUug/aopimg003.png?auth_key=1741057246-mRE5TxsRVTreKdbVDWcZ7D-0-d9c8c1c90cfbb0f9d1b0461b0f87257e)​ 代理工程：基于jdk代理技术，生成代理对象 public class ProxyFactory { private Object target; public ProxyFactory(Object target) { this.target = target; } public Object getProxy(){ /** * newProxyInstance()：创建一个代理实例 * 其中有三个参数： * 1、classLoader：加载动态生成的代理类的类加载器 * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组 * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法 */ ClassLoader classLoader = target.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces(); InvocationHandler invocationHandler = new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { /** * proxy：代理对象 * method：代理对象需要实现的方法，即其中需要重写的方法 * args：method所对应方法的参数 */ Object result = null; try { System.out.println(\"[动态代理][日志] \"+method.getName()+\"，参数：\"+ Arrays.toString(args)); result = method.invoke(target, args); System.out.println(\"[动态代理][日志] \"+method.getName()+\"，结果：\"+ result); } catch (Exception e) { e.printStackTrace(); System.out.println(\"[动态代理][日志] \"+method.getName()+\"，异常：\"+e.getMessage()); } finally { System.out.println(\"[动态代理][日志] \"+method.getName()+\"，方法执行完毕\"); } return result; } }; return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler); } } 测试代码： @Test public void testDynamicProxy(){ ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl()); Calculator proxy = (Calculator) factory.getProxy(); proxy.div(1,0); //proxy.div(1,1); } 4. **代理总结** **代理方式可以解决附加功能代码干扰核心代码和不方便统一维护的问题！** 他主要是将附加功能代码提取到代理中执行，不干扰目标核心代码！ 但是我们也发现，无论使用静态代理和动态代理(jdk,cglib)，程序员的工作都比较繁琐！ 需要自己编写代理工厂等！ 但是，提前剧透，我们在实际开发中，不需要编写代理代码，我们可以使用[Spring AOP]框架， 他会简化动态代理的实现！！！ 5.3 面向切面编程思维（AOP） 1. **面向切面编程思想AOP** AOP：Aspect Oriented Programming面向切面编程 AOP可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 ![](https://secure2.wostatic.cn/static/7xBHASmuNUSNpC3bZmWUHT/image.png?auth_key=1741057244-hgxJ6fHvL3Uv6wSfUfot7a-0-4f3c8d8f1e6b8b6d2365ad4969a0f9eb)​ AOP技术恰恰相反，它利用一种称为\"横切\"的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为\"Aspect\"，即切面。所谓\"切面\"，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 使用AOP，可以在不修改原来代码的基础上添加新功能。 ![](https://secure2.wostatic.cn/static/pSbvngwba8MqmH69aQfzjj/image.png?auth_key=1741057244-5ySdWAL8VrE8PXU7VWs9Yo-0-0a63d4d0fcdd1016268d75e36c656a90) 2. **AOP思想主要的应用场景** AOP（面向切面编程）是一种编程范式，它通过将通用的横切关注点（如日志、事务、权限控制等）与业务逻辑分离，使得代码更加清晰、简洁、易于维护。AOP可以应用于各种场景，以下是一些常见的AOP应用场景： 1. 日志记录：在系统中记录日志是非常重要的，可以使用AOP来实现日志记录的功能，可以在方法执行前、执行后或异常抛出时记录日志。 2. 事务处理：在数据库操作中使用事务可以保证数据的一致性，可以使用AOP来实现事务处理的功能，可以在方法开始前开启事务，在方法执行完毕后提交或回滚事务。 3. 安全控制：在系统中包含某些需要安全控制的操作，如登录、修改密码、授权等，可以使用AOP来实现安全控制的功能。可以在方法执行前进行权限判断，如果用户没有权限，则抛出异常或转向到错误页面，以防止未经授权的访问。 4. 性能监控：在系统运行过程中，有时需要对某些方法的性能进行监控，以找到系统的瓶颈并进行优化。可以使用AOP来实现性能监控的功能，可以在方法执行前记录时间戳，在方法执行完毕后计算方法执行时间并输出到日志中。 5. 异常处理：系统中可能出现各种异常情况，如空指针异常、数据库连接异常等，可以使用AOP来实现异常处理的功能，在方法执行过程中，如果出现异常，则进行异常处理（如记录日志、发送邮件等）。 6. 缓存控制：在系统中有些数据可以缓存起来以提高访问速度，可以使用AOP来实现缓存控制的功能，可以在方法执行前查询缓存中是否有数据，如果有则返回，否则执行方法并将方法返回值存入缓存中。 7. 动态代理：AOP的实现方式之一是通过动态代理，可以代理某个类的所有方法，用于实现各种功能。 综上所述，AOP可以应用于各种场景，它的作用是将通用的横切关注点与业务逻辑分离，使得代码更加清晰、简洁、易于维护。 3. **AOP术语名词介绍** 1-横切关注点 从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。 这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。 ![](https://secure2.wostatic.cn/static/q1FA8t8MXYLLqk6gybZ5Ya/aopimg007.png?auth_key=1741057244-hfmhVFM46ojRtNkXY4N6Ng-0-892da30ddf07cff624b31f02158b98ff)​ AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事务、异常等。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 2-通知(增强) 每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。 - 前置通知：在被代理的目标方法前执行 - 返回通知：在被代理的目标方法成功结束后执行（**寿终正寝**） - 异常通知：在被代理的目标方法异常结束后执行（**死于非命**） - 后置通知：在被代理的目标方法最终结束后执行（**盖棺定论**） - 环绕通知：使用try...catch...finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置 ![](https://secure2.wostatic.cn/static/p2kNLy4hrpYoHRjpanrS2t/aopimg008.png?auth_key=1741057244-vrD1g8dd5oCPRjDH57gg58-0-3b6985f4a0e766581d9107fa51f098ae)​ 3-连接点 joinpoint 这也是一个纯逻辑概念，不是语法定义的。 指那些被拦截到的点。在 Spring 中，可以被动态代理拦截目标类的方法 ![](https://secure2.wostatic.cn/static/ssFYqSKwRkku7yWm1KrHFo/apoimg010.png?auth_key=1741057244-925QsTU9Kqzxma7YMTkt4a-0-eb3dacd6470004df46a9e73d104c1ef8)​ 4-切入点 pointcut 定位连接点的方式，或者可以理解成被选中的连接点！ 是一个表达式，比如execution(* com.spring.service.impl. *.* (..))。符合条件的每个方法都是一个具体的连接点。 5-切面 aspect 切入点和通知的结合。是一个类。 ![](https://secure2.wostatic.cn/static/8Y4kgKdeMeNz2RSFkHo4o1/aopimg009.png?auth_key=1741057244-x8enY7odErJEc5pvWoiPGd-0-ea05a779ab34b57d3682f96fec9fae7d)​ 6-目标 target 被代理的目标对象。 7-代理 proxy 向目标对象应用通知之后创建的代理对象。 8-织入 weave 指把通知应用到目标上，生成代理对象的过程。可以在编译期织入，也可以在运行期织入，Spring采用后者。 5.4 Spring AOP框架介绍和关系梳理 1. AOP一种区别于OOP的编程思维，用来完善和解决OOP的非核心代码冗余和不方便统一维护问题！ 2. 代理技术（动态代理|静态代理）是实现AOP思维编程的具体技术，但是自己使用动态代理实现代码比较繁琐！ 3. Spring AOP框架，基于AOP编程思维，封装动态代理技术，简化动态代理技术实现的框架！SpringAOP内部帮助我们实现动态代理，我们只需写少量的配置，指定生效范围即可,即可完成面向切面思维编程的实现！ 5.5 Spring AOP基于注解方式实现和细节 #### 5.5.1 Spring AOP底层技术组成 ![](https://secure2.wostatic.cn/static/pRzPnt5i7zeasX3V3zYZQ4/aopimg006-1716953659294.png?auth_key=1741057241-cUZEuBJihydejgaiMX1rcx-0-25e2a070753a145489702c3e6be3fe5d)​ - 动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。 - cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。 - AspectJ：早期的AOP实现的框架，SpringAOP借用了AspectJ中的AOP注解。 #### 5.5.2 初步实现 1. 加入依赖 &lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; 2. 准备接口 public interface Calculator { int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j); } 3. 纯净实现类 package com.atguigu.proxy; /** * 实现计算接口,单纯添加 + - * / 实现! 掺杂其他功能! */ @Component public class CalculatorPureImpl implements Calculator { @Override public int add(int i, int j) { int result = i + j; return result; } @Override public int sub(int i, int j) { int result = i - j; return result; } @Override public int mul(int i, int j) { int result = i * j; return result; } @Override public int div(int i, int j) { int result = i / j; return result; } } 4. 声明切面类 package com.atguigu.advice; import org.aspectj.lang.annotation.*; import org.springframework.stereotype.Component; // @Aspect表示这个类是一个切面类 @Aspect // @Component注解保证这个切面类能够放入IOC容器 @Component public class LogAspect { // @Before注解：声明当前方法是前置通知方法 // value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上 @Before(value = \"execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))\") public void printLogBeforeCore() { System.out.println(\"[AOP前置通知] 方法开始了\"); } @AfterReturning(value = \"execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))\") public void printLogAfterSuccess() { System.out.println(\"[AOP返回通知] 方法成功返回了\"); } @AfterThrowing(value = \"execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))\") public void printLogAfterException() { System.out.println(\"[AOP异常通知] 方法抛异常了\"); } @After(value = \"execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))\") public void printLogFinallyEnd() { System.out.println(\"[AOP后置通知] 方法最终结束了\"); } } 5. 开启aspectj注解支持 1. xml方式 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 进行包扫描--&gt; &lt;context:component-scan base-package=\"com.atguigu\" /&gt; &lt;!-- 开启aspectj框架注解支持--&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;/beans&gt; 2. 配置类方式 @Configuration @ComponentScan(basePackages = \"com.atguigu\") //作用等于 &lt;aop:aspectj-autoproxy /&gt; 配置类上开启 Aspectj注解支持! @EnableAspectJAutoProxy public class MyConfig { } 6. 测试效果 //@SpringJUnitConfig(locations = \"classpath:spring-aop.xml\") @SpringJUnitConfig(value = {MyConfig.class}) public class AopTest { @Autowired private Calculator calculator; @Test public void testCalculator(){ calculator.add(1,1); } } 输出结果： \"C:\\Program Files\\Java\\jdk-17\\bin\\java.exe\" -ea -Didea.test.cyclic.buffer.size=1048576 \"-javaagent:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.3.2\\lib\\idea_rt.jar=65511:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.3.2\\bin\" -Dfile.encoding=UTF-8 -classpath \"C:\\Users\\Jackiechan\\.m2\\repository\\org\\junit\\platform\\junit-platform-launcher\\1.3.1\\junit-platform-launcher-1.3.1.jar;C:\\Users\\Jackiechan\\.m2\\repository\\org\\apiguardian\\apiguardian-api\\1.0.0\\apiguardian-api-1.0.0.jar;C:\\Users\\Jackiechan\\.m2\\repository\\org\\junit\\platform\\junit-platform-engine\\1.3.1\\junit-platform-engine-1.3.1.jar;C:\\Users\\Jackiechan\\.m2\\repository\\org\\junit\\platform\\junit-platform-commons\\1.3.1\\junit-platform-commons-1.3.1.jar;C:\\Users\\Jackiechan\\.m2\\repository\\org\\opentest4j\\opentest4j\\1.1.1\\opentest4j-1.1.1.jar;C:\\Users\\Jackiechan\\.m2\\repository\\org\\junit\\jupiter\\junit-jupiter-engine\\5.3.1\\junit-jupiter-engine-5.3.1.jar;C:\\Users\\Jackiechan\\.m2\\repository\\org\\junit\\jupiter\\junit-jupiter-api\\5.3.1\\junit-jupiter-api-5.3.1.jar;D:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.3.2\\lib\\idea_rt.jar;D:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.3.2\\plugins\\junit\\lib\\junit5-rt.jar;D:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.3.2\\plugins\\junit\\lib\\junit-rt.jar;D:\\javaprojects\\backend-engineering\\part01-spring\\spring-aop-annotation\\target\\test-classes;D:\\javaprojects\\backend-engineering\\part01-spring\\spring-aop-annotation\\target\\classes;D:\\repository\\org\\springframework\\spring-context\\6.0.6\\spring-context-6.0.6.jar;D:\\repository\\org\\springframework\\spring-beans\\6.0.6\\spring-beans-6.0.6.jar;D:\\repository\\org\\springframework\\spring-core\\6.0.6\\spring-core-6.0.6.jar;D:\\repository\\org\\springframework\\spring-jcl\\6.0.6\\spring-jcl-6.0.6.jar;D:\\repository\\org\\springframework\\spring-expression\\6.0.6\\spring-expression-6.0.6.jar;D:\\repository\\org\\junit\\jupiter\\junit-jupiter-api\\5.3.1\\junit-jupiter-api-5.3.1.jar;D:\\repository\\org\\apiguardian\\apiguardian-api\\1.0.0\\apiguardian-api-1.0.0.jar;D:\\repository\\org\\opentest4j\\opentest4j\\1.1.1\\opentest4j-1.1.1.jar;D:\\repository\\org\\junit\\platform\\junit-platform-commons\\1.3.1\\junit-platform-commons-1.3.1.jar;D:\\repository\\org\\springframework\\spring-test\\6.0.6\\spring-test-6.0.6.jar;D:\\repository\\jakarta\\annotation\\jakarta.annotation-api\\2.1.1\\jakarta.annotation-api-2.1.1.jar;D:\\repository\\mysql\\mysql-connector-java\\8.0.25\\mysql-connector-java-8.0.25.jar;D:\\repository\\com\\google\\protobuf\\protobuf-java\\3.11.4\\protobuf-java-3.11.4.jar;D:\\repository\\com\\alibaba\\druid\\1.2.8\\druid-1.2.8.jar;D:\\repository\\javax\\annotation\\javax.annotation-api\\1.3.2\\javax.annotation-api-1.3.2.jar;D:\\repository\\org\\springframework\\spring-aop\\6.0.6\\spring-aop-6.0.6.jar;D:\\repository\\org\\springframework\\spring-aspects\\6.0.6\\spring-aspects-6.0.6.jar;D:\\repository\\org\\aspectj\\aspectjweaver\\1.9.9.1\\aspectjweaver-1.9.9.1.jar\" com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit5 com.atguigu.test.AopTest,testCalculator [AOP前置通知] 方法开始了 [AOP返回通知] 方法成功返回了 [AOP后置通知] 方法最终结束了 #### 5.5.3 获取通知细节信息 1. **JointPoint接口** 需要获取方法签名、传入的实参等信息时，可以在通知方法声明JoinPoint类型的形参。 - 要点1：JoinPoint 接口通过 getSignature() 方法获取目标方法的签名（方法声明时的完整信息） - 要点2：通过目标方法签名对象获取方法名 - 要点3：通过 JoinPoint 对象获取外界调用目标方法时传入的实参列表组成的数组 // @Before注解标记前置通知方法 // value属性：切入点表达式，告诉Spring当前通知方法要套用到哪个目标方法上 // 在前置通知方法形参位置声明一个JoinPoint类型的参数，Spring就会将这个对象传入 // 根据JoinPoint对象就可以获取目标方法名称、实际参数列表 @Before(value = \"execution(public int com.atguigu.aop.api.Calculator.add(int,int))\") public void printLogBeforeCore(JoinPoint joinPoint) { // 1.通过JoinPoint对象获取目标方法签名对象 // 方法的签名：一个方法的全部声明信息 Signature signature = joinPoint.getSignature(); // 2.通过方法的签名对象获取目标方法的详细信息 String methodName = signature.getName(); System.out.println(\"methodName = \" + methodName); int modifiers = signature.getModifiers(); System.out.println(\"modifiers = \" + modifiers); String declaringTypeName = signature.getDeclaringTypeName(); System.out.println(\"declaringTypeName = \" + declaringTypeName); // 3.通过JoinPoint对象获取外界调用目标方法时传入的实参列表 Object[] args = joinPoint.getArgs(); // 4.由于数组直接打印看不到具体数据，所以转换为List集合 List&lt;Object&gt; argList = Arrays.asList(args); System.out.println(\"[AOP前置通知] \" + methodName + \"方法开始了，参数列表：\" + argList); } 2. **方法返回值** 在返回通知中，通过 **@AfterReturning**注解的returning属性获取目标方法的返回值！ // @AfterReturning注解标记返回通知方法 // 在返回通知中获取目标方法返回值分两步： // 第一步：在@AfterReturning注解中通过returning属性设置一个名称 // 第二步：使用returning属性设置的名称在通知方法中声明一个对应的形参 @AfterReturning( value = \"execution(public int com.atguigu.aop.api.Calculator.add(int,int))\", returning = \"targetMethodReturnValue\" ) public void printLogAfterCoreSuccess(JoinPoint joinPoint, Object targetMethodReturnValue) { String methodName = joinPoint.getSignature().getName(); System.out.println(\"[AOP返回通知] \"+methodName+\"方法成功结束了，返回值是：\" + targetMethodReturnValue); } 3. **异常对象捕捉** 在异常通知中，通过@AfterThrowing注解的throwing属性获取目标方法抛出的异常对象 // @AfterThrowing注解标记异常通知方法 // 在异常通知中获取目标方法抛出的异常分两步： // 第一步：在@AfterThrowing注解中声明一个throwing属性设定形参名称 // 第二步：使用throwing属性指定的名称在通知方法声明形参，Spring会将目标方法抛出的异常对象从这里传给我们 @AfterThrowing( value = \"execution(public int com.atguigu.aop.api.Calculator.add(int,int))\", throwing = \"targetMethodException\" ) public void printLogAfterCoreException(JoinPoint joinPoint, Throwable targetMethodException) { String methodName = joinPoint.getSignature().getName(); System.out.println(\"[AOP异常通知] \"+methodName+\"方法抛异常了，异常类型是：\" + targetMethodException.getClass().getName()); } #### 5.5.4 切点表达式语法 1. **切点表达式作用** AOP切点表达式（Pointcut Expression）是一种用于指定切点的语言，它可以通过定义匹配规则，来选择需要被切入的目标对象。 ![](https://secure2.wostatic.cn/static/bYuoZYrB1bTE9phRx5AJfk/apoimg028.png?auth_key=1741057239-2vXSaiYgChCw9y9rLpogRh-0-e60f4d669d17fffabded389f3b34d964) 2. **切点表达式语法** 切点表达式总结 ![](https://secure2.wostatic.cn/static/u3zGFYMEQBEc9aXovEQo1R/apoimg011.png?auth_key=1741057239-uT8Zqt5rMTmD7ZW3n9NEQ8-0-24346a623169964d7642cb412ccc7154)​ 语法细节 - 第一位：execution( ) 固定开头 - 第二位：方法访问修饰符 public private 直接描述对应修饰符即可 - 第三位：方法返回值 int String void 直接描述返回值类型 注意： 特殊情况 不考虑 访问修饰符和返回值 execution(* * ) 这是错误语法 execution(*) == 你只要考虑返回值 或者 不考虑访问修饰符 相当于全部不考虑了 - 第四位：指定包的地址 固定的包: com.atguigu.api | service | dao 单层的任意命名: com.atguigu.* = com.atguigu.api com.atguigu.dao * = 任意一层的任意命名 任意层任意命名: com.. = com.atguigu.api.erdaye com.a.a.a.a.a.a.a ..任意层,任意命名 用在包上! 注意: ..不能用作包开头 public int .. 错误语法 com.. 找到任何包下: *.. - 第五位：指定类名称 固定名称: UserService 任意类名: * 部分任意: com..service.impl.*Impl 任意包任意类: *..* - 第六位：指定方法名称 语法和类名一致 任意访问修饰符,任意类的任意方法: * *..*.* - 第七位：方法参数 第七位: 方法的参数描述 具体值: (String,int) != (int,String) 没有参数 () 模糊值: 任意参数 有 或者 没有 (..) ..任意参数的意识 部分具体和模糊: 第一个参数是字符串的方法 (String..) 最后一个参数是字符串 (..String) 字符串开头,int结尾 (String..int) 包含int类型(..int..) 3. **切点表达式案例** 1.查询某包某类下，访问修饰符是公有，返回值是int的全部方法 2.查询某包下类中第一个参数是String的方法 3.查询全部包下，无参数的方法！ 4.查询com包下，以int参数类型结尾的方法 5.查询指定包下，Service开头类的私有返回值int的无参数方法 #### 5.5.5 重用（提取）切点表达式 1. 重用切点表达式优点 // @Before注解：声明当前方法是前置通知方法 // value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上 @Before(value = \"execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))\") public void printLogBeforeCore() { System.out.println(\"[AOP前置通知] 方法开始了\"); } @AfterReturning(value = \"execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))\") public void printLogAfterSuccess() { System.out.println(\"[AOP返回通知] 方法成功返回了\"); } @AfterThrowing(value = \"execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))\") public void printLogAfterException() { System.out.println(\"[AOP异常通知] 方法抛异常了\"); } @After(value = \"execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))\") public void printLogFinallyEnd() { System.out.println(\"[AOP后置通知] 方法最终结束了\"); } 上面案例，是我们之前编写切点表达式的方式，发现， 所有增强方法的切点表达式相同！ 出现了冗余，如果需要切换也不方便统一维护！ 我们可以将切点提取，在增强上进行引用即可！ 2. 同一类内部引用 提取 // 切入点表达式重用 @Pointcut(\"execution(public int com.atguigu.aop.api.Calculator.add(int,int)))\") public void declarPointCut() {} 注意：提取切点注解使用@Pointcut(切点表达式) ， 需要添加到一个无参数无返回值方法上即可！ 引用 @Before(value = \"declarPointCut()\") public void printLogBeforeCoreOperation(JoinPoint joinPoint) { 3. 不同类中引用 不同类在引用切点，只需要添加类的全限定符+方法名即可！ @Before(value = \"com.atguigu.spring.aop.aspect.LogAspect.declarPointCut()\") public Object roundAdvice(ProceedingJoinPoint joinPoint) { 4. 切点统一管理 建议：将切点表达式统一存储到一个类中进行集中管理和维护！ @Component public class AtguiguPointCut { @Pointcut(value = \"execution(public int *..Calculator.sub(int,int))\") public void atguiguGlobalPointCut(){} @Pointcut(value = \"execution(public int *..Calculator.add(int,int))\") public void atguiguSecondPointCut(){} @Pointcut(value = \"execution(* *..*Service.*(..))\") public void transactionPointCut(){} } #### 5.5.6 环绕通知 环绕通知对应整个 try...catch...finally 结构，包括前面四种通知的所有功能。 // 使用@Around注解标明环绕通知方法 @Around(value = \"com.atguigu.aop.aspect.AtguiguPointCut.transactionPointCut()\") public Object manageTransaction( // 通过在通知方法形参位置声明ProceedingJoinPoint类型的形参， // Spring会将这个类型的对象传给我们 ProceedingJoinPoint joinPoint) { // 通过ProceedingJoinPoint对象获取外界调用目标方法时传入的实参数组 Object[] args = joinPoint.getArgs(); // 通过ProceedingJoinPoint对象获取目标方法的签名对象 Signature signature = joinPoint.getSignature(); // 通过签名对象获取目标方法的方法名 String methodName = signature.getName(); // 声明变量用来存储目标方法的返回值 Object targetMethodReturnValue = null; try { // 在目标方法执行前：开启事务（模拟） log.debug(\"[AOP 环绕通知] 开启事务，方法名：\" + methodName + \"，参数列表：\" + Arrays.asList(args)); // 过ProceedingJoinPoint对象调用目标方法 // 目标方法的返回值一定要返回给外界调用者 targetMethodReturnValue = joinPoint.proceed(args); // 在目标方法成功返回后：提交事务（模拟） log.debug(\"[AOP 环绕通知] 提交事务，方法名：\" + methodName + \"，方法返回值：\" + targetMethodReturnValue); }catch (Throwable e){ // 在目标方法抛异常后：回滚事务（模拟） log.debug(\"[AOP 环绕通知] 回滚事务，方法名：\" + methodName + \"，异常：\" + e.getClass().getName()); }finally { // 在目标方法最终结束后：释放数据库连接 log.debug(\"[AOP 环绕通知] 释放数据库连接，方法名：\" + methodName); } return targetMethodReturnValue; } #### 5.5.7 切面优先级设置 相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。 - 优先级高的切面：外面 - 优先级低的切面：里面 使用 @Order 注解可以控制切面的优先级： - @Order(较小的数)：优先级高 - @Order(较大的数)：优先级低 ![](https://secure2.wostatic.cn/static/iEnKQ8R7ApCSeaF4x3wuYa/aopimg012.png?auth_key=1741057237-87XvPbBdhkCr4EkzJJjGma-0-7d7145a39b1cabf0bd6f1faa3c651314)​ 实际意义 实际开发时，如果有多个切面嵌套的情况，要慎重考虑。例如：如果事务切面优先级高，那么在缓存中命中数据的情况下，事务切面的操作都浪费了。 ![](https://secure2.wostatic.cn/static/6g2Cj5L8KRRnnaZ3zRReu/aopimg013.png?auth_key=1741057237-hHfqDiG9KKyiVEMC1t8Gwc-0-1746d946eea1bcd7206411b9d7bff90a)​ 此时应该将缓存切面的优先级提高，在事务操作之前先检查缓存中是否存在目标数据。 #### 5.5.8 CGLib动态代理生效 在目标类没有实现任何接口的情况下，Spring会自动使用cglib技术实现代理。为了证明这一点，我们做下面的测试： @Service public class EmployeeService { public void getEmpList() { System.out.print(\"方法内部 com.atguigu.aop.imp.EmployeeService.getEmpList\"); } } 测试： @Autowired private EmployeeService employeeService; @Test public void testNoInterfaceProxy() { employeeService.getEmpList(); } 没有接口： ![](https://secure2.wostatic.cn/static/wDFPhenVxhRjSLAYxZxe66/img029.png?auth_key=1741057236-d7GgDtuvdUggptBatZ9cvB-0-f094aec9c91e1cfc2c8551afaba9450f)​ 有接口： ![](https://secure2.wostatic.cn/static/9GdskQzE3TDD2FnqUTLQJU/img030.png?auth_key=1741057236-fz8j7hfnCn7La92uNZBSeq-0-99c8cf5ac3d8e2526c9de0b5ed8740c1)​ 使用总结： a. 如果目标类有接口,选择使用jdk动态代理 b. 如果目标类没有接口,选择cglib动态代理 c. 如果有接口,接口接值 d. 如果没有接口,类进行接值 #### 5.5.9 注解实现小结 ![](https://secure2.wostatic.cn/static/sfHfbbULBw5jTj8dnzEnKT/aopimg015.png?auth_key=1741057235-xhtC4De7qWYEWmqQhmGhqJ-0-e7571a566799ad9c6aa3030ecc5ed0c4)​ 5.6 Spring AOP基于XML方式实现(了解) 1. 准备工作 加入依赖 和基于注解的 AOP 时一样。 准备代码 把测试基于注解功能时的Java类复制到新module中，去除所有注解。 2. 配置Spring配置文件 &lt;!-- 配置目标类的bean --&gt; &lt;bean id=\"calculatorPure\" class=\"com.atguigu.aop.imp.CalculatorPureImpl\"/&gt; &lt;!-- 配置切面类的bean --&gt; &lt;bean id=\"logAspect\" class=\"com.atguigu.aop.aspect.LogAspect\"/&gt; &lt;!-- 配置AOP --&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut id=\"logPointCut\" expression=\"execution(* *..*.*(..))\"/&gt; &lt;!-- aop:aspect标签：配置切面 --&gt; &lt;!-- ref属性：关联切面类的bean --&gt; &lt;aop:aspect ref=\"logAspect\"&gt; &lt;!-- aop:before标签：配置前置通知 --&gt; &lt;!-- method属性：指定前置通知的方法名 --&gt; &lt;!-- pointcut-ref属性：引用切入点表达式 --&gt; &lt;aop:before method=\"printLogBeforeCore\" pointcut-ref=\"logPointCut\"/&gt; &lt;!-- aop:after-returning标签：配置返回通知 --&gt; &lt;!-- returning属性：指定通知方法中用来接收目标方法返回值的参数名 --&gt; &lt;aop:after-returning method=\"printLogAfterCoreSuccess\" pointcut-ref=\"logPointCut\" returning=\"targetMethodReturnValue\"/&gt; &lt;!-- aop:after-throwing标签：配置异常通知 --&gt; &lt;!-- throwing属性：指定通知方法中用来接收目标方法抛出异常的异常对象的参数名 --&gt; &lt;aop:after-throwing method=\"printLogAfterCoreException\" pointcut-ref=\"logPointCut\" throwing=\"targetMethodException\"/&gt; &lt;!-- aop:after标签：配置后置通知 --&gt; &lt;aop:after method=\"printLogCoreFinallyEnd\" pointcut-ref=\"logPointCut\"/&gt; &lt;!-- aop:around标签：配置环绕通知 --&gt; &lt;!--&lt;aop:around method=\"……\" pointcut-ref=\"logPointCut\"/&gt;--&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 3. 测试 @SpringJUnitConfig(locations = \"classpath:spring-aop.xml\") public class AopTest { @Autowired private Calculator calculator; @Test public void testCalculator(){ System.out.println(calculator); calculator.add(1,1); } } 5.7 Spring AOP对获取Bean的影响理解 #### 5.7.1 根据类型装配 bean 1. 情景一 - bean 对应的类没有实现任何接口 - 根据 bean 本身的类型获取 bean - 测试：IOC容器中同类型的 bean 只有一个 正常获取到 IOC 容器中的那个 bean 对象 - 测试：IOC 容器中同类型的 bean 有多个 会抛出 NoUniqueBeanDefinitionException 异常，表示 IOC 容器中这个类型的 bean 有多个 2. 情景二 - bean 对应的类实现了接口，这个接口也只有这一个实现类 - 测试：根据接口类型获取 bean - 测试：根据类获取 bean - 结论：上面两种情况其实都能够正常获取到 bean，而且是同一个对象 3. 情景三 - 声明一个接口 - 接口有多个实现类 - 接口所有实现类都放入 IOC 容器 - 测试：根据接口类型获取 bean 会抛出 NoUniqueBeanDefinitionException 异常，表示 IOC 容器中这个类型的 bean 有多个 - 测试：根据类获取bean 正常 4. 情景四 - 声明一个接口 - 接口有一个实现类 - 创建一个切面类，对上面接口的实现类应用通知 - 测试：根据接口类型获取bean 正常 - 测试：根据类获取bean 无法获取 原因分析： - 应用了切面后，真正放在IOC容器中的是代理类的对象 - 目标类并没有被放到IOC容器中，所以根据目标类的类型从IOC容器中是找不到的 ![](http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img021.3e0da1cc.png) 5. 情景五 - 声明一个类 - 创建一个切面类，对上面的类应用通知 - 测试：根据类获取 bean，能获取到 ![](http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img023.b5696f3e.png)​ debug查看实际类型： ![](http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img024.558f6062.png)​ #### 5.7.2 使用总结 对实现了接口的类应用切面 ![](https://secure2.wostatic.cn/static/dJxjyGJAQazCzzNRQCyPMb/image.png?auth_key=1741057230-rJk1RiVHBHL8vVVHotdEnM-0-b5bf0f554ac296009b34938f437cd967)​ 对没实现接口的类应用切面new ![](https://secure2.wostatic.cn/static/mRgDnd1d6a3oa73t2A7LDK/image.png?auth_key=1741057230-4V3ZCtspM8tykLQ9jwuhq-0-33ab12f263c17e70847c81984e1ea532)​ **如果使用AOP技术，目标类有接口，必须使用接口类型接收IoC容器中代理组件！** 六、Spring 声明式事务 6.1 声明式事务概念 #### 6.1.1 编程式事务 编程式事务是指手动编写程序来管理事务，即通过编写代码的方式直接控制事务的提交和回滚。在 Java 中，通常使用事务管理器(如 Spring 中的 `PlatformTransactionManager`​)来实现编程式事务。 编程式事务的主要优点是灵活性高，可以按照自己的需求来控制事务的粒度、模式等等。但是，编写大量的事务控制代码容易出现问题，对代码的可读性和可维护性有一定影响。 Connection conn = ...; try { // 开启事务：关闭事务的自动提交 conn.setAutoCommit(false); // 核心操作 // 业务代码 // 提交事务 conn.commit(); }catch(Exception e){ // 回滚事务 conn.rollBack(); }finally{ // 释放数据库连接 conn.close(); } 编程式的实现方式存在缺陷： - 细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。 - 代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。 #### 6.1.2 声明式事务 声明式事务是指使用注解或 XML 配置的方式来控制事务的提交和回滚。 开发者只需要添加配置即可， 具体事务的实现由第三方框架实现，避免我们直接进行事务操作！ 使用声明式事务可以将事务的控制和业务逻辑分离开来，提高代码的可读性和可维护性。 区别： - 编程式事务需要手动编写代码来管理事务 - 而声明式事务可以通过配置文件或注解来控制事务。 #### 6.1.3 Spring事务管理器 1. Spring声明式事务对应依赖 - spring-tx: 包含声明式事务实现的基本规范（事务管理器规范接口和事务增强等等） - spring-jdbc: 包含DataSource方式事务管理器实现类DataSourceTransactionManager - spring-orm: 包含其他持久层框架的事务管理器实现类例如：Hibernate/Jpa等 2. Spring声明式事务对应事务管理器接口 ![](https://secure2.wostatic.cn/static/cTpSy6E9Vzq4H8i1x7MLEf/image.png?auth_key=1741057221-nH1CKjn9fQLDrDuarT4MUp-0-9c4c47e547d71ae0f33f7ccb8099de80)​ 我们现在要使用的事务管理器是org.springframework.jdbc.datasource.DataSourceTransactionManager，将来整合 JDBC方式、JdbcTemplate方式、Mybatis方式的事务实现！ DataSourceTransactionManager类中的主要方法： - doBegin()：开启事务 - doSuspend()：挂起事务 - doResume()：恢复挂起的事务 - doCommit()：提交事务 - doRollback()：回滚事务 6.2 基于注解的声明式事务 #### 6.2.1 准备工作 1. 准备项目 &lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库驱动 和 连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 声明式事务依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2. 外部配置文件 jdbc.properties atguigu.url=jdbc:mysql://localhost:3306/studb atguigu.driver=com.mysql.cj.jdbc.Driver atguigu.username=root atguigu.password=root 3. spring配置文件 @Configuration @ComponentScan(\"com.atguigu\") @PropertySource(\"classpath:jdbc.properties\") public class JavaConfig { @Value(\"${atguigu.driver}\") private String driver; @Value(\"${atguigu.url}\") private String url; @Value(\"${atguigu.username}\") private String username; @Value(\"${atguigu.password}\") private String password; //druid连接池 @Bean public DataSource dataSource(){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; } @Bean //jdbcTemplate public JdbcTemplate jdbcTemplate(DataSource dataSource){ JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; } } 4. 准备dao/service层 dao @Repository public class StudentDao { @Autowired private JdbcTemplate jdbcTemplate; public void updateNameById(String name,Integer id){ String sql = \"update students set name = ? where id = ? ;\"; int rows = jdbcTemplate.update(sql, name, id); } public void updateAgeById(Integer age,Integer id){ String sql = \"update students set age = ? where id = ? ;\"; jdbcTemplate.update(sql,age,id); } } service @Service public class StudentService { @Autowired private StudentDao studentDao; public void changeInfo(){ studentDao.updateAgeById(100,1); System.out.println(\"-----------\"); studentDao.updateNameById(\"test1\",1); } } 5. 测试环境搭建 /** * projectName: com.atguigu.test * * description: */ @SpringJUnitConfig(JavaConfig.class) public class TxTest { @Autowired private StudentService studentService; @Test public void testTx(){ studentService.changeInfo(); } } #### 6.2.2 基本事务控制 1. 配置事务管理器 数据库相关的配置 /** * projectName: com.atguigu.config * * description: 数据库和连接池配置类 */ @Configuration @ComponenScan(\"com.atguigu\") @PropertySource(value = \"classpath:jdbc.properties\") @EnableTransactionManagement public class DataSourceConfig { /** * 实例化dataSource加入到ioc容器 * @param url * @param driver * @param username * @param password * @return */ @Bean public DataSource dataSource(@Value(\"${atguigu.url}\")String url, @Value(\"${atguigu.driver}\")String driver, @Value(\"${atguigu.username}\")String username, @Value(\"${atguigu.password}\")String password){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; } /** * 实例化JdbcTemplate对象,需要使用ioc中的DataSource * @param dataSource * @return */ @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource){ JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; } /** * 装配事务管理实现对象 * @param dataSource * @return */ @Bean public TransactionManager transactionManager(DataSource dataSource){ return new DataSourceTransactionManager(dataSource); } } 2. 使用声明事务注解@Transactional /** * projectName: com.atguigu.service * */ @Service public class StudentService { @Autowired private StudentDao studentDao; @Transactional public void changeInfo(){ studentDao.updateAgeById(100,1); System.out.println(\"-----------\"); int i = 1/0; studentDao.updateNameById(\"test1\",1); } } 3. 测试事务效果 /** * projectName: com.atguigu.test * * description: */ //@SpringJUnitConfig(locations = \"classpath:application.xml\") @SpringJUnitConfig(classes = DataSourceConfig.class) public class TxTest { @Autowired private StudentService studentService; @Test public void testTx(){ studentService.changeInfo(); } } #### 6.2.3 事务属性：只读 1. 只读介绍 对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。 2. 设置方式 // readOnly = true把当前事务设置为只读 默认是false! @Transactional(readOnly = true) 3. 针对DML动作设置只读模式 会抛出下面异常： Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed 4. @Transactional注解放在类上 1. 生效原则 如果一个类中每一个方法上都使用了 @Transactional 注解，那么就可以将 @Transactional 注解提取到类上。反过来说：@Transactional 注解在类级别标记，会影响到类中的每一个方法。同时，类级别标记的 @Transactional 注解中设置的事务属性也会延续影响到方法执行时的事务属性。除非在方法上又设置了 @Transactional 注解。 对一个方法来说，离它最近的 @Transactional 注解中的事务属性设置生效。 2. 用法举例 在类级别@Transactional注解中设置只读，这样类中所有的查询方法都不需要设置@Transactional注解了。因为对查询操作来说，其他属性通常不需要设置，所以使用公共设置即可。 然后在这个基础上，对增删改方法设置@Transactional注解 readOnly 属性为 false。 @Service @Transactional(readOnly = true) public class EmpService { // 为了便于核对数据库操作结果，不要修改同一条记录 @Transactional(readOnly = false) public void updateTwice(……) { …… } // readOnly = true把当前事务设置为只读 // @Transactional(readOnly = true) public String getEmpName(Integer empId) { …… } } #### 6.2.4 事务属性：超时时间 1. 需求 事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。 此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。 概括来说就是一句话：超时回滚，释放资源。 2. 设置超时时间 @Service public class StudentService { @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! */ @Transactional(readOnly = false,timeout = 3) public void changeInfo(){ studentDao.updateAgeById(100,1); //休眠4秒,等待方法超时! try { Thread.sleep(4000); } catch (InterruptedException e) { throw new RuntimeException(e); } studentDao.updateNameById(\"test1\",1); } } 3. 测试超时效果 执行抛出事务超时异常 org.springframework.transaction.TransactionTimedOutException: Transaction timed out: deadline was Wed May 24 09:10:43 IRKT 2023 at org.springframework.transaction.support.ResourceHolderSupport.checkTransactionTimeout(ResourceHolderSupport.java:155) at org.springframework.transaction.support.ResourceHolderSupport.getTimeToLiveInMillis(ResourceHolderSupport.java:144) at org.springframework.transaction.support.ResourceHolderSupport.getTimeToLiveInSeconds(ResourceHolderSupport.java:128) at org.springframework.jdbc.datasource.DataSourceUtils.applyTimeout(DataSourceUtils.java:341) at org.springframework.jdbc.core.JdbcTemplate.applyStatementSettings(JdbcTemplate.java:1467) #### 6.2.5 事务属性：事务异常 1. 默认情况 默认只针对运行时异常回滚，编译时异常不回滚。情景模拟代码如下： @Service public class StudentService { @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! */ @Transactional(readOnly = false,timeout = 3) public void changeInfo() throws FileNotFoundException { studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(\"xxxx\"); studentDao.updateNameById(\"test1\",1); } } 2. 设置回滚异常 rollbackFor属性：指定哪些异常类才会回滚,默认是 RuntimeException and Error 异常方可回滚! /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! */ @Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class) public void changeInfo() throws FileNotFoundException { studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(\"xxxx\"); studentDao.updateNameById(\"test1\",1); } 3. 设置不回滚的异常 在默认设置和已有设置的基础上，再指定一个异常类型，碰到它不回滚。 noRollbackFor属性：指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! @Service public class StudentService { @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! */ @Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class,noRollbackFor = FileNotFoundException.class) public void changeInfo() throws FileNotFoundException { studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(\"xxxx\"); studentDao.updateNameById(\"test1\",1); } } #### 6.2.6 事务属性：事务隔离级别 1. 事务隔离级别 数据库事务的隔离级别是指在多个事务并发执行时，数据库系统为了保证数据一致性所遵循的规定。常见的隔离级别包括： 1. 读未提交（Read Uncommitted）：事务可以读取未被提交的数据，容易产生脏读、不可重复读和幻读等问题。实现简单但不太安全，一般不用。 2. 读已提交（Read Committed）：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读。 3. 可重复读（Repeatable Read）：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改。可以避免脏读和不可重复读，但仍有幻读的问题。 4. 串行化（Serializable）：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景。 不同的隔离级别适用于不同的场景，需要根据实际业务需求进行选择和调整。 2. 事务隔离级别设置 package com.atguigu.service; import com.atguigu.dao.StudentDao; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Isolation; import org.springframework.transaction.annotation.Transactional; import java.io.FileInputStream; import java.io.FileNotFoundException; /** * projectName: com.atguigu.service */ @Service public class StudentService { @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! * isolation = 设置事务的隔离级别,mysql默认是repeatable read! */ @Transactional(readOnly = false, timeout = 3, rollbackFor = Exception.class, noRollbackFor = FileNotFoundException.class, isolation = Isolation.REPEATABLE_READ) public void changeInfo() throws FileNotFoundException { studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(\"xxxx\"); studentDao.updateNameById(\"test1\",1); } } #### 6.2.7 事务属性：事务传播行为 1. 事务传播行为要研究的问题 ![](https://secure2.wostatic.cn/static/t9aMhzWSt1v8HnQy7Uaoui/img012.png?auth_key=1741057217-2bJNuoDoxyw1eXtybfqiAB-0-8716a5782accb0e653c05d597d9740b1)​ 举例代码： @Transactional public void MethodA(){ // ... MethodB(); // ... } //在被调用的子方法中设置传播行为，代表如何处理调用的事务！ 是加入，还是新事务等！ @Transactional(propagation = Propagation.REQUIRES_NEW) public void MethodB(){ // ... } 2. propagation属性 @Transactional 注解通过 propagation 属性设置事务的传播行为。它的默认值是： Propagation propagation() default Propagation.REQUIRED; propagation 属性的可选值由 org.springframework.transaction.annotation.Propagation 枚举类提供： 名称 含义 REQUIRED 默认值 如果父方法有事务，就加入，如果没有就新建自己独立！ REQUIRES_NEW 不管父方法是否有事务，我都新建事务，都是独立的！ 3. 测试 1. 声明两个业务方法 @Service public class StudentService { @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! * isolation = 设置事务的隔离级别,mysql默认是repeatable read! */ @Transactional(readOnly = false, timeout = 3, rollbackFor = Exception.class, noRollbackFor = FileNotFoundException.class, isolation = Isolation.REPEATABLE_READ) public void changeInfo() throws FileNotFoundException { studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(\"xxxx\"); studentDao.updateNameById(\"test1\",1); } /** * 声明两个独立修改数据库的事务业务方法 */ @Transactional(propagation = Propagation.REQUIRED) public void changeAge(){ studentDao.updateAgeById(99,1); } @Transactional(propagation = Propagation.REQUIRED) public void changeName(){ studentDao.updateNameById(\"test2\",1); int i = 1/0; } } 2. 声明一个整合业务方法 @Service public class TopService { @Autowired private StudentService studentService; @Transactional public void topService(){ studentService.changeAge(); studentService.changeName(); } } 3. 添加传播行为测试 @SpringJUnitConfig(classes = AppConfig.class) public class TxTest { @Autowired private StudentService studentService; @Autowired private TopService topService; @Test public void testTx() throws FileNotFoundException { topService.topService(); } } **注意：** 在同一个类中，对于@Transactional注解的方法调用，事务传播行为不会生效。这是因为Spring框架中使用代理模式实现了事务机制，在同一个类中的方法调用并不经过代理，而是通过对象的方法调用，因此@Transactional注解的设置不会被代理捕获，也就不会产生任何事务传播行为的效果。 4. 其他传播行为值（了解） 1. Propagation.REQUIRED：如果当前存在事务，则加入当前事务，否则创建一个新事务。 2. Propagation.REQUIRES_NEW：创建一个新事务，并在新事务中执行。如果当前存在事务，则挂起当前事务，即使新事务抛出异常，也不会影响当前事务。 3. Propagation.NESTED：如果当前存在事务，则在该事务中嵌套一个新事务，如果没有事务，则与Propagation.REQUIRED一样。 4. Propagation.SUPPORTS：如果当前存在事务，则加入该事务，否则以非事务方式执行。 5. Propagation.NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，挂起该事务。 6. Propagation.MANDATORY：必须在一个已有的事务中执行，否则抛出异常。 7. Propagation.NEVER：必须在没有事务的情况下执行，否则抛出异常。 七、Spring核心掌握总结     核心点 掌握目标 spring框架理解 spring家族和spring framework框架 spring核心功能 ioc/di , aop , tx spring ioc / di 组件管理、ioc容器、ioc/di , 三种配置方式 spring aop aop和aop框架和代理技术、基于注解的aop配置 spring tx 声明式和编程式事务、动态事务管理器、事务注解、属性 " }, { "title": "Maven", "url": "/posts/maven/", "categories": "Maven", "tags": "spring, sql, framework, mybatis, java, javascript, maven", "date": "2024-11-12 10:44:29 +0800", "content": " Maven 一、Maven简介和快速入门 1.1 Maven介绍 1.2 Maven主要作用理解 1.3 Maven安装和配置 二、基于IDEA的Maven工程创建 2.1梳理Maven工程GAVP属性 2.2 Idea构建Maven JavaSE工程 2.3 Idea构建Maven JavaEE工程 2.4 Maven工程项目结构说明 三、Maven核心功能依赖和构建管理 3.1 依赖管理和配置 3.2依赖传递和冲突 3.3 依赖导入失败场景和解决方案 3.4 扩展构建管理和插件配置 四、Maven继承和聚合特性 4.1 Maven工程继承关系 4.2 Maven工程聚合关系 五、Maven实战案例：搭建微服务Maven工程架构 5.1 项目需求和结构分析 5.2项目搭建和统一构建 六、Maven核心掌握总结 Maven 一、Maven简介和快速入门 1.1 Maven介绍 https://maven.apache.org/what-is-maven.html Maven 是一款为 Java 项目构建管理、依赖管理的工具（**软件**），使用 Maven 可以自动化构建、测试、打包和发布项目，大大提高了开发效率和质量。 总结：Maven就是一个软件，掌握软件安装、配置、以及基本功能 **（项目构建、依赖管理）** 使用就是本课程的主要目标！ 1.2 Maven主要作用理解 1. 场景概念 **场景1：** 例如我们项目需要第三方库（依赖），如Druid连接池、MySQL数据库驱动和Jackson等。那么我们可以将需要的依赖项的信息编写到Maven工程的配置文件，Maven软件就会自动下载并复制这些依赖项到项目中，也会自动下载依赖需要的依赖！确保依赖版本正确无冲突和依赖完整！ **场景2：** 项目开发完成后，想要将项目打成.war文件，并部署到服务器中运行，使用Maven软件，我们可以通过一行构建命令（mvn package）快速项目构建和打包！节省大量时间！ 2. **依赖管理：** Maven 可以管理项目的依赖，包括自动下载所需依赖库、自动下载依赖需要的依赖并且保证版本没有冲突、依赖版本管理等。通过 Maven，我们可以方便地维护项目所依赖的外部库，而我们仅仅需要编写配置即可。 3. **构建管理：** 项目构建是指将源代码、配置文件、资源文件等转化为能够运行或部署的应用程序或库的过程！ Maven 可以管理项目的编译、测试、打包、部署等构建过程。通过实现标准的构建生命周期，Maven 可以确保每一个构建过程都遵循同样的规则和最佳实践。同时，Maven 的插件机制也使得开发者可以对构建过程进行扩展和定制。主动触发构建，只需要简单的命令操作即可。 ![](https://secure2.wostatic.cn/static/7crHSdhCetVYi4F1JxGLhz/image.png?auth_key=1741057006-jVQ4ARmSvtcakP7pn83xea-0-4015989493563fa674f9a6e8ffdb3564)​ 1.3 Maven安装和配置 https://maven.apache.org/docs/history.html 选用版本： 发布时间 maven版本 jdk最低版本 **2019 - 11 - **25 3.6. 3 Java 7 1. 安装 **安装条件：** maven需要本机安装java环境、必需包含java_home环境变量！ **软件安装：** 右键解压即可（绿色免安装） **软件结构：** ![](https://secure2.wostatic.cn/static/8ejDwZkzK2uywsn98zaPnN/image.png?auth_key=1741057005-csZFp7xotgMkRPLhGsMpzK-0-ce9c757e4ca7cbe7d3e9d34430d8c56b) 2. 环境变量 **环境变量：** 配置maven_home 和 path ![](https://secure2.wostatic.cn/static/c4JPvhLTYs5r4w4BKykMH7/image.png?auth_key=1741057005-8oBEp5TJzxhKwC5eYTetBi-0-a62504f0860d1698310abc0cfc6d1829)​ ![](https://secure2.wostatic.cn/static/3V7mbfetmPg69QRTmFUNhN/image.png?auth_key=1741057005-hYDLS4VVWkoyqzebd7CSvN-0-1b9747b99442bdfcc7fce9127839fa35) 3. 命令测试 mvn -v # 输出版本信息即可，如果错误，请仔细检查环境变量即可！ # 友好提示，如果此处错误，绝大部分原因都是java_home变量的事，请仔细检查！！ 4. 配置文件 &gt; 我们需要需改**maven/conf/settings.xml**配置文件，来修改maven的一些默认配置。我们主要休要修改的有三个配置：1.依赖本地缓存位置（本地仓库位置）2.maven下载镜像3.maven选用编译项目的jdk版本！ 1. 配置本地仓库地址 &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: ${user.home}/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt; &lt;!-- conf/settings.xml 55行 --&gt; &lt;localRepository&gt;D:\\repository&lt;/localRepository&gt; 2. 配置国内阿里镜像 &lt;!--在mirrors节点(标签)下添加中央仓库镜像 160行附近--&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 3. 配置jdk17版本项目构建 &lt;!--在profiles节点(标签)下添加jdk编译版本 268行附近--&gt; &lt;profile&gt; &lt;id&gt;jdk-17&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;17&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;17&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; 5. idea配置本地maven &gt; 我们需要将配置好的maven软件，配置到idea开发工具中即可！ 注意：idea工具默认自带maven配置软件，但是因为没有修改配置，建议替换成本地配置好的maven！ 1. 打开idea配置文件，构建工具配置 依次点击 file / settings / build / build tool / maven 2. 选中本地maven软件 ![](https://secure2.wostatic.cn/static/qwwv17NrU5W6zJbLNujS2k/image.png?auth_key=1741057005-jjHVrLctY2DEec5QjMfznm-0-2db35bcfade707b0e232eb41cd54f15a) 3. 测试是否配置成功 **注意**：如果本地仓库地址不变化，只有一个原因，就是maven/conf/settings.xml配置文件编写错误！仔细检查即可！ ![](https://secure2.wostatic.cn/static/3ZSrj9TMYDEQMKY37csyNc/image.png?auth_key=1741057005-8cqbAPAKVG5nC9VF73NWKN-0-3b37e699ef8eda337e0629478a962ae8)​ 二、基于IDEA的Maven工程创建 2.1梳理Maven工程GAVP属性 &gt; Maven工程相对之前的工程，多出一组gavp属性，gav需要我们在创建项目的时指定，p有默认值，后期通过配置文件修改。既然要填写的属性，我们先行了解下这组属性的含义! Maven 中的 GAVP 是指 GroupId、ArtifactId、Version、Packaging 等四个属性的缩写，其中前三个是必要的，而 Packaging 属性为可选项。这四个属性主要为每个项目在maven仓库总做一个标识，类似人的《姓-名》。有了具体标识，方便maven软件对项目进行管理和互相引用！ **GAV遵循一下规则：** 1） **GroupID 格式**：com.{公司/BU }.业务线.[子业务线]，最多 4 级。 说明：{公司/BU} 例如：alibaba/taobao/tmall/aliexpress 等 BU 一级；子业务线可选。 正例：com.taobao.tddl 或 com.alibaba.sourcing.multilang com.atguigu.java 2） **ArtifactID 格式**：产品线名-模块名。语义不重复不遗漏，先到仓库中心去查证一下。 正例：tc-client / uic-api / tair-tool / bookstore 3） **Version版本号格式推荐**：主版本号.次版本号.修订号 1.0.0 1） 主版本号：当做了不兼容的 API 修改，或者增加了能改变产品方向的新功能。 2） 次版本号：当做了向下兼容的功能性新增（新增类、接口等）。 3） 修订号：修复 bug，没有修改方法签名的功能加强，保持 API 兼容性。 例如： 初始→1.0.0 修改bug → 1.0.1 功能调整 → 1.1.1等 **Packaging定义规则：** 指示将项目打包为什么类型的文件，idea根据packaging值，识别maven项目类型！ packaging 属性为 jar（默认值），代表普通的Java工程，打包以后是.jar结尾的文件。 packaging 属性为 war，代表Java的web工程，打包以后.war结尾的文件。 packaging 属性为 pom，代表不会打包，用来做继承的父工程。 2.2 Idea构建Maven JavaSE工程 注意：此处省略了version，直接给了一个默认值&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; 自己后期可以在项目中随意修改！ ![](https://secure2.wostatic.cn/static/oDo2HDrVXHoKqfqRdqLKuV/image.png?auth_key=1741057002-7HVeSsgee9VmvPJ7H4zc77-0-a51b4c51d2cfd760d3baf7948be4ad0a)​ 2.3 Idea构建Maven JavaEE工程 1. 手动创建 1. 创建一个javasemaven工程 2. 手动添加web项目结构文件 注意：结构和命名固定 ![](https://secure2.wostatic.cn/static/2iYsG44sjYayNqY7t9WtrZ/image.png?auth_key=1741057002-3ibsC8NDEgjCQMhzwp2w5Q-0-737270092beaf53b3873447d7521f150) 3. 修改pom.xml文件打包方式 修改位置：项目下/pom.xml &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;maven_parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 新增一列打包方式packaging --&gt; &lt;packaging&gt;war&lt;/packaging&gt; 4. 刷新和校验 ![](https://secure2.wostatic.cn/static/CEhMC5eswYp2GhyYQwnry/image.png?auth_key=1741057002-tqmnmkC9ce8AXiT1XLv1vd-0-490a6f4ebae58c20b45006a48875353f)​ ![](https://secure2.wostatic.cn/static/haCWoNhTmZaQEzd3T8GmRu/image.png?auth_key=1741057002-faTYruX5Dy895b5JNQLXoS-0-1091ef2ec370a5e8d0a023184bfea185)​ 项目的webapp文件夹出现小蓝点，代表成功！！ 2. 插件方式创建 1. 安装插件JBLJavaToWeb file / settings / plugins / marketplace ![](https://secure2.wostatic.cn/static/dfWTRgLdpDLHj7triTW9nM/image.png?auth_key=1741057002-ad58ZcoBuifoQ7k1WDZ4UV-0-85c418409aacbc46e01837626b827a23) 2. 创建一个javasemaven工程 3. 右键、使用插件快速补全web项目 ![](https://secure2.wostatic.cn/static/vdNw6jnGT7r7CXUji3j7ah/image.png?auth_key=1741057002-ufvPwZpzztx6pv58rWRwQG-0-655d67850b1fb0e1b18ee4d5aaf92694)​ 2.4 Maven工程项目结构说明 Maven 是一个强大的构建工具，它提供一种标准化的项目结构，可以帮助开发者更容易地管理项目的依赖、构建、测试和发布等任务。以下是 Maven Web 程序的文件结构及每个文件的作用： |-- pom.xml # Maven 项目管理文件 |-- src |-- main # 项目主要代码 | |-- java # Java 源代码目录 | | `-- com/example/myapp # 开发者代码主目录 | | |-- controller # 存放 Controller 层代码的目录 | | |-- service # 存放 Service 层代码的目录 | | |-- dao # 存放 DAO 层代码的目录 | | `-- model # 存放数据模型的目录 | |-- resources # 资源目录，存放配置文件、静态资源等 | | |-- log4j.properties # 日志配置文件 | | |-- spring-mybatis.xml # Spring Mybatis 配置文件 | | `-- static # 存放静态资源的目录 | | |-- css # 存放 CSS 文件的目录 | | |-- js # 存放 JavaScript 文件的目录 | | `-- images # 存放图片资源的目录 | `-- webapp # 存放 WEB 相关配置和资源 | |-- WEB-INF # 存放 WEB 应用配置文件 | | |-- web.xml # Web 应用的部署描述文件 | | `-- classes # 存放编译后的 class 文件 | `-- index.html # Web 应用入口页面 `-- test # 项目测试代码 |-- java # 单元测试目录 `-- resources # 测试资源目录 - pom.xml：Maven 项目管理文件，用于描述项目的依赖和构建配置等信息。 - src/main/java：存放项目的 Java 源代码。 - src/main/resources：存放项目的资源文件，如配置文件、静态资源等。 - src/main/webapp/WEB-INF：存放 Web 应用的配置文件。 - src/main/webapp/index.html：Web 应用的入口页面。 - src/test/java：存放项目的测试代码。 - src/test/resources：存放测试相关的资源文件，如测试配置文件等。 三、Maven核心功能依赖和构建管理 3.1 依赖管理和配置 Maven 依赖管理是 Maven 软件中最重要的功能之一。Maven 的依赖管理能够帮助开发人员自动解决软件包依赖问题，使得开发人员能够轻松地将其他开发人员开发的模块或第三方框架集成到自己的应用程序或模块中，避免出现版本冲突和依赖缺失等问题。 我们通过定义 POM 文件，Maven 能够自动解析项目的依赖关系，并通过 Maven **仓库自动**下载和管理依赖，从而避免了手动下载和管理依赖的繁琐工作和可能引发的版本冲突问题。 重点: 编写pom.xml文件! maven项目信息属性配置和读取： &lt;!-- 模型版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt; &lt;groupId&gt;com.companyname.project-group&lt;/groupId&gt; &lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt; &lt;artifactId&gt;project&lt;/artifactId&gt; &lt;!-- 版本号 --&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;!--打包方式 默认：jar jar指的是普通的java项目打包方式！ 项目打成jar包！ war指的是web项目打包方式！项目打成war包！ pom不会讲项目打包！这个项目作为父工程，被其他工程聚合或者继承！后面会讲解两个概念 --&gt; &lt;packaging&gt;jar/pom/war&lt;/packaging&gt; 依赖管理和添加： &lt;!-- 通过编写依赖jar包的gav必要属性，引入第三方依赖！ scope属性是可选的，可以指定依赖生效范围！ 依赖信息查询方式： 1. maven仓库信息官网 https://mvnrepository.com/ 2. mavensearch插件搜索 --&gt; &lt;dependencies&gt; &lt;!-- 引入具体的依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;!-- 生效范围 - compile ：main目录 test目录 打包打包 [默认] - provided：main目录 test目录 Servlet - runtime： 打包运行 MySQL - test: test目录 junit --&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 依赖版本提取和维护: &lt;!--声明版本--&gt; &lt;properties&gt; &lt;!--命名随便,内部制定版本号即可！--&gt; &lt;junit.version&gt;4.11&lt;/junit.version&gt; &lt;!-- 也可以通过 maven规定的固定的key，配置maven的参数！如下配置编码格式！--&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!--引用properties声明版本 --&gt; &lt;version&gt;${junit.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3.2依赖传递和冲突 **依赖传递**指的是当一个模块或库 A 依赖于另一个模块或库 B，而 B 又依赖于模块或库 C，那么 A 会间接依赖于 C。这种依赖传递结构可以形成一个依赖树。当我们引入一个库或框架时，构建工具（如 Maven、Gradle）会自动解析和加载其所有的直接和间接依赖，确保这些依赖都可用。 依赖传递的作用是： 1. 减少重复依赖：当多个项目依赖同一个库时，Maven 可以自动下载并且只下载一次该库。这样可以减少项目的构建时间和磁盘空间。 2. 自动管理依赖: Maven 可以自动管理依赖项，使用依赖传递，简化了依赖项的管理，使项目构建更加可靠和一致。 3. 确保依赖版本正确性：通过依赖传递的依赖，之间都不会存在版本兼容性问题，确实依赖的版本正确性！ 依赖传递演示： 项目中，需要导入jackson相关的依赖，通过之前导入经验，jackson需要导入三个依赖，分别为： ![](https://secure2.wostatic.cn/static/463a23mzkd1mo97Fm1rhpS/image.png?auth_key=1741056998-kg8diukjXk3iSLBsDqT8fV-0-f27edda65db78fa63299e2aeb9c4fdfb)​ 通过查看网站介绍的依赖传递特性：data-bind中，依赖其他两个依赖 ![](https://secure2.wostatic.cn/static/m8TKvDS5fj34z334a6jPxz/image.png?auth_key=1741056998-viLNQmACvtZGqxPCcyaMuK-0-20f8bb875f71d785c8dee932bc58c3a2)​ 最佳导入：直接可以导入data-bind，自动依赖传递需要的依赖 &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.15.0&lt;/version&gt; &lt;/dependency&gt; 依赖冲突演示： 当直接引用或者间接引用出现了相同的jar包! 这时呢，一个项目就会出现相同的重复jar包，这就算作冲突！依赖冲突避免出现重复依赖，并且终止依赖传递！ ![](https://secure2.wostatic.cn/static/4C2G8BJGLJ4pzmWoGs1Woi/image.png?auth_key=1741056998-mhWqHZ97hGaziiVPf12SSC-0-4d8e972037b6d0a8c9ee4230e7635a2c)​ maven自动解决依赖冲突问题能力，会按照自己的原则，进行重复依赖选择。同时也提供了手动解决的冲突的方式，不过不推荐！ 解决依赖冲突（如何选择重复依赖）方式： 1. 自动选择原则 - 短路优先原则（第一原则） A—&gt;B—&gt;C—&gt;D—&gt;E—&gt;X(version 0.0.1) A—&gt;F—&gt;X(version 0.0.2) 则A依赖于X(version 0.0.2)。 - 依赖路径长度相同情况下，则“先声明优先”（第二原则） A—&gt;E—&gt;X(version 0.0.1) A—&gt;F—&gt;X(version 0.0.2) 在&lt;depencies&gt;&lt;/depencies&gt;中，先声明的，路径相同，会优先选择！ 小思考: 前提： A 1.1 -&gt; B 1.1 -&gt; C 1.1 F 2.2 -&gt; B 2.2 pom声明： F 2.2 A 1.1 B 2.2 3.3 依赖导入失败场景和解决方案 在使用 Maven 构建项目时，可能会发生依赖项下载错误的情况，主要原因有以下几种： 1. 下载依赖时出现网络故障或仓库服务器宕机等原因，导致无法连接至 Maven 仓库，从而无法下载依赖。 2. 依赖项的版本号或配置文件中的版本号错误，或者依赖项没有正确定义，导致 Maven 下载的依赖项与实际需要的不一致，从而引发错误。 3. 本地 Maven 仓库或缓存被污染或损坏，导致 Maven 无法正确地使用现有的依赖项，并且也无法重新下载！ 解决方案： 1. 检查网络连接和 Maven 仓库服务器状态。 2. 确保依赖项的版本号与项目对应的版本号匹配，并检查 POM 文件中的依赖项是否正确。 3. 清除本地 Maven 仓库缓存（lastUpdated 文件），因为只要存在lastupdated缓存文件，刷新也不会重新下载。本地仓库中，根据依赖的gav属性依次向下查找文件夹，最终删除内部的文件，刷新重新下载即可！ 例如： pom.xml依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; 文件： ![](https://secure2.wostatic.cn/static/6mSDgf4nkaRLAu16dqSJk7/image.png?auth_key=1741056997-mgmqjYGo3uJUey9Y59BEEL-0-bc8dd06acf1761f07719af662d64b7ac)​ 脚本使用： 使用记事本打开 set REPOSITORY_PATH=D:\\repository 改成你本地仓库地址即可！ 点击运行脚本，即可自动清理本地错误缓存文件！！ 3.4 扩展构建管理和插件配置 **构建概念:** 项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。 ![](https://secure2.wostatic.cn/static/hDM25DDDzZrYFzhfiwTWVk/image.png?auth_key=1741056995-8ei6PfeaXRZ2gTsVVxgBDY-0-f576d9c9588e9448864c3417d71d18c6)​ **主动触发场景：** - 重新编译 : 编译不充分, 部分文件没有被编译! - 打包 : 独立部署到外部服务器软件,打包部署 - 部署本地或者私服仓库 : maven工程加入到本地或者私服仓库,供其他工程使用 **命令方式构建:** 语法: mvn 构建命令 构建命令.... 命令 描述 mvn clean 清理编译或打包后的项目结构,删除target文件夹 mvn compile 编译项目，生成target文件 mvn test 执行测试源码 (测试) mvn site 生成一个项目依赖信息的展示页面 mvn package 打包项目，生成war / jar 文件 mvn install 打包后上传到maven本地仓库(本地部署) mvn deploy 只打包，上传到maven私服仓库(私服部署) **可视化方式构建:** ![](https://secure2.wostatic.cn/static/85Cv2rhHoFN4C9JgJzVdho/image.png?auth_key=1741056995-ef18oyiKZw3hdSPMBiGNmA-0-4273d37d9bf393f0a776f3600fdbec6c)​ **构建命令周期:** 构建生命周期可以理解成是一组固定构建命令的有序集合，触发周期后的命令，会自动触发周期前的命令！也是一种简化构建的思路! - 清理周期：主要是对项目编译生成文件进行清理 包含命令：clean - 默认周期：定义了真正构件时所需要执行的所有步骤，它是生命周期中最核心的部分 包含命令：compile - test - package - install / deploy - 报告周期 包含命令：site 打包: mvn clean package 本地仓库: mvn clean install **最佳使用方案:** 打包: mvn clean package 重新编译: mvn clean compile 本地部署: mvn clean install **周期，命令和插件:** 周期→包含若干命令→包含若干插件! 使用周期命令构建，简化构建过程！ 最终进行构建的是插件！ 插件配置: &lt;build&gt; &lt;!-- jdk17 和 war包版本插件不匹配 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 四、Maven继承和聚合特性 4.1 Maven工程继承关系 1. 继承概念 Maven 继承是指在 Maven 的项目中，让一个项目从另一个项目中继承配置信息的机制。继承可以让我们在多个项目中共享同一配置信息，简化项目的管理和维护工作。 ![](https://secure2.wostatic.cn/static/ooGfu99ezNBaguhLkwT4Z4/image.png?auth_key=1741056977-7WhNd2VbMtFXNr9EeLRWE5-0-5ac7d8c03cb867fef69a3b02dd5abb5d) 2. 继承作用 作用：在父工程中统一管理项目中的依赖信息,进行统一版本管理! 它的背景是： - 对一个比较大型的项目进行了模块拆分。 - 一个 project 下面，创建了很多个 module。 - 每一个 module 都需要配置自己的依赖信息。 它背后的需求是： - 多个模块要使用同一个框架，它们应该是同一个版本，所以整个项目中使用的框架版本需要统一管理。 - 使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。 通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范、准确的 jar 包；又能够将以往的经验沉淀下来，节约时间和精力。 3. 继承语法 - 父工程 &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt; &lt;packaging&gt;pom&lt;/packaging&gt; - 子工程 &lt;!-- 使用parent标签指定当前工程的父工程 --&gt; &lt;parent&gt; &lt;!-- 父工程的坐标 --&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;!-- 子工程的坐标 --&gt; &lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt; &lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt; &lt;artifactId&gt;pro04-maven-module&lt;/artifactId&gt; &lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt; 4. 父工程依赖统一管理 - 父工程声明版本 &lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt; &lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; - 子工程引用版本 &lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。 --&gt; &lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt; &lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 4.2 Maven工程聚合关系 1. 聚合概念 Maven 聚合是指将多个项目组织到一个父级项目中，通过触发父工程的构建,统一按顺序触发子工程构建的过程!! 2. 聚合作用 1. 统一管理子项目构建：通过聚合，可以将多个子项目组织在一起，方便管理和维护。 2. 优化构建顺序：通过聚合，可以对多个项目进行顺序控制，避免出现构建依赖混乱导致构建失败的情况。 3. 聚合语法 父项目中包含的子项目列表。 &lt;project&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;parent-project&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;modules&gt; &lt;module&gt;child-project1&lt;/module&gt; &lt;module&gt;child-project2&lt;/module&gt; &lt;/modules&gt; &lt;/project&gt; 4. 聚合演示 通过触发父工程构建命令、引发所有子模块构建！产生反应堆！ ![](https://secure2.wostatic.cn/static/weyQ7odFa3amf3NTtCgyjQ/image.png?auth_key=1741056976-jRZc8Lb9vLzcQt5nVVyucn-0-cce57baaa883cfc566ef867a530e1bcc)​ 五、Maven实战案例：搭建微服务Maven工程架构 5.1 项目需求和结构分析 ![](https://secure2.wostatic.cn/static/55JDMJtqJgk1V39q31237Q/image.png?auth_key=1741054104-mpm5qkPuCkGF737P1seDi5-0-ba3f0b0d598cff5dab08b9e3b1dd58d3)​ 需求案例：搭建一个电商平台项目，该平台包括用户服务、订单服务、通用工具模块等。 项目架构： 1. 用户服务：负责处理用户相关的逻辑，例如用户信息的管理、用户注册、登录等。 2. 订单服务：负责处理订单相关的逻辑，例如订单的创建、订单支付、退货、订单查看等。 3. 通用模块：负责存储其他服务需要通用工具类，其他服务依赖此模块。 服务依赖： 1. 用户服务 (1.0.1) - spring-context 6.0.6 - spring-core 6.0.6 - spring-beans 6.0.6 - jackson-databind / jackson-core / jackson-annotations 2.15.0 2. 订单服务 (1.0.1) 1. shiro-core 1.10.1 2. spring-context 6.0.6 3. spring-core 6.0.6 4. spring-beans 6.0.6 3. 通用模块 (1.0.1) 1. commons-io 2.11.0 5.2项目搭建和统一构建 1. 父模块搭建 (micro-shop) 1. 创建父工程 ![](https://secure2.wostatic.cn/static/q4ub49tpGULm7q2tLaTu1J/image.png?auth_key=1741054102-kU6SHB6gi8UpvjZMxURDFk-0-a1794730bc5293a7a95012cddca601ce) 2. pom.xml配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;micro-shop&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;!-- 父工程不打包，所以选择pom值--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;spring.version&gt;6.0.6&lt;/spring.version&gt; &lt;jackson.version&gt;2.15.0&lt;/jackson.version&gt; &lt;shiro.version&gt;1.10.1&lt;/shiro.version&gt; &lt;commons.version&gt;2.11.0&lt;/commons.version&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;!-- 依赖管理 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- spring-context会依赖传递core/beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jackson-databind会依赖传递core/annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;${jackson.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- shiro-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;${shiro.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- commons-io --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;${commons.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 父工程添加依赖，会自动传递给所有子工程，不推荐！ --&gt; &lt;/dependencies&gt; &lt;!-- 统一更新子工程打包插件--&gt; &lt;build&gt; &lt;!-- jdk17 和 war包版本插件不匹配 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 2. 通用模块 (common-service) 1. 创建模块 ![](https://secure2.wostatic.cn/static/s29BZ1jzoRgncf5dY8Zecx/image.png?auth_key=1741054102-pVUYQ1A5UE6YndxBy5a2Vt-0-44b411eabdaf15350ca9ec6d38ebdd0c)​ ![](https://secure2.wostatic.cn/static/uJF4JRuQqi7GxHtSPEq8Mi/image.png?auth_key=1741054102-8QuAxYKktAMqTS679fJRYr-0-018be83c63ce178e61a5c4dabfecc520) 2. pom.xml配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;micro-shop&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;common-service&lt;/artifactId&gt; &lt;!-- 打包方式默认就是jar！ --&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 声明commons-io，继承父工程版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 3. 用户模块 (user-service) 1. 创建模块 ![](https://secure2.wostatic.cn/static/feDvXd6JWZWLf3MiP1GbQC/image.png?auth_key=1741054102-uDgGUU3wEM1xSg2WNru6EL-0-beac971bd21689c622d01edc9812ea7b)​ ![](https://secure2.wostatic.cn/static/qxywuU1jKc2rpyn68nGtfU/image.png?auth_key=1741054102-8Wmzkzmct3SaT8puVyPs1W-0-8ffc9334dce95dbc5d73e44634ef55c1) 2. pom.xml配置 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;micro-shop&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;user-service&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 添加spring-context 自动传递 core / beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 添加jackson-databind 自动传递 core / annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 4. 订单模块 (order-service) 1. 创建模块 ![](https://secure2.wostatic.cn/static/gRxngf1p153nByr6Fpp46T/image.png?auth_key=1741054102-fkaiFejiwhTnkF7quXddNQ-0-0c80860bb36a044cfd8b0c238cd0aba4)​ ![](https://secure2.wostatic.cn/static/qxywuU1jKc2rpyn68nGtfU/image.png?auth_key=1741054102-pRVNp9gBBaKM9CLJ8385QJ-0-049c7ee8fe212e9f0fae7c99aad30953) 2. pom.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;micro-shop&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;order-service&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 继承父工程依赖版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 继承父工程依赖版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 六、Maven核心掌握总结     核心点 掌握目标 安装 maven安装、环境变量、maven配置文件修改 工程创建 gavp属性理解、JavaSE/EE工程创建、项目结构 依赖管理 依赖添加、依赖传递、版本提取、导入依赖错误解决 构建管理 构建过程、构建场景、构建周期等 继承和聚合 理解继承和聚合作用、继承语法和实践、聚合语法和实践 " }, { "title": "HTTP协议", "url": "/post/http-protocol-z1vjgkd.html", "categories": "", "tags": "", "date": "2024-08-02 20:56:28 +0800", "content": "‍ IP协议 TCP 协议 TCP 三次握手 每次握手存在的价值 SYN -&gt; 客户端告知服务器，自己有发送数据的能力 SYN/ACK-&gt; 标识 服务器通知客户端自己有 收发数据的能力 ACK -&gt; 客户端告知自己能收到数据 在TCP（传输控制协议）中，SYN 和 ACK 是两个重要的标志符，用于建立和确认连接。它们分别代表： SYN：Synchronize（同步） ACK：Acknowledge（确认） 具体作用 SYN（Synchronize） ： 当客户端希望与服务器建立连接时，首先发送一个带有 SYN 标志的包，表示请求同步序列号以开始连接。这是三次握手过程的第一步。 ACK（Acknowledge） ： ACK 标志用于确认接收到的数据包。每当一方收到数据包时，会发送一个带有 ACK 标志的包，告知发送方数据已成功接收。 三次握手过程 参考： https://www.bilibili.com/video/BV1kV411j7hA?spm_id_from=333.788.videopod.sections&amp;vd_source=4f9d828ef6e4359eafd9b7b64eae9b9f TCP 连接的建立过程称为三次握手，具体步骤如下： 第一次握手：客户端发送一个带有 SYN 标志的包，表示请求建立连接，并同步序列号。 第二次握手：服务器收到 SYN 包后，回复一个带有 SYN 和 ACK 标志的包，表示同意建立连接，并确认客户端的 SYN 包。 第三次握手：客户端收到服务器的 SYN+ACK 包后，回复一个带有 ACK 标志的包，表示确认连接建立。 DNS 负责提供域名到IP地址的解析服务 各协议的协同关系 HTTPS HTTP 协议 安全性不足 ‍ HTTP URL与URI URI(Uniform Resource Identifier) ,统一资源标识符。 URL(Uniform Resource Locator),统一资源定位符， 也就是网址 URL 是URI 的子集。 HTTP 报文的构成 KEEP-ALIVE 在HTTP请求头中，Keep-Alive​ 是一个用于控制TCP连接保持活跃状态的机制。它的主要作用包括： 保持连接： ​Keep-Alive​ 允许客户端和服务器在完成一次请求-响应后保持TCP连接，而不是关闭连接。这有助于在后续的请求中重用同一个连接，减少了连接建立和关闭的开销。 提高性能： 通过保持连接，Keep-Alive​ 减少了创建新连接所需的时间和资源，从而提高了网络通信的效率和性能。这对于需要频繁请求资源的应用尤其有用，例如网页加载过程中需要加载多个资源（如图片、样式表、脚本等）。 减少延迟： 由于不需要为每个请求重新建立连接，Keep-Alive​ 可以显著减少请求的延迟，提升用户体验。 工作原理 请求头： 客户端在HTTP请求头中包含 Connection: keep-alive​ 字段，表示希望保持连接。 响应头： 服务器在响应头中包含 Connection: keep-alive​ 字段，表示同意保持连接。 Keep-Alive头： ​Keep-Alive​ 头可以包含两个可选参数来控制连接的保持时间和最大请求数： ​timeout​：指定连接保持活跃的时间（以秒为单位）。 ​max​：指定在关闭连接之前允许的最大请求数。 请求方法 Trace 可以跟踪请求经过的路径 常用状态码 204 和206 一般是出现在分段的返回中，一般是返回较大的资源中出现 301 永久重定向 ，302临时重定向 HTTP协议头参数 无状态和Cookie_Session_Token " }, { "title": "Welcome to My Tech Journey", "url": "/posts/welcome/", "categories": "公告", "tags": "博客, 欢迎", "date": "2024-03-11 12:00:00 +0800", "content": "关于我 热衷于技术探索和工程实践的全栈开发者，专注于游戏开发与服务端架构。持续学习，乐于分享，用代码构建有趣的数字世界。 技术栈 游戏开发 Unity 客户端开发 游戏性能优化 游戏架构设计 Lua 脚本开发 服务端开发 Java 企业级应用开发 Spring Framework 生态系统 高性能数据库设计 (MySQL, Redis) 分布式系统架构 akka 核心技能 编程语言：Java, C#, Lua 数据库：MySQL, Redis 开发工具：Git unity 逆向 博客内容 这里记录了我在技术探索过程中的： 学习笔记与心得 项目实践经验 技术难点解决方案 系统架构设计思考 性能优化案例分析 更新计划 持续分享以下领域的内容： Unity 游戏开发实践 java 服务器相关技术 数据库 分布式系统设计 性能调优实战 AI 与实践 欢迎交流与讨论！ " }, { "title": "cursor白嫖", "url": "/posts/free-cursor/", "categories": "AI", "tags": "cursor, 白嫖", "date": "2021-10-08 09:36:00 +0800", "content": "Cursor 白嫖策略 cursor-fake-machine 实现白嫖 这个插件可以改变Cursor的机器码，让它以为你在不同的电脑上登录，从而绕过额度限制。 首先，需要下载cursor-fake-machine插件。 下载好之后，打开Cursor，把插件文件直接拖到插件扩展区域就OK了！ 安装成功后，你会看到一个提示，告诉你安装完成了。接下来，就是见证奇迹的时刻！ 打开Cursor的设置（file-&gt;preference-&gt;cursor settings），找到“advanced-&gt;Manage”，然后进入官网，删除账号。 删除账号后，回到Cursor，退出登录，确保你的账号已经彻底退出了。 在Cursor中，按下快捷键Ctrl+Shift+P，然后输入“fake”，你会看到一个“Fake Cursor”的选项，点击它！ cursor-fake-machine github地址 cursor-fake-machine 这个方案使用久了，发现有时候还是不能用，会被提示使用太多次，方案二可以接着白嫖 白嫖方案二 方案来自于 toutiao 参照方案一 去官网删除账号 在powershell 中执行 irm https://raw.githubusercontent.com/yuaotian/go-cursor-help/master/scripts/install.ps1 | iex 运行命令，等待安装完成，重启cursor " }, { "title": "java - 基础知识", "url": "/posts/thread1/", "categories": "java", "tags": "java", "date": "2021-10-08 09:36:00 +0800", "content": "内存结构 栈 存放局部变量 堆 存放对象，数组 变量 成员变量 vs 局部变量（方法内，方法形参，构造器，构造器形参，代码块内） 四种访问权限修饰符 修饰符 类内部 同一个包 不同包的子类 同一个工程 private yes       default yes yes     protected yes yes yes   public yes yes yes yes 对于class的修饰符只有public 和default JavaBean 符合以下标准的类 类是公共的 有一个无参的公共构造器 有属性，且有对应的get,set方法 用户可以使用JavaBean 将功能，处理，值，数据库访问和其他任何可以用java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面，Servlet,其他JavaBean,applet程序或者应用来使用这些对象。用户可以认为JavaBean 提供了一种随时随地的复制和赞贴的功能，而不用关心任何改变。 this this可以调用属性，方法，构造器 this() 调用构造器，可以显示的使用this(形参列表)方式，调用指定的其他构造器，不能形成递归 继承 子类继承后，具有父类的所有属性和方法 ，private属性和方法仍然认为获取到了，但是因为封装的原因，不能直接调用 所有的java类处 java.lang.Object 外，都直接或者间接继承了java.lang.Object类 当子类和父类中定义同名属性时，我们想要在子类调用父类中的属性方式，必须使用“super.属性”，子类不会覆盖父类的属性 我们可以在子类构造器中显示的使用super(形参列表)，调用父类的构造器，必须声明在子类构造器的首行 在构造器的首行没有显示的声明this(形参列表)或super(形参列表)，则默认调用的是父类的空参的构造函数 子类对象的实例化过程 从结果来看 子类继承父类以后，就获取了父类所有的属性和方法 创建子类的对象后，在堆空间中，就会加载所有父类中声明的属性 从过程看 当我们通过子类的构造器创建子类对象时，我们一定会直接或者间接的调用父类的构造器，直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有父类的结构，所有内存中才会有所有父类的结构，并且使用。 虽然创建子类对象时，调用了父类的构造器，但是只创建了一个对象，就是new 出来的对象 多态性 对象的多态性，父类的引用指向子类的对象 多态的使用 当调用子父类同名同参方法时，执行的是子类重写父类的方法 编译期，只能调用父类中声明的方法 ，但是运行期，我们实际执行的是子类重写的方法 只适用方法，编译看左边，运行看右边 对象的多态性，只使用于方法，不适用于属性。 编译和运行都看左边。 虚拟方法调用 子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它不同子类对象，动态调用属于子类的的该方法，这样的方法调用在编译器是无法确定的。 编译时类型和运行时类型。方法调用是在运行时确定的，动态绑定。 多态是个运行时行为 若子类重写了父类的方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类的的方法转移到子类中。（编译看左边，运行看右边） 对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量（编译运行都看左边） ## 方法的重写 方法名，形参列表相同 权限修饰符不能小于父类，不能重写private权限的方法 返回值不能大于父类的返回类型， static 方法不涉及到重写 静态变量 静态变量随着类的加载而加载 静态变量加载要早于对象的创建 类只会加载一次， 静态变量也只会存在一份 静态方法 只能调用静态变量或者其他静态方法，因为是随着类的加载而加载，其他实例变量还没有，所以this,super是不能用的。 栈，堆，方法区 栈，静态变量 堆：new 出来的结构 对象，数组 方法区： 类的加载信息，静态域，常量池 抽象与接口 抽象 抽象类，不可以实例化，一定有构造器，便于子类实例化时调用，通常在开发中，都会提供抽象类的子类，让子类对象实例化。 抽象方法，没有方法体，只有声明。 抽象方法一定是在抽象类。 若子类重写了父类的所有 抽象方法后，则此子类可以实例化，若子类没有重写父类的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰。 接口 interface和类是并列的结构，通过implements 如何定义接口：JDK7及以前 只能定义全局常量和抽象方法（public static final（书写时可以省略）,public abstarct） JDK8 新增了 静态方法和默认方法。 接口中是不可以定义构造器的，意味着接口不可以实例化 如果实现类覆盖了接口中所有的抽象方法，则此实现类可以实例化，如果没有则实现类认为接口 java类可以实现多个接口，弥补了java单继承性 接口与接口之间可以继承，并且可以多继承 ### jdk8 新特性 静态方法和默认方法 接口中定义的静态方法，只能通过接口调用 通过实现类的对象，可以调用接口中的默认方法 如果子类继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没有重写此方法的情况下，默认调用的是父类中同名同参数默认（default）方法 接口冲突： 如果实现类实现了多个接口，而这多个接口中定了同名同参数的默认方法，那么实现类没有重写此方法的情况下报错 调用接口中的默认方法 Interface.super.method（） ## 抽象类和接口的共同点以及区别 相同点： 不能实例化，都可以被继承 不同 抽象类：有构造器， 接口：不能声明构造器 ，类单继承，接口可以多继承 异常处理 ### ERROR 一般不编写针对性的代码进行处理 java虚拟机无法解决的严重问题，如JVM系统内部错误，资源耗尽等严重情况，例如栈溢出：StackOverflowError,堆溢出：OutOfMemoryError, ### Exception 其他编程错误或偶然的外在因素导致的，可以使用针对性的代码进行处理 例如空指针，数组越界，除数为0 一般两种解决方法，遇到错误终止程序的运行。另一种方法时由程序编写程序时，考虑到错误的检测，错误消息的提示，以及处理。 finally 是可选的，finally 中声明的是一定会被执行的代码，即使catch中又出了异常，try中有return语句，catch中有return 语句等， 也会先执行finally的语句。 像数据库连接，输入输出流，网络编程Socket 等资源，JVM是不能自动回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中 ### 体会 使用try-catch-finally 处理编译时异常，是将编译时可能出现的异常，延迟到运行时出现 开发中，由于运行时异常比较常见，所以我们通常就不针对运行时编译try-catch-finally " }, { "title": "java - 设计模式-原型模式", "url": "/posts/designpattern4/", "categories": "java", "tags": "原型模式", "date": "2021-01-08 09:36:00 +0800", "content": "原型模式（ProtoType） 用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象 原型模式是一种创建型模式，允许一个对象再创建另外一个可定制的对象，无需知道任何创建的细节 工作原理是通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone package CreationalPattern.ProtoTypePattern; public class Main { public static void main(String[] args) { ProtoType pt1 =new ProtoType(1); ProtoType pt2 = new ProtoType(2); pt1.setProtoType(pt2); System.out.println(pt1.toString()); try { ProtoType pt3 = (ProtoType) pt1.clone(); System.out.println(pt3.toString()); }catch (Exception e) { System.out.println(e.getMessage()); } } } package CreationalPattern.ProtoTypePattern; /** * 原型模式 */ public class ProtoType implements Cloneable { public int id; public void setProtoType(ProtoType protoType) { this.protoType = protoType; } private ProtoType protoType; public ProtoType(int id) { this.id = id; } @Override public String toString() { return \"id:\"+id+\" protoType:\"+protoType.hashCode(); } @Override protected Object clone() throws CloneNotSupportedException { ProtoType protoType=null; try { protoType = (ProtoType) super.clone(); }catch (Exception e) { System.out.println(e.getMessage()); } return protoType; } } 输出结果 id:1 protoType:603742814 id:1 protoType:603742814 对于引用传递的对象再克隆的时候，传递的是地址，这里克隆模式使用的是浅拷贝 浅拷贝 对于数据类型是基本数据类型的成员变量，直接进行值传递 对于引用类型的成员变量，例如数组，或者成员对象，浅拷贝进行引用传递，也就是只会复制地址，在一个对象修改该成员变量，会影响到另一个对象的该成员变量值 深拷贝 复制对象的所有基本数据类型的成员变量值 为所还有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达到所有的对象。 深拷贝实现 重写 clone 方法来实现深拷贝 对象序列化实现深拷贝 " }, { "title": "java - 类加载过程", "url": "/posts/java1/", "categories": "java", "tags": "类加载过程", "date": "2021-01-03 09:36:00 +0800", "content": "类加载过程 初始化 一个类要实例化需要先加载并初始化该类 main 所在的类需要先加载和初始化 一个子类要初始化需要先初始化父类 一个类初始化就是执行&lt; clinit &gt;（） 方法 &lt; clinit &gt;() 方法由静态类静态变量显示赋值代码和静态代码块组成 类变量显示赋值代码和静态代码块从上到下顺序执行 &lt; clinit &gt;()方法只执行一次 实例初始化 实例初始化就是执行&lt; init &gt;() 方法 &lt; init &gt;() 方法可能重载有多个，有几个构造器就有几个&lt; init &gt;()方法 &lt; init &gt;() 方法由非静态实例变量显示赋值代码和非静态代码块从上到下顺序执行，而构造器的代码最后执行 每次创建实例对象，调用对应构造器，执行的就是对应&lt; init &gt;()方法 &lt; init &gt;方法的首行是 super（）或 super（实参列表），即对应父类&lt; init &gt;方法 方法的重写 不可重写的方法 final 方法 静态方法 private 等子类中不可见方法 非静态方法前面都有个 this，this 在&lt; init &gt; 表示的是正在创建的对象 对象的多态性 子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码 非静态方法默认的调用对象时 this this 堆在在构造器或者说&lt; init &gt;方法中就是正在创建的队形 " }, { "title": "设计模式 - 单例", "url": "/posts/designpattern3/", "categories": "设计模式", "tags": "单例", "date": "2020-12-20 09:36:00 +0800", "content": "单例模式 采取一定的方法保证在整个软件系统中，某个类只能存在一个对象实例， 并且该类只提供一个取得其对象实例的方法（静态方法） 八种方式 饿汉式（静态常量） 饿汉式（静态代码块） 懒汉式（线程不安全） 懒汉式（线程安全，同步方法） 懒汉式（线程安全，同步代码块） 双重检查 静态内部类 枚举 饿汉式（静态常量） 1.构造器私有化（防止 new 出新实例） 2.类的内部创建对象 3.向外暴露一个静态方法（获取实例） public class Singleton7 { private Singleton7() { } private static class SingletonInstance{ private static final Singleton7 INSTANCE = new Singleton7(); } public static Singleton7 getInstance() { return SingletonInstance.INSTANCE; } } 优点：写法简单，类装载的时候完成实例化，避免线程安全问题 缺点：类装载的时候完成实例化，没有 lazy loading 效果，如果自始至终没有用到单例，会造成内存浪费 这种方式基于 classloader 机制避免了多线程的同步问题，不过，intance 在装载时就实例化，单例模式中大多数都是调用 getInstance 方法，但是导致类装载的原因很多，不能确定有其他的方式导致类装载，这时候初始化 instance 没有达到 lazy loading 的效果。 饿汉式（静态代码块） packagepattern.Singleton; /** * 饿汉式 静态代码块 */ public class Singleton2 { private Singleton2() { } private static Singleton2 instance; static { instance = new Singleton2(); } public static Singleton2 getInstance() { return instance; } } 类实例化的过程放在了静态代码块中，也是类装载的时候，就执行了静态代码块的中的代码，初始化类的实例。优缺点和上面相同。 懒汉式（线程不安全） /** * 懒汉式 线程不安全 lazy loading */ public class Singleton3 { private Singleton3() { } private static Singleton3 instance; public static Singleton3 getInstance() { if(instance==null){ instance = new Singleton3(); } return instance; } } 1.起到了 lazy loading 的效果，但是只能单线程下使用. 2.如果在多线程下，多个线程同时进入 if 语句，就会产生多个实例 饿汉式（线程安全） /** * 懒汉式，线程安全，同步方法 */ public class Singleton4 { private Singleton4() { } private static Singleton4 instance; public static synchronized Singleton4 getInstance() { if(instance==null){ instance = new Singleton4(); } return instance; } } 优点：线程安全 缺点：效率太低，每个线程想要获取实例执行 getInstance 都要进行同步，但是该方法只需要执行一次，实例化后直接 return 就好了 实际开发不推荐 双重检查 /** * Double Check 双重检查 * 优点： 线程安全，懒加载，getInstance方法效率也提高了 */ public class Singleton6 { private Singleton6() { } private static volatile Singleton6 instance; public static Singleton6 getInstance() { if(instance==null){ synchronized(Singleton6.class) { if(instance==null) { instance = new Singleton6(); } } } return instance; } } 推荐使用的方法 优缺点： 线程安全，延迟加载，效率较高 第一个 instance==null 不为空则直接返回，避免方法每次访问同步 第二个 instance==null 保证了线程安全 这样保证了效率和线程安全，在实际开发中推荐这样使用 静态内部类 /** * 静态内部类方法 */ public class Singleton7 { private Singleton7() { } private static class SingletonInstance{ private static final Singleton7 INSTANCE = new Singleton7(); } public static Singleton7 getInstance() { return SingletonInstance.INSTANCE; } } 1.这种方式采用了类装载的机制来保证初始化实例只有一个线程 2.静态内部类在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载静态内部类 SingletonInstance，从而完成 Singleton 的实例化，提高了效率 3.类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程安全，在类进行初始化时，别的线程是无法进入的，避免线程不安全。 推荐使用 总结 单例模式保证系统中该类只有这一个对象，节省了系统资源，对于频繁创建销毁的对象，使用单例模式可以系统性能 当想使用一个实例时，只能用 getInstance，不能 new 单例模式使用的场景：需要频繁的进行创建和销毁的对象，创建对象时耗时过多或耗费资源过多（重量级对象），但又经常用到的对象 工具类对象，频繁访问数据库或文件的对象（比如数据源，session 工厂等） " }, { "title": "设计模式 - 设计模式的原则", "url": "/posts/designpattern2/", "categories": "设计模式", "tags": "设计模式的原则", "date": "2020-12-06 09:36:00 +0800", "content": "七大原则 单一职责原则 单一职责原则（Single Responsibility Principle, SRP）： 一个类只负责一个功能领域中的相 应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 开闭原则 开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件 实体应尽量在不修改原有代码的情况下进行扩展。 在 Java、C#等 编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现 层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系 统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何 改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩 展系统的功能，达到开闭原则的要求。 里式替换原则 里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类 （父类）的地方必须能透明地使用其子类的对象。 里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任 何错误和异常，反过来则不成立。 里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对 象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用 子类对象来替换父类对象。 (1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代 换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在 子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 (2) 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现 父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地 扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类 来实现。里氏代换原则是开闭原则的具体实现手段之一。 依赖倒转原则 依赖倒转原则(Dependency Inversion Principle, DIP)：抽象不应该依赖于细节，细节应 当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层 类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据 类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只 实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增 加的新方法。 在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体 类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改 配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭 原则的要求。 在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入 (DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发 生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注 入，设值注入（Setter 注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象， 设值注入是指通过 Setter 方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务 方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型 的对象，由子类对象来覆盖父类对象。 接口隔离原则 接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一 的总接口，即客户端不应该依赖那些它不需要的接口。 根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接 口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干 不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具 有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义， 有严格的定义和结构，比如 Java 语言中的 interface。对于这两种不同的含义，ISP 的表达方式以 及含义都有所不同： (1) 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概 念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角 色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。 (2) 如果把“接口”理解成狭义的特定语言的接口，那么 ISP 表达的意思是指接口仅仅提供客户端 需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口， 而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的 所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口 中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便， 并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只 包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即 为不同的客户端提供宽窄不同的接口。 合成复用原则 合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复 用的目的。 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些 已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能 的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。 在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/ 聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低 类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使 用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂 度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继 承复用。 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实 现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白 箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是 静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用 （如类没有声明为不能被继承）。 由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新 对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现 细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对 较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用 成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型 相同的其他对象。 迪米特原则 迪米特法则(Law of Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。 迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等，在迪 米特法则中，对于一个对象，其朋友包括以下几类： (1) 当前对象本身(this)； (2) 以参数形式传入到当前对象方法中的对象； (3) 当前对象的成员对象； (4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； (5) 当前对象所创建的对象。 " }, { "title": "Akka 入门-Actor", "url": "/posts/akka1/", "categories": "框架", "tags": "akka, actor", "date": "2020-10-17 00:16:00 +0800", "content": "模块 AKKA 是调度模块化的，它由许多拥有不同特性的 JAR 组成。 akka-actor – 经典角色、类型角色、IO 角色等。 akka-agent – 代理、整合了 Scala 的 STM 特性 akka-camel – 整合 Apache 的 Camel akka-cluster – 集群成员管理、弹性路由 akka-kernel – AKKA 微内核，运行着一个极简应用服务器 akka-osgi – 在 OSG 容器里使用 AKKA 的基本 bundle，包括 akka-actor 的类 akka-osgi-aries – Aries——服务提供角色系统的蓝图 akka-remote – 远程角色 akka-slf4j – SLF4J Logger (事件总线监听器) akka-testkit – 测试角色系统的工具包 Toolkit for testing Actor systems akka-zeromq – 整合 ZeroM Actor 角色（Actor） 并发与并行性的高等级抽象 异步，无锁以及高性能的事件驱动编程模型 非常轻量级的事件驱动流程 容错 拥有“让它崩溃”语义的管理层级 管理层级可以跨越多个 JVM，实现真正的容错系统 非常适合编写可自我修复且永不停机的高容错能力的系统 位置透明 akka 旨在分布式环境中工作：角色之间都是用纯消息交互，并且一切都是异步的 Actor 优点 事件驱动模型：Event-driven model，Actor 通过响应消息来执行工作。Actor 之间的通信是异步的，允许 Actor 发送消息并继续自己的工作，而不是阻塞等待响应 强隔离原则：Strong isolation principles，与 Java 中的常规对象不同，Actor 在调用的方法方面，没有一个公共 API。相反，它的公共 API 是通过 Actor 处理的消息来定义的。这可以防止 Actor 之间共享状态；观察另一个 Actor 状态的唯一方法是向其发送请求状态的消息。 位置透明：Location transparency，系统通过工厂方法构造 Actor 并返回对实例的引用。因为位置无关紧要，所以 Actor 实例可以启动、停止、移动和重新启动，以向上和向下扩展以及从意外故障中恢复 轻量级：Lightweight，每个实例只消耗几百个字节，这实际上允许数百万并发 Actor 存在于一个应用程序中。 Actor 生命周期 actor 被创建后存在，并且用户请求关闭消失。当 actor 被关闭后，其所有的子 actor 都将被递归地关闭。这个特性极大简化了我们的资源清理工作，并且防止资源泄露。实际上，在进行底层多线程编程时，我们经常会小看各种对并发资源生命周期管理的难度。 Context.stop(self)自我关闭，停止其他 Context.stop(actorRef) 通过这种方式停止一个 actor 是坏习惯，但是你可以给这个 actor 发送 PosionPill 或者自定义关闭消息来关闭它。 Akka 的 actor 提供了很对生命周期 API，你可以在实现 actor 时重载这些方法。最常用的是 preStart()和 postStop()。 preStart()会在 actor 启动后，并在它处理第一个消息之前被调用 postStop()会在 actor 将要被关闭前被调用，在它之后，actor 不会再处理任何消息了 Actor 层次结构 通过调用 context.actorOf 创建一个 actor。这种方式向现有的 actor 树内加入了一个新的 actor，这个 actor 创建者 就成为了这个 actor 的父 actor。 所有的 actor 都有一个共同的家长 成为 user guardian 可以通过调用 system.actorOf()来创建属于它新的 actor 实例。创建 actor 将返回一个有效的 URL 引用，因此，如果我们通过调用 system.actorOf(…,”someActor”) 创建一个名为 someActor 时，其引用将包路径/user/someActor Actor 失败处理 父 actor 和子 actor 在整个声明周期内都保持着联系。当一个 actor 失败了（抛出异常或者在 receive 里冒出一个未处理的异常），他会被暂时地挂起。就像之前提到的一样，失败信息会被传递到父 actor 中，然后由父 actor 来决定如何处理这个子 actor 产生的异常。在这种方式下，父 actor 就是子 actor 的监管者，默认的监管策略就是停止并且重启子 actor。如果你没有修改默认的监管策略，那么所有的失败都会导致重启 actor。 到在 actor 失败后，被监管的 actor 被立即停止并重启，我们也看到了一条这个异常被处理的日志。在测试中，我们使用 preStart()和 postStop()钩子，这些钩子可以在 actor 被重启前后被调用，所以我们不能用它来区分 actor 是我吃一次启动还是被重启。重启 actor 在大多数情况是正确的，重启可以让 actor 恢复到一个已知的正确状态上，也就是启动时的干净状态。在内部真正发生的是：preRestart()和postRestart() 方法被调用，如果它们没有被重载，则它们分别会调用 postStop()和 preStart()你可以尝试重载这些方法，看看输出的改变 Actor 处理子角色故障 角色最后一个功能是处理子角色的故障。故障处理对于用户来说是透明的，对于发生的故障 Akka 都会自动的通过对应策略处理（监管和监测章节介绍）。 因为这些策略是构成角色系统的基础，所以一旦角色被创建那么这些故障处理策略将不可改变。 由于每个角色都只有一类故障处理策略，这也就意味着不同的子角色将会应用不同的策略。角色根据子角色所使用的故障处理策略将它们分组。根据任务被切分的子任务性质系统会不断的重复这个分组过程。一旦角色终止，如失败后无法重启，自己停止或者被监督者停止，那么它将释放它占有的所有资源，并将它信箱中没处理的消息发送到“死信件信箱”里，然后“死信件信箱”将会把他们以 DeadLetters 的形式传递给 EventStream. Actor 引用中的信箱将会被一个系统信箱所取代，然后将所有消息以 DeadLetters 的形式转发给 EventStream。虽然系统会尽最大努力来实现该消息传递，但是我们不能依赖它来实现“有保证的传递”。 为什么不选择悄悄的将所有消息倾倒出来，是基于我们下面的测试结果考虑：我们在事件总线（BUS）上注册了测试事件监听器(TestEventListener)。这里事件总线即死信件被发送到的地方。该监听器将会对收到的每条死信件记录一条警告日志——这个可以帮助我们更快的检测失败。所以我们有理由相信这个特征还将可以应用于其他目的。 " }, { "title": "常用算法 一", "url": "/posts/datastructure11/", "categories": "数据结构与算法", "tags": "java", "date": "2020-07-12 14:16:00 +0800", "content": "常用算法 非递归二分查找实现 二分查找只适用于有序查找，需要先将数列进行排序 package com.learn.bsc; /** * 非递归二分查找 */ public class BsNoRecur { public static int binarySearchNoRecur(int arr[],int target) { int left=0; int right = arr.length -1; while(left&lt;=right) { int mid =(left+right)/2; if(arr[mid]==target) { return mid; }else if(arr[mid]&gt;target) { right=mid-1; }else { left=mid+1; } } return -1; } } 分治算法 分治算法可以求解的一些问题 二分搜索 大整数乘法 棋盘覆盖 合并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔 分治算法设计模式 分治算法实现汉诺塔 这里问题最小规模 按 n==2 考虑，当 n&gt;2 时，把上层的塔看做一个整体 package com.learn.fenzhi; public class hannoitower { // 把n-1个盘子由A 移到 B； // 把第n个盘子由 A移到 C； // 把n-1个盘子由B 移到 C； public static void play(int num,char a,char b,char c) { if(num==1) { //只有一个盘直接从a移到c System.out.println(\"第一个盘从\"+a+\"-&gt;\"+c); }else{ //盘&gt;=2 总是看成两个盘 //把最上面的盘全部移到b play(num-1,a,c,b); System.out.println(\"第\"+num+\"个盘从\"+a+\"-&gt;\"+c); //把b上面移到c play(num-1,b,a,c); } } } " }, { "title": "常用算法 一", "url": "/posts/algorithm1/", "categories": "数据结构与算法", "tags": "java", "date": "2020-07-10 14:16:00 +0800", "content": "常用算法 非递归二分查找实现 二分查找只适用于有序查找，需要先将数列进行排序 package com.learn.bsc; /** * 非递归二分查找 */ public class BsNoRecur { public static int binarySearchNoRecur(int arr[],int target) { int left=0; int right = arr.length -1; while(left&lt;=right) { int mid =(left+right)/2; if(arr[mid]==target) { return mid; }else if(arr[mid]&gt;target) { right=mid-1; }else { left=mid+1; } } return -1; } } 分治算法 分治算法可以求解的一些问题 二分搜索 大整数乘法 棋盘覆盖 合并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔 分治算法设计模式 分治算法实现汉诺塔 这里问题最小规模 按 n==2 考虑，当 n&gt;2 时，把上层的塔看做一个整体 package com.learn.fenzhi; public class hannoitower { // 把n-1个盘子由A 移到 B； // 把第n个盘子由 A移到 C； // 把n-1个盘子由B 移到 C； public static void play(int num,char a,char b,char c) { if(num==1) { //只有一个盘直接从a移到c System.out.println(\"第一个盘从\"+a+\"-&gt;\"+c); }else{ //盘&gt;=2 总是看成两个盘 //把最上面的盘全部移到b play(num-1,a,c,b); System.out.println(\"第\"+num+\"个盘从\"+a+\"-&gt;\"+c); //把b上面移到c play(num-1,b,a,c); } } } 动态规划算法 核心思想 将大问题规划分为小问题进行解决，从而一步步虎丘最优解的处理算法 动态规划算反与分治算法类似，其基本思想也是将带球解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解的到原问题的解 与分治法不同的是，适合用于动态规划求解的问题，经分级得到子问题往往不是互相独立的。即下一个阶段的求解是建立在上一阶段的解的基础上进行进一步求解 动态规划可以通过填表方式来逐步推进，得到最优解。 背包问题 " }, { "title": "图", "url": "/posts/datastructure10/", "categories": "数据结构与算法", "tags": "tree, java", "date": "2020-07-02 14:16:00 +0800", "content": "1.在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有开一个直接前驱和一个直接后继 2.在树形结构中，数据元素之间有明显的层次关系，并且在每一层上的数据元素可能和下一层多个元素相关，但只能和上一层一个元素相关。 这两种结构只能表达一对多的关系，当遇到多对多关系，就需要图。 图是由有穷非空集合和顶点之间变得集合组成，通常表示为：G（v,e）,G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。 1.线性表中数据元素 叫元素 。 树-结点 图-顶点 2.图是有穷非空集合，图结构中不允许没有顶点 3.线性表中，相邻数据元素之间具有线性关系 无向边 顶点之间的边没有方向，如果任意两个顶点之间的边都是无向边，则称该图为无向图。 若两顶点之间的边有方向，则称这条边为有向边，也称为弧。 无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有 n 个顶点的无向完全图 在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图 图的遍历 深度优先 （Depth First Search） 广度优先 (Braddth FS) 深度优先和广度优先，时间复杂度相同，不同之处仅仅在于对顶点访问的顺序不同。 package com.learn.graph; import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; public class Graph { private ArrayList&lt;String&gt; vertexList; //存储顶点集合 private int[][] edges; //存储图对应的邻结矩阵 private int numOfEdges; //表示边的数目 //定义给数组boolean[], 记录某个结点是否被访问 private boolean[] isVisited; public static void main(String[] args) { //测试一把图是否创建ok int n = 8; //结点的个数 //String Vertexs[] = {\"A\", \"B\", \"C\", \"D\", \"E\"}; String Vertexs[] = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"}; //创建图对象 Graph graph = new Graph(n); //循环的添加顶点 for(String vertex: Vertexs) { graph.insertVertex(vertex); } //添加边 //A-B A-C B-C B-D B-E //\t\tgraph.insertEdge(0, 1, 1); // A-B //\t\tgraph.insertEdge(0, 2, 1); // //\t\tgraph.insertEdge(1, 2, 1); // //\t\tgraph.insertEdge(1, 3, 1); // //\t\tgraph.insertEdge(1, 4, 1); // //更新边的关系 graph.insertEdge(0, 1, 1); graph.insertEdge(0, 2, 1); graph.insertEdge(1, 3, 1); graph.insertEdge(1, 4, 1); graph.insertEdge(3, 7, 1); graph.insertEdge(4, 7, 1); graph.insertEdge(2, 5, 1); graph.insertEdge(2, 6, 1); graph.insertEdge(5, 6, 1); //显示一把邻结矩阵 graph.showGraph(); //测试一把，我们的dfs遍历是否ok System.out.println(\"深度遍历\"); graph.dfs(); // A-&gt;B-&gt;C-&gt;D-&gt;E [1-&gt;2-&gt;4-&gt;8-&gt;5-&gt;3-&gt;6-&gt;7] //\t\tSystem.out.println(); System.out.println(\"广度优先!\"); graph.bfs(); // A-&gt;B-&gt;C-&gt;D-E [1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8] } //构造器 public Graph(int n) { //初始化矩阵和vertexList edges = new int[n][n]; vertexList = new ArrayList&lt;String&gt;(n); numOfEdges = 0; } //得到第一个邻接结点的下标 w /** * * @param index * @return 如果存在就返回对应的下标，否则返回-1 */ public int getFirstNeighbor(int index) { for(int j = 0; j &lt; vertexList.size(); j++) { if(edges[index][j] &gt; 0) { return j; } } return -1; } //根据前一个邻接结点的下标来获取下一个邻接结点 public int getNextNeighbor(int v1, int v2) { for(int j = v2 + 1; j &lt; vertexList.size(); j++) { if(edges[v1][j] &gt; 0) { return j; } } return -1; } //深度优先遍历算法 //i 第一次就是 0 private void dfs(boolean[] isVisited, int i) { //首先我们访问该结点,输出 System.out.print(getValueByIndex(i) + \"-&gt;\"); //将结点设置为已经访问 isVisited[i] = true; //查找结点i的第一个邻接结点w int w = getFirstNeighbor(i); while(w != -1) {//说明有 if(!isVisited[w]) { dfs(isVisited, w); } //如果w结点已经被访问过 w = getNextNeighbor(i, w); } } //对dfs 进行一个重载, 遍历我们所有的结点，并进行 dfs public void dfs() { isVisited = new boolean[vertexList.size()]; //遍历所有的结点，进行dfs[回溯] for(int i = 0; i &lt; getNumOfVertex(); i++) { if(!isVisited[i]) { dfs(isVisited, i); } } } //对一个结点进行广度优先遍历的方法 private void bfs(boolean[] isVisited, int i) { int u ; // 表示队列的头结点对应下标 int w ; // 邻接结点w //队列，记录结点访问的顺序 LinkedList queue = new LinkedList(); //访问结点，输出结点信息 System.out.print(getValueByIndex(i) + \"=&gt;\"); //标记为已访问 isVisited[i] = true; //将结点加入队列 queue.addLast(i); while( !queue.isEmpty()) { //取出队列的头结点下标 u = (Integer)queue.removeFirst(); //得到第一个邻接结点的下标 w w = getFirstNeighbor(u); while(w != -1) {//找到 //是否访问过 if(!isVisited[w]) { System.out.print(getValueByIndex(w) + \"=&gt;\"); //标记已经访问 isVisited[w] = true; //入队 queue.addLast(w); } //以u为前驱点，找w后面的下一个邻结点 w = getNextNeighbor(u, w); //体现出我们的广度优先 } } } //遍历所有的结点，都进行广度优先搜索 public void bfs() { isVisited = new boolean[vertexList.size()]; for(int i = 0; i &lt; getNumOfVertex(); i++) { if(!isVisited[i]) { bfs(isVisited, i); } } } //图中常用的方法 //返回结点的个数 public int getNumOfVertex() { return vertexList.size(); } //显示图对应的矩阵 public void showGraph() { for(int[] link : edges) { System.err.println(Arrays.toString(link)); } } //得到边的数目 public int getNumOfEdges() { return numOfEdges; } //返回结点i(下标)对应的数据 0-&gt;\"A\" 1-&gt;\"B\" 2-&gt;\"C\" public String getValueByIndex(int i) { return vertexList.get(i); } //返回v1和v2的权值 public int getWeight(int v1, int v2) { return edges[v1][v2]; } //插入结点 public void insertVertex(String vertex) { vertexList.add(vertex); } //添加边 /** * * @param v1 表示点的下标即使第几个顶点 \"A\"-\"B\" \"A\"-&gt;0 \"B\"-&gt;1 * @param v2 第二个顶点对应的下标 * @param weight 表示 */ public void insertEdge(int v1, int v2, int weight) { edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; } } " }, { "title": "二叉排序树 BST（Binary Sort Tree）", "url": "/posts/datastructure9/", "categories": "数据结构与算法", "tags": "tree, java", "date": "2020-07-02 14:16:00 +0800", "content": "二叉排序树 二叉排序树是一颗空树或者具有以下性质二叉树 若它的左子树不为空，则左子树上所有结点的值均小于它根结点的值 若它的右子树不为空，则右子树上所欲结点的值均大于它根结点的值 它的左右子树分别为二叉排序树 实现 package com.learn.bst; public class BinarySortTreeDemo { public static void main(String[] args) { int[] arr = {7, 3, 10, 12, 5, 1, 9, 2}; BinarySortTree binarySortTree = new BinarySortTree(); //循环的添加结点到二叉排序树 for(int i = 0; i&lt; arr.length; i++) { binarySortTree.add(new Node(arr[i])); } //中序遍历二叉排序树 System.out.println(\"中序遍历二叉排序树~\"); binarySortTree.infixOrder(); // 1, 3, 5, 7, 9, 10, 12 //测试一下删除叶子结点 binarySortTree.delNode(12); binarySortTree.delNode(5); binarySortTree.delNode(10); binarySortTree.delNode(2); binarySortTree.delNode(3); binarySortTree.delNode(9); binarySortTree.delNode(1); binarySortTree.delNode(7); System.out.println(\"root=\" + binarySortTree.getRoot()); System.out.println(\"删除结点后\"); binarySortTree.infixOrder(); } } //创建二叉排序树 class BinarySortTree { private Node root; public Node getRoot() { return root; } //查找要删除的结点 public Node search(int value) { if(root == null) { return null; } else { return root.search(value); } } //查找父结点 public Node searchParent(int value) { if(root == null) { return null; } else { return root.searchParent(value); } } //编写方法: //1. 返回的 以node 为根结点的二叉排序树的最小结点的值 //2. 删除node 为根结点的二叉排序树的最小结点 /** * * @param node 传入的结点(当做二叉排序树的根结点) * @return 返回的 以node 为根结点的二叉排序树的最小结点的值 */ public int delRightTreeMin(Node node) { Node target = node; //循环的查找左子节点，就会找到最小值 while(target.left != null) { target = target.left; } //这时 target就指向了最小结点 //删除最小结点 delNode(target.value); return target.value; } //删除结点 public void delNode(int value) { if(root == null) { return; }else { //1.需求先去找到要删除的结点 targetNode Node targetNode = search(value); //如果没有找到要删除的结点 if(targetNode == null) { return; } //如果我们发现当前这颗二叉排序树只有一个结点 if(root.left == null &amp;&amp; root.right == null) { root = null; return; } //去找到targetNode的父结点 Node parent = searchParent(value); //如果要删除的结点是叶子结点 if(targetNode.left == null &amp;&amp; targetNode.right == null) { //判断targetNode 是父结点的左子结点，还是右子结点 if(parent.left != null &amp;&amp; parent.left.value == value) { //是左子结点 parent.left = null; } else if (parent.right != null &amp;&amp; parent.right.value == value) {//是由子结点 parent.right = null; } } else if (targetNode.left != null &amp;&amp; targetNode.right != null) { //删除有两颗子树的节点 int minVal = delRightTreeMin(targetNode.right); targetNode.value = minVal; } else { // 删除只有一颗子树的结点 //如果要删除的结点有左子结点 if(targetNode.left != null) { if(parent != null) { //如果 targetNode 是 parent 的左子结点 if(parent.left.value == value) { parent.left = targetNode.left; } else { // targetNode 是 parent 的右子结点 parent.right = targetNode.left; } } else { root = targetNode.left; } } else { //如果要删除的结点有右子结点 if(parent != null) { //如果 targetNode 是 parent 的左子结点 if(parent.left.value == value) { parent.left = targetNode.right; } else { //如果 targetNode 是 parent 的右子结点 parent.right = targetNode.right; } } else { root = targetNode.right; } } } } } //添加结点的方法 public void add(Node node) { if(root == null) { root = node;//如果root为空则直接让root指向node } else { root.add(node); } } //中序遍历 public void infixOrder() { if(root != null) { root.infixOrder(); } else { System.out.println(\"二叉排序树为空，不能遍历\"); } } } //创建Node结点 class Node { int value; Node left; Node right; public Node(int value) { this.value = value; } //查找要删除的结点 /** * * @param value 希望删除的结点的值 * @return 如果找到返回该结点，否则返回null */ public Node search(int value) { if(value == this.value) { //找到就是该结点 return this; } else if(value &lt; this.value) {//如果查找的值小于当前结点，向左子树递归查找 //如果左子结点为空 if(this.left == null) { return null; } return this.left.search(value); } else { //如果查找的值不小于当前结点，向右子树递归查找 if(this.right == null) { return null; } return this.right.search(value); } } //查找要删除结点的父结点 /** * * @param value 要找到的结点的值 * @return 返回的是要删除的结点的父结点，如果没有就返回null */ public Node searchParent(int value) { //如果当前结点就是要删除的结点的父结点，就返回 if((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) { return this; } else { //如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空 if(value &lt; this.value &amp;&amp; this.left != null) { return this.left.searchParent(value); //向左子树递归查找 } else if (value &gt;= this.value &amp;&amp; this.right != null) { return this.right.searchParent(value); //向右子树递归查找 } else { return null; // 没有找到父结点 } } } @Override public String toString() { return \"Node [value=\" + value + \"]\"; } //添加结点的方法 //递归的形式添加结点，注意需要满足二叉排序树的要求 public void add(Node node) { if(node == null) { return; } //判断传入的结点的值，和当前子树的根结点的值关系 if(node.value &lt; this.value) { //如果当前结点左子结点为null if(this.left == null) { this.left = node; } else { //递归的向左子树添加 this.left.add(node); } } else { //添加的结点的值大于 当前结点的值 if(this.right == null) { this.right = node; } else { //递归的向右子树添加 this.right.add(node); } } } //中序遍历 public void infixOrder() { if(this.left != null) { this.left.infixOrder(); } System.out.println(this); if(this.right != null) { this.right.infixOrder(); } } } 平衡二叉树（AVL 树） 平衡二叉树时一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于 1 定义：它时一颗空树或它的左右两个子树的高度差绝对值不超过 1，并且 左右两个子树都是一颗平衡二叉树 一个 BST 左子树全部为空 从形式上看 更像一个单链表 插入速度没有影响，但是查询速度比链表更慢，因为需要判断左子树 平衡二叉树是在二叉搜索树的基础之上成立的 平衡二叉树常用实现方法有 红黑树 Avl 替罪羊树 Treap 伸展树 右子树高的时候进行左旋，左子树搞得时候进行右旋 左旋思路： 1.创建一个新节点，值等于当前根节点的值 2.把新节点的左子树设置成当前节点的左子树 3.把新节点的右子树设置为当前节点的右子节点的左子树 4.把当前节点的值换位右子节点的值 5.把当前节点的左子树设置为新节点 6.把当前节点的右子树设置成当前节点右子树的右子树 package com.learn.avl; public class AVLTreeDemo { public static void main(String[] args) { // int[] arr = {4, 3, 6, 5, 7, 8}; int[] arr ={10,12,8,9,7,6}; AVLTree tree = new AVLTree(); for (int i = 0; i &lt; arr.length; i++) { tree.add(new Node(arr[i])); } System.out.println(tree.height()); } } class AVLTree { private Node root; public Node getRoot() { return root; } public int height() { return root.height(); } //查找要删除的结点 public Node search(int value) { if (root == null) { return null; } else { return root.search(value); } } //查找父结点 public Node searchParent(int value) { if (root == null) { return null; } else { return root.searchParent(value); } } //编写方法: //1. 返回的 以node 为根结点的二叉排序树的最小结点的值 //2. 删除node 为根结点的二叉排序树的最小结点 /** * @param node 传入的结点(当做二叉排序树的根结点) * @return 返回的 以node 为根结点的二叉排序树的最小结点的值 */ public int delRightTreeMin(Node node) { Node target = node; //循环的查找左子节点，就会找到最小值 while (target.left != null) { target = target.left; } //这时 target就指向了最小结点 //删除最小结点 delNode(target.value); return target.value; } //删除结点 public void delNode(int value) { if (root == null) { return; } else { //1.需求先去找到要删除的结点 targetNode Node targetNode = search(value); //如果没有找到要删除的结点 if (targetNode == null) { return; } //如果我们发现当前这颗二叉排序树只有一个结点 if (root.left == null &amp;&amp; root.right == null) { root = null; return; } //去找到targetNode的父结点 Node parent = searchParent(value); //如果要删除的结点是叶子结点 if (targetNode.left == null &amp;&amp; targetNode.right == null) { //判断targetNode 是父结点的左子结点，还是右子结点 if (parent.left != null &amp;&amp; parent.left.value == value) { //是左子结点 parent.left = null; } else if (parent.right != null &amp;&amp; parent.right.value == value) {//是由子结点 parent.right = null; } } else if (targetNode.left != null &amp;&amp; targetNode.right != null) { //删除有两颗子树的节点 int minVal = delRightTreeMin(targetNode.right); targetNode.value = minVal; } else { // 删除只有一颗子树的结点 //如果要删除的结点有左子结点 if (targetNode.left != null) { if (parent != null) { //如果 targetNode 是 parent 的左子结点 if (parent.left.value == value) { parent.left = targetNode.left; } else { // targetNode 是 parent 的右子结点 parent.right = targetNode.left; } } else { root = targetNode.left; } } else { //如果要删除的结点有右子结点 if (parent != null) { //如果 targetNode 是 parent 的左子结点 if (parent.left.value == value) { parent.left = targetNode.right; } else { //如果 targetNode 是 parent 的右子结点 parent.right = targetNode.right; } } else { root = targetNode.right; } } } } } //添加结点的方法 public void add(Node node) { if (root == null) { root = node;//如果root为空则直接让root指向node } else { root.add(node); } } //中序遍历 public void infixOrder() { if (root != null) { root.infixOrder(); } else { System.out.println(\"二叉排序树为空，不能遍历\"); } } } //创建Node结点 class Node { int value; Node left; Node right; public Node(int value) { this.value = value; } /** * 左旋思路： * 1.创建一个新节点，值等于当前根节点的值 * 2.把新节点的左子树设置成当前节点的左子树 * 3.把新节点的右子树设置为当前节点的右子节点的左子树 * 4.把当前节点的值换位右子节点的值 * 5.把当前节点的左子树设置为新节点 * 6.把当前节点的右子树设置成当前节点右子树的右子树 */ public void leftRotate() { Node temp = new Node(this.value); temp.left = left; temp.right = right.left; value=right.value; this.left=temp; right=right.right; } public void rightRotate() { Node temp = new Node(this.value); temp.right = right; temp.left = left.right; value=left.value; left = left.left; right=temp; } /** * 以本节点为根节点的高度,如果只有根节点，高度则是 1 */ public int height() { int left_height=1; int right_height=1; if(left!=null) { left_height=left.height()+1; } if(right!=null) { right_height=right.height()+1; } return Math.max(left_height,right_height); } /** * 右子树高度 * @return */ public int rightHeight() { int mHeight= 0; if(right!=null) { return right.height(); } return mHeight; } /** * 左子树高度 * @return */ public int leftHeight() { int mHeight =0; if (left!=null) { return left.height(); } return mHeight; } //查找要删除的结点 /** * @param value 希望删除的结点的值 * @return 如果找到返回该结点，否则返回null */ public Node search(int value) { if (value == this.value) { //找到就是该结点 return this; } else if (value &lt; this.value) {//如果查找的值小于当前结点，向左子树递归查找 //如果左子结点为空 if (this.left == null) { return null; } return this.left.search(value); } else { //如果查找的值不小于当前结点，向右子树递归查找 if (this.right == null) { return null; } return this.right.search(value); } } //查找要删除结点的父结点 /** * @param value 要找到的结点的值 * @return 返回的是要删除的结点的父结点，如果没有就返回null */ public Node searchParent(int value) { //如果当前结点就是要删除的结点的父结点，就返回 if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) { return this; } else { //如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空 if (value &lt; this.value &amp;&amp; this.left != null) { return this.left.searchParent(value); //向左子树递归查找 } else if (value &gt;= this.value &amp;&amp; this.right != null) { return this.right.searchParent(value); //向右子树递归查找 } else { return null; // 没有找到父结点 } } } @Override public String toString() { return \"Node [value=\" + value + \"]\"; } //添加结点的方法 //递归的形式添加结点，注意需要满足二叉排序树的要求 public void add(Node node) { if (node == null) { return; } //判断传入的结点的值，和当前子树的根结点的值关系 if (node.value &lt; this.value) { //如果当前结点左子结点为null if (this.left == null) { this.left = node; } else { //递归的向左子树添加 this.left.add(node); } } else { //添加的结点的值大于 当前结点的值 if (this.right == null) { this.right = node; } else { //递归的向右子树添加 this.right.add(node); } } if(rightHeight()-leftHeight()&gt;1) { if(right!=null&amp;&amp;right.leftHeight()&gt;right.rightHeight()) { right.rightRotate(); } leftRotate(); return; } if(leftHeight()-rightHeight()&gt;1) { if(left!=null&amp;&amp;left.rightHeight()&gt;left.leftHeight()) { left.leftRotate(); } rightRotate(); } } //中序遍历 public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } } } 多路查找树 多路查找树（muitl-way search tree），其每一个结点的孩子数可以多于两个，且每一个结点可以存储多个元素。由于它时查找树，所有元素之间存在某种特定的排序关系 多路查找树 4 中特殊形式 2-3 树，2-3-4 树，b 树，b+树 在二叉树中，每个节点有数据项，最多两个子节点，如果 允许每个节点有更多的数据项和更多的子节点，就是多叉树 2-3 树 其中每一个结点都具有两个孩子或者三个孩子 一个 2 节点包含一个元素和两个孩子或者没有孩子 一个 3 结点包含一小一大两个元素和三个孩子或者没有孩子 2=3 树所有叶子节点都在同一层（只要是 B 树都满足这个条件） 2-3 树是由 2，3 结点构成的 B 树 B 树是一种平衡的多路查找树，2-3 树和 2-3-4 树都是 B 树的特例。 节点最大的孩子数目称为 B 树的阶 因此 2-3 树是 3 阶的 B 树，2-3-4 树 是 4 阶的 B 树。 一个 m 阶的 b 树具有如下属性 如果根结点不是叶子结点，则至少有两颗子树 每一个非根的分支节点都有 k-1 个元素和 k 个孩子，其中 m/2&lt;=k&lt;=m 每一个叶子节点 n 都有 k-1 个元素，其中 m/2&lt;=k&lt;=m. 所有叶子节点都位于同一层次 B 树上查找的过程式一个顺指针查找结点和再结点中查找关键字的交叉过程 B 树是怎么做到减少内存与外存交换数据的 外存，比如硬盘，将所有信息分割成相等大小的页面，每次硬盘读写都是一个 或多个完整的页面，对于一个硬盘来说，一页的长度可能是 211 到 214 个字节。 在一个典型的 B 树应用中，要处理的硬盘数据量很大，因此无法一次全部装入 到内存。因此我们会对 B 树进行调整，使得 B 树的阶数（结点的元素）与硬盘存储 的页面大小相匹配。通过这种方式，在有限内存的情况下，每一次磁盘的访问我们 都可以获得最大数据量的数据。由于 b 树每结点可以具有比二叉树多得多的元素 ，所以与二叉树的操作不同，它们减少了必须访问结点和数据块的数量，从而提高了性能 。可以说，b 树的数据结构就是为内外存的数据交互准备的。 B+树 对于树结构来说，我们可以通过中序遍历来顺序查找树中的元素，这一切都是在 内存中进行。 可是在 b 树结构中，我们往返于每个节点之间意味着，我们必须得在硬盘的页面 之间进行多次访问。为了能够解决所有元素遍历等基本问题，我们在 原有的 B 树结构基础上，加上了新的元素组织方式，这就是 B+树。 B+树是应文件系统所需而出的一种 B 树的变形树，严格意义上讲，不是数据 结构定义的树了。 " }, { "title": "赫夫曼树", "url": "/posts/datastructure8/", "categories": "数据结构与算法", "tags": "tree", "date": "2020-06-23 14:16:00 +0800", "content": "赫夫曼树 树的带权路径长度：树的带权路径长度规定为所有的叶子节点的带权路径长度之和（wpl 的和），wpl 最小的树就是赫夫曼树 给定 n 个权值作为 n 个叶子节点，构造一颗二叉树，若该树的带权路径达到最小（wpl），这样的二叉树称为最优二叉树。 赫夫曼树是带权路径最短的树，权越大离根结点距离越近 构建赫夫曼树 构建赫夫曼树的思路 从小到大进行排序，每个数据看成一个节点，每个节点看成最简单的二叉树 取出根节点权重值最小的两颗二叉树 组成一颗新的二叉树，新的二叉树的根节点权值是前面两颗二叉树的根节点权值的和 再将这颗新的二叉树，以根节点的权值大小再次排序 不断重复 1-4 的步骤，直到数列中，所有的数据都被处理。就得到一颗赫夫曼树。 package com.learn.huffman; import java.util.ArrayList; import java.util.Collections; public class HuffmanTree { public static void main(String[] args) { int[] arr=new int[]{13,7,8,3,29,6,1}; createHuffManTree(arr); } //创建赫夫曼树 public static void createHuffManTree(int[] arr) { ArrayList&lt;Node&gt; nodes=new ArrayList&lt;Node&gt;(arr.length); for(int i=0;i&lt;arr.length;i++) { nodes.add(new Node(arr[i])); } while (nodes.size()&gt;1) { //排序 Collections.sort(nodes); Node leftNode =nodes.get(0); Node rightNode = nodes.get(1); Node root= new Node(leftNode.value+rightNode.value); root.left=leftNode; root.right = rightNode; nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(root); } //前序遍历 nodes nodes.get(0).preOrder(); } } class Node implements Comparable&lt;Node&gt;{ int value; Node left; Node right; public Node(int value) { this.value = value; } public void setLeft(Node left) { this.left = left; } public void setRight(Node right) { this.right = right; } public int getValue() { return value; } public Node getLeft() { return left; } public Node getRight() { return right; } /** * 前序遍历 */ public void preOrder() { System.out.println(this.toString()); if(left!=null) { left.preOrder(); } if(right!=null) { right.preOrder(); } } @Override //从小到大排序 public int compareTo(Node o) { return this.value-o.value; } @Override public String toString() { return this.value+\"\"; } } 赫夫曼编码 赫夫曼编码是赫夫曼树在电讯通信中的经典应用之一 赫夫曼编码广泛地用于数据文件压缩，其压缩率通常在 20%~90%之间 赫夫曼码是可变字长编码（vlc）的一种 赫夫曼编码实现 前缀编码：字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码，即不能匹配到重复的编码 根据赫夫曼树，给各个字符，规定编码，向左的路径为 0，向右为 1 ，前缀编码，匹配的时候不会出现多意性（因为每一个字符都有唯一路径） package com.learn.huffmancode; import java.util.*; //赫夫曼编码实现 public class huffManCodeDemo { public static void main(String[] args) { String str = \"i like like like java do you like a java\"; huffManCode tree = new huffManCode(str.getBytes()); HashMap&lt;Byte, String&gt; huffmanCodes = tree.getHuffManCode(); var bytes = huffManZip(str.getBytes(),huffmanCodes); System.out.println( new String(decode(bytes,huffmanCodes)) ); } /** * 解压缩赫夫曼编码后的byte数组 * 1.将byte还原成二进制字符串 * @param byteArr byteArr是将赫夫曼表，按字符顺序对应的二进制字符串按8位组成一个byte存储后的数组，最后一位不够8位则高位补0 * @param huffManCodes 对应的哈夫曼编码表 * @return */ public static byte[] decode(byte[] byteArr,HashMap&lt;Byte,String&gt; huffManCodes) { //转置哈夫曼编码 HashMap&lt;String,Byte&gt; reverseHuffManCodes = new HashMap&lt;&gt;(); for(Map.Entry&lt;Byte,String&gt; entry:huffManCodes.entrySet()) { reverseHuffManCodes.put(entry.getValue(),entry.getKey()); } StringBuilder bitString =new StringBuilder(); for(int i=0;i&lt;byteArr.length;i++) { bitString.append(byteToBitString(i!=byteArr.length-1,byteArr[i])); } int mark =0; List&lt;Byte&gt; lst= new ArrayList&lt;&gt;() ; for(int i=0;i&lt;bitString.length();i++) { var temp=reverseHuffManCodes.get(bitString.substring(mark,i)); if(temp!=null) { lst.add(temp); mark=i; } } lst.add(reverseHuffManCodes.get(bitString.substring(mark))); byte[] original = new byte[lst.size()]; for(int i=0;i&lt;lst.size();i++) { original[i]=lst.get(i); } return original; } /** * 将一个byte转成二进制的字符串 * @param flag 是否需要进行补位，如果是最后一个字节不需要补高位 * @return */ public static String byteToBitString(boolean flag,byte b) { int temp =b; if(flag) { temp |=256; } String bitString = Integer.toBinaryString(temp); if(flag) { bitString = bitString.substring(bitString.length()-8); } return bitString; } /** * @param bytes 需要压缩byte【】 * @return 返回赫夫曼编码处理后的 byte[] * 举例： String content = \"i like like like java do you like a java\"; =》 byte[] contentBytes = content.getBytes(); * 返回的是 字符串 \"1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100\" * =&gt; 对应的 byte[] huffmanCodeBytes ，即 8位对应一个 byte,放入到 huffmanCodeBytes * huffmanCodeBytes[0] = 10101000(补码) =&gt; byte [推导 10101000=&gt; 10101000 - 1 =&gt; 10100111(反码)=&gt; 11011000= -88 ] * huffmanCodeBytes[1] = -88 */ public static byte[] huffManZip( byte[] bytes,HashMap&lt;Byte, String&gt; huffmanCodes) { StringBuilder builder = new StringBuilder(); //获取每个字符对应的赫夫曼路径编码 for (var b : bytes) { builder.append(huffmanCodes.get(b)); } String huffStr = builder.toString(); int len = (huffStr.length() + 7) / 8; byte[] zipBytes = new byte[len]; //每8位二进制转成一个byte类型数据 //获取长度 int index = 0; for (int i = 0; i &lt; huffStr.length(); i += 8) { String byteStr; if ((i + 8) &lt; huffStr.length()) { byteStr = huffStr.substring(i, i + 8); } else { byteStr = huffStr.substring(i); } zipBytes[index] = (byte)Integer.parseInt(byteStr,2); index++; } return zipBytes; } } /** * 将字符串转成哈夫曼编码 */ class huffManCode { //根节点 Node root; HashMap&lt;Byte, String&gt; huffCodeMap = new HashMap&lt;Byte, String&gt;(); /** * 把所有字符转换成哈夫曼树节点形式 * * @param bytes 目标字符串 * @return 所欲节点列表 */ ArrayList&lt;Node&gt; createNodeLst(byte[] bytes) { ArrayList&lt;Node&gt; arrayList = new ArrayList&lt;&gt;(); HashMap&lt;Byte, Node&gt; nodeDictionary = new HashMap&lt;Byte, Node&gt;(); for (int i = 0; i &lt; bytes.length; i++) { Byte data = bytes[i]; Node node = nodeDictionary.get(data); if (node == null) { node = new Node(bytes[i], 0); node.data = data; node.weight++; nodeDictionary.put(data, node); } else { node.weight++; } } for (var nodeSet : nodeDictionary.entrySet()) { arrayList.add(nodeSet.getValue()); } return arrayList; } public huffManCode(byte[] bytes) { ArrayList&lt;Node&gt; nodes = createNodeLst(bytes); while (nodes.size() &gt; 1) { Collections.sort(nodes); Node left = nodes.get(0); Node right = nodes.get(1); Node root = new Node(null, left.weight + right.weight); root.lNode = left; root.rNode = right; nodes.remove(left); nodes.remove(right); nodes.add(root); } root = nodes.get(0); } public void print() { System.out.println(getHuffManCode()); } public HashMap&lt;Byte, String&gt; getHuffManCode() { getHuffManCode(root, \"\", new StringBuilder()); return huffCodeMap; } void getHuffManCode(Node node, String code, StringBuilder builder) { StringBuilder tempBulider = new StringBuilder(builder); tempBulider.append(code); if (node != null) { //找到叶子节点 if (node.data == null) { //向左0 向右 1 getHuffManCode(node.lNode, \"0\", tempBulider); getHuffManCode(node.rNode, \"1\", tempBulider); } else { huffCodeMap.put(node.data, tempBulider.toString()); } } } } class Node implements Comparable&lt;Node&gt; { //字符 Byte data; //权值 public int weight = 0; //左子结点 Node lNode; //右子结点 Node rNode; public Node(Byte data, int weight) { this.data = data; this.weight = weight; } public Node getlNode() { return lNode; } public void setlNode(Node lNode) { this.lNode = lNode; } public Node getrNode() { return rNode; } public void setrNode(Node rNode) { this.rNode = rNode; } @Override public int compareTo(Node o) { return this.weight - o.weight; } } 赫夫曼编码压缩数据注意事项 如果文件本身已经是经过压缩处理的，那么使用赫夫曼编码再压缩效率会不明显，比如压缩视频，ppt 等 赫夫曼编码是按字节处理的，因此可以处理所有文件（二级制文件，文本文件） 如果一个文件重复的内容不是很多，压缩效果也不会很明显 " }, { "title": "树", "url": "/posts/datastructure7/", "categories": "数据结构与算法", "tags": "tree", "date": "2020-06-18 11:16:00 +0800", "content": "树与数组链表的比较 数组存储方式的分析 优点：通过下标访问元素，速度快。对于有序数组，还可以使用二分查找提高检索速度 缺点： 如果要检索具体某个值，或者插入值，会整体移动，效率低 链式存储方式的分析 优点：插入，删除效率较高 缺点：检索效率低 树存储方式分析 提高数据存储，读取的效率，比如利用二叉排序树，即保证了数据查询的效率，也保证了数据修改，插入，删除的效率 二叉树 每个节点最多只有两个子节点的一种形式称为二叉树 二叉树的子节点分为左节点和右节点 如果该二叉树的所有叶子节点都在最后一层，并且节点总数 2^n-1 n 为层数，则我们称为满二叉树 如果该二叉树所有叶子节点都在最后一层或者倒数第二次，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树 相关概念 节点 根节点 父节点 子节点 叶子节点（没有子节点） 节点的权 路径（从 root 节点找到该节点的路线） 层 子树 树的高度(最大层数) 森林（多颗子树构成森林） 遍历 二叉树遍历（父节点输出位置对应了 前序 中序 后序 ，左子树始终比右子树先输出） 前序遍历： 先输出父节点，再遍历左子树和右子树 中序遍历：先遍历左子树，再输出父节点，再遍历右子树 后续遍历：先遍历左子树，再遍历右子树，最后输出父节点 查询与删除遍历类似 public static void main(String[] args) { HeroTree heroTree = new HeroTree(); //创建需要的结点 HeroTreeNode root = new HeroTreeNode(1, \"宋江\"); HeroTreeNode node2 = new HeroTreeNode(2, \"吴用\"); HeroTreeNode node3 = new HeroTreeNode(3, \"卢俊义\"); HeroTreeNode node4 = new HeroTreeNode(4, \"林冲\"); HeroTreeNode node5 = new HeroTreeNode(5, \"关胜\"); //说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树 root.setLeft(node2); root.setRight(node3); node3.setRight(node4); node3.setLeft(node5); heroTree.setRoot(root); heroTree.DelNode(2); //测试 \t\tSystem.out.println(\"前序遍历\"); // 1,2,3,5,4 heroTree.preOrder(); // // //测试 //\t\tSystem.out.println(\"中序遍历\"); //\t\theroTree.midOrder(); // 2,1,5,3,4 // //\t\tSystem.out.println(\"后序遍历\"); // heroTree.postOrder(); // 2,5,4,3,1 // HeroTreeNode node = heroTree.PostSearch(5); // if(node!=null) // { // node.ToString(); // }else { // System.out.println(\"target node is null\"); // } } } class HeroTree{ HeroTreeNode root; public void setRoot(HeroTreeNode root) { this.root=root; } public void preOrder() { if(root!=null) { root.PreOrder(); } } public void midOrder() { if(root!=null) { root.MiddleOrder(); } } public void postOrder() { if(root!=null) { root.PostOrder(); } } // public HeroTreeNode PreSearch(int id) { if(root!=null) { return root.PreSearch(id); } return null; } public HeroTreeNode MidSearch(int id) { if(root!=null) { return root.MidSearch(id); } return null; } public HeroTreeNode PostSearch(int id) { if(root!=null) { return root.PostSearch(id); } return null; } //删除节点 /** * 1.如果是root则置空 * 2.判断左子节点是否是目标 * 3.判断右子节点是否是目标 * 4.1-3不满足，则递归左子节点 * 5.1-4不满足，则递归右子节点 * @param id 待删除节点 */ public void DelNode(int id) { if(root==null) { return; } DelNode(root,id); } //删除节点 void DelNode(HeroTreeNode node,int id) { if(node.id==id) { node=null; return; }else if(node.left!=null &amp;&amp; node.left.id==id) { node.left=null; return; }else if(node.right!=null&amp;&amp;node.right.id==id) { node.right=null; return; } if(node.left!=null) { DelNode(node.left,id); } if(node.right!=null) { DelNode(node.right,id); } } } class HeroTreeNode{ public int id; public String name; //左子节点 HeroTreeNode left; //右子几点 HeroTreeNode right; public void setLeft(HeroTreeNode node) {left=node;} public void setRight(HeroTreeNode node) { right=node; } public HeroTreeNode(int id,String name) { this.id=id; this.name=name; } public void ToString() { System.out.println(\"id:\"+id+\" name:\"+name); } /** * 前序遍历 根节点 左节点 右节点 */ public void PreOrder() { this.ToString(); if(left!=null) { left.PreOrder(); } if(right!=null) { right.PreOrder(); } } /** * 中序遍历 左节点 根节点 右节点 */ public void MiddleOrder() { if(left!=null) { left.MiddleOrder(); } this.ToString(); if(right!=null) { right.MiddleOrder(); } } /** * 后序遍历 左节点 右节点 根节点 */ public void PostOrder() { if(left!=null) { left.PostOrder(); } if(right!=null) { right.PostOrder(); } this.ToString(); } public HeroTreeNode PreSearch(int id) { System.out.println(\"PreSearch\"); if(this.id==id) { return this; } HeroTreeNode node=null; if(left!=null) { node = left.PreSearch(id); } if(node!=null) { return node; } if(right!=null) { node= right.PreSearch(id); } return node; } public HeroTreeNode MidSearch(int id) { System.out.println(\"MidSearch\"); HeroTreeNode node=null; if(left!=null) { node = left.MidSearch(id); } if(node!=null) { return node; } if(this.id==id) { return this; } if(right!=null) { node= right.MidSearch(id); } return node; } public HeroTreeNode PostSearch(int id) { System.out.println(\"PostSearch\"); HeroTreeNode node=null; if(left!=null) { node = left.PostSearch(id); } if(node!=null) { return node; } if(right!=null) { node= right.PostSearch(id); } if(node!=null) { return node; } if(this.id==id) { return this; } return null; } 顺序存储二叉树 应用:堆排序 从数据存储来看，树的存储方式与数组的存储方式可以互相转换 二叉树的节点以数组方式存放，并且仍然可以进行前序遍历，中序遍历，和后序遍历 顺序存储二叉树的特点 顺序二叉树通常指考虑完全二叉树 第 n 个元素的左子节点为 2*n+1 第 n 个元素的右子节点为 2*n+2 第 n 元素的父节点为（n-1）/2 n 表示二叉树的第几个元素（从 0 开始) 线索化二叉树 1.n 个节点的二叉链表中含有 2n-(n-1)=n+1 个空指针，利用二叉树链表中 的空指针域，存放指向节点在某种遍历顺序下的前驱和后继节点的指针 2.这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树（Threaded BinaryTree）。根据线索性质的不同，线索二叉树可分为前序线索二叉树，中序线索二叉树和后序线索二叉树三种 3.一个节点的前一个节点，称为前驱节点 4.一个节点的后一个节点，称为后继节点 优点 创建线索化二叉树时可以充分利用空指针域 通过前驱后继，可以快速索引节点，不必再次遍历 线索化二叉树以及遍历线索化二叉树 package com.learn.tree; public class BinaryTree { public static void main(String[] args) { ThreadedBinaryTree heroTree = new ThreadedBinaryTree(); //创建需要的结点 HeroTreeNode root = new HeroTreeNode(1, \"tom\"); HeroTreeNode node2 = new HeroTreeNode(3, \"jack\"); HeroTreeNode node3 = new HeroTreeNode(6, \"smith\"); HeroTreeNode node4 = new HeroTreeNode(8, \"mary\"); HeroTreeNode node5 = new HeroTreeNode(10, \"king\"); HeroTreeNode node6 = new HeroTreeNode(14, \"dim\"); //二叉树，后面我们要递归创建, 现在简单处理使用手动创建 root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); heroTree.setRoot(root); heroTree.Threaded(); // System.out.print(node2.leftType+\" \"+node2.rightType); heroTree.ThreadedList(); // node4.ToString(); // System.out.print(node4.leftType); // heroTree.DelNode(2); //测试 //\t\tSystem.out.println(\"前序遍历\"); // 1,2,3,5,4 // heroTree.preOrder(); // // //测试 //\t\tSystem.out.println(\"中序遍历\"); //\t\theroTree.midOrder(); // 2,1,5,3,4 // //\t\tSystem.out.println(\"后序遍历\"); // heroTree.postOrder(); // 2,5,4,3,1 // HeroTreeNode node = heroTree.PostSearch(5); // if(node!=null) // { // node.ToString(); // }else { // System.out.println(\"target node is null\"); // } } } class HeroTree{ HeroTreeNode root; public void setRoot(HeroTreeNode root) { this.root=root; } public void preOrder() { if(root!=null) { root.PreOrder(); } } public void midOrder() { if(root!=null) { root.MiddleOrder(); } } public void postOrder() { if(root!=null) { root.PostOrder(); } } // public HeroTreeNode PreSearch(int id) { if(root!=null) { return root.PreSearch(id); } return null; } public HeroTreeNode MidSearch(int id) { if(root!=null) { return root.MidSearch(id); } return null; } public HeroTreeNode PostSearch(int id) { if(root!=null) { return root.PostSearch(id); } return null; } //删除节点 /** * 1.如果是root则置空 * 2.判断左子节点是否是目标 * 3.判断右子节点是否是目标 * 4.1-3不满足，则递归左子节点 * 5.1-4不满足，则递归右子节点 * @param id 待删除节点 */ public void DelNode(int id) { if(root==null) { return; } DelNode(root,id); } //删除节点 void DelNode(HeroTreeNode node,int id) { if(node.id==id) { node=null; return; }else if(node.left!=null &amp;&amp; node.left.id==id) { node.left=null; return; }else if(node.right!=null&amp;&amp;node.right.id==id) { node.right=null; return; } if(node.left!=null) { DelNode(node.left,id); } if(node.right!=null) { DelNode(node.right,id); } } } class HeroTreeNode{ public int id; public String name; //节点类型 public int leftType = 0; public int rightType =0 ; //左子节点 HeroTreeNode left; //右子几点 HeroTreeNode right; public void setLeft(HeroTreeNode node) {left=node;} public void setRight(HeroTreeNode node) { right=node; } public HeroTreeNode(int id,String name) { this.id=id; this.name=name; } public void ToString() { System.out.println(\"id:\"+id+\" name:\"+name); } /** * 前序遍历 根节点 左节点 右节点 */ public void PreOrder() { this.ToString(); if(left!=null) { left.PreOrder(); } if(right!=null) { right.PreOrder(); } } /** * 中序遍历 左节点 根节点 右节点 */ public void MiddleOrder() { if(left!=null) { left.MiddleOrder(); } this.ToString(); if(right!=null) { right.MiddleOrder(); } } /** * 后序遍历 左节点 右节点 根节点 */ public void PostOrder() { if(left!=null) { left.PostOrder(); } if(right!=null) { right.PostOrder(); } this.ToString(); } public HeroTreeNode PreSearch(int id) { System.out.println(\"PreSearch\"); if(this.id==id) { return this; } HeroTreeNode node=null; if(left!=null) { node = left.PreSearch(id); } if(node!=null) { return node; } if(right!=null) { node= right.PreSearch(id); } return node; } public HeroTreeNode MidSearch(int id) { System.out.println(\"MidSearch\"); HeroTreeNode node=null; if(left!=null) { node = left.MidSearch(id); } if(node!=null) { return node; } if(this.id==id) { return this; } if(right!=null) { node= right.MidSearch(id); } return node; } public HeroTreeNode PostSearch(int id) { System.out.println(\"PostSearch\"); HeroTreeNode node=null; if(left!=null) { node = left.PostSearch(id); } if(node!=null) { return node; } if(right!=null) { node= right.PostSearch(id); } if(node!=null) { return node; } if(this.id==id) { return this; } return null; } } //中序线索化二叉树 class ThreadedBinaryTree extends HeroTree { HeroTreeNode pre=null; public void Threaded() { Threaded(root); } public void Threaded(HeroTreeNode node) { if(node==null) { return; } Threaded(node.left); //线索化前驱节点 if(node.left==null) { node.left=pre; //指定type node.leftType=1; } if(pre!=null &amp;&amp; pre.right==null) { pre.right=node; pre.rightType=1; } pre=node; Threaded(node.right); } public void ThreadedList() { HeroTreeNode node = root; while(node != null) { //循环的找到leftType == 1的结点，第一个找到就是8结点 //后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化 //处理后的有效结点 while(node.leftType == 0) { node = node.left; } //打印当前这个结点 node.ToString(); //如果当前结点的右指针指向的是后继结点,就一直输出 while(node.rightType == 1) { //获取到当前结点的后继结点 node = node.right; node.ToString(); } //替换这个遍历的结点 node = node.right; } } } " }, { "title": "树", "url": "/posts/datastructure/", "categories": "数据结构与算法", "tags": "tree", "date": "2020-06-18 11:16:00 +0800", "content": "树与数组链表的比较 数组存储方式的分析 优点：通过下标访问元素，速度快。对于有序数组，还可以使用二分查找提高检索速度 缺点： 如果要检索具体某个值，或者插入值，会整体移动，效率低 链式存储方式的分析 优点：插入，删除效率较高 缺点：检索效率低 树存储方式分析 提高数据存储，读取的效率，比如利用二叉排序树，即保证了数据查询的效率，也保证了数据修改，插入，删除的效率 二叉树 每个节点最多只有两个子节点的一种形式称为二叉树 二叉树的子节点分为左节点和右节点 如果该二叉树的所有叶子节点都在最后一层，并且节点总数 2^n-1 n 为层数，则我们称为满二叉树 如果该二叉树所有叶子节点都在最后一层或者倒数第二次，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树 相关概念 节点 根节点 父节点 子节点 叶子节点（没有子节点） 节点的权 路径（从 root 节点找到该节点的路线） 层 子树 树的高度(最大层数) 森林（多颗子树构成森林） 遍历 二叉树遍历（父节点输出位置对应了 前序 中序 后序 ，左子树始终比右子树先输出） 前序遍历： 先输出父节点，再遍历左子树和右子树 中序遍历：先遍历左子树，再输出父节点，再遍历右子树 后续遍历：先遍历左子树，再遍历右子树，最后输出父节点 查询与删除遍历类似 public static void main(String[] args) { HeroTree heroTree = new HeroTree(); //创建需要的结点 HeroTreeNode root = new HeroTreeNode(1, \"宋江\"); HeroTreeNode node2 = new HeroTreeNode(2, \"吴用\"); HeroTreeNode node3 = new HeroTreeNode(3, \"卢俊义\"); HeroTreeNode node4 = new HeroTreeNode(4, \"林冲\"); HeroTreeNode node5 = new HeroTreeNode(5, \"关胜\"); //说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树 root.setLeft(node2); root.setRight(node3); node3.setRight(node4); node3.setLeft(node5); heroTree.setRoot(root); heroTree.DelNode(2); //测试 \t\tSystem.out.println(\"前序遍历\"); // 1,2,3,5,4 heroTree.preOrder(); // // //测试 //\t\tSystem.out.println(\"中序遍历\"); //\t\theroTree.midOrder(); // 2,1,5,3,4 // //\t\tSystem.out.println(\"后序遍历\"); // heroTree.postOrder(); // 2,5,4,3,1 // HeroTreeNode node = heroTree.PostSearch(5); // if(node!=null) // { // node.ToString(); // }else { // System.out.println(\"target node is null\"); // } } } class HeroTree{ HeroTreeNode root; public void setRoot(HeroTreeNode root) { this.root=root; } public void preOrder() { if(root!=null) { root.PreOrder(); } } public void midOrder() { if(root!=null) { root.MiddleOrder(); } } public void postOrder() { if(root!=null) { root.PostOrder(); } } // public HeroTreeNode PreSearch(int id) { if(root!=null) { return root.PreSearch(id); } return null; } public HeroTreeNode MidSearch(int id) { if(root!=null) { return root.MidSearch(id); } return null; } public HeroTreeNode PostSearch(int id) { if(root!=null) { return root.PostSearch(id); } return null; } //删除节点 /** * 1.如果是root则置空 * 2.判断左子节点是否是目标 * 3.判断右子节点是否是目标 * 4.1-3不满足，则递归左子节点 * 5.1-4不满足，则递归右子节点 * @param id 待删除节点 */ public void DelNode(int id) { if(root==null) { return; } DelNode(root,id); } //删除节点 void DelNode(HeroTreeNode node,int id) { if(node.id==id) { node=null; return; }else if(node.left!=null &amp;&amp; node.left.id==id) { node.left=null; return; }else if(node.right!=null&amp;&amp;node.right.id==id) { node.right=null; return; } if(node.left!=null) { DelNode(node.left,id); } if(node.right!=null) { DelNode(node.right,id); } } } class HeroTreeNode{ public int id; public String name; //左子节点 HeroTreeNode left; //右子几点 HeroTreeNode right; public void setLeft(HeroTreeNode node) {left=node;} public void setRight(HeroTreeNode node) { right=node; } public HeroTreeNode(int id,String name) { this.id=id; this.name=name; } public void ToString() { System.out.println(\"id:\"+id+\" name:\"+name); } /** * 前序遍历 根节点 左节点 右节点 */ public void PreOrder() { this.ToString(); if(left!=null) { left.PreOrder(); } if(right!=null) { right.PreOrder(); } } /** * 中序遍历 左节点 根节点 右节点 */ public void MiddleOrder() { if(left!=null) { left.MiddleOrder(); } this.ToString(); if(right!=null) { right.MiddleOrder(); } } /** * 后序遍历 左节点 右节点 根节点 */ public void PostOrder() { if(left!=null) { left.PostOrder(); } if(right!=null) { right.PostOrder(); } this.ToString(); } public HeroTreeNode PreSearch(int id) { System.out.println(\"PreSearch\"); if(this.id==id) { return this; } HeroTreeNode node=null; if(left!=null) { node = left.PreSearch(id); } if(node!=null) { return node; } if(right!=null) { node= right.PreSearch(id); } return node; } public HeroTreeNode MidSearch(int id) { System.out.println(\"MidSearch\"); HeroTreeNode node=null; if(left!=null) { node = left.MidSearch(id); } if(node!=null) { return node; } if(this.id==id) { return this; } if(right!=null) { node= right.MidSearch(id); } return node; } public HeroTreeNode PostSearch(int id) { System.out.println(\"PostSearch\"); HeroTreeNode node=null; if(left!=null) { node = left.PostSearch(id); } if(node!=null) { return node; } if(right!=null) { node= right.PostSearch(id); } if(node!=null) { return node; } if(this.id==id) { return this; } return null; } 顺序存储二叉树 应用:堆排序 从数据存储来看，树的存储方式与数组的存储方式可以互相转换 二叉树的节点以数组方式存放，并且仍然可以进行前序遍历，中序遍历，和后序遍历 顺序存储二叉树的特点 顺序二叉树通常指考虑完全二叉树 第 n 个元素的左子节点为 2*n+1 第 n 个元素的右子节点为 2*n+2 第 n 元素的父节点为（n-1）/2 n 表示二叉树的第几个元素（从 0 开始) 线索化二叉树 1.n 个节点的二叉链表中含有 2n-(n-1)=n+1 个空指针，利用二叉树链表中 的空指针域，存放指向节点在某种遍历顺序下的前驱和后继节点的指针 2.这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树（Threaded BinaryTree）。根据线索性质的不同，线索二叉树可分为前序线索二叉树，中序线索二叉树和后序线索二叉树三种 3.一个节点的前一个节点，称为前驱节点 4.一个节点的后一个节点，称为后继节点 优点 创建线索化二叉树时可以充分利用空指针域 通过前驱后继，可以快速索引节点，不必再次遍历 线索化二叉树以及遍历线索化二叉树 package com.learn.tree; public class BinaryTree { public static void main(String[] args) { ThreadedBinaryTree heroTree = new ThreadedBinaryTree(); //创建需要的结点 HeroTreeNode root = new HeroTreeNode(1, \"tom\"); HeroTreeNode node2 = new HeroTreeNode(3, \"jack\"); HeroTreeNode node3 = new HeroTreeNode(6, \"smith\"); HeroTreeNode node4 = new HeroTreeNode(8, \"mary\"); HeroTreeNode node5 = new HeroTreeNode(10, \"king\"); HeroTreeNode node6 = new HeroTreeNode(14, \"dim\"); //二叉树，后面我们要递归创建, 现在简单处理使用手动创建 root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); heroTree.setRoot(root); heroTree.Threaded(); // System.out.print(node2.leftType+\" \"+node2.rightType); heroTree.ThreadedList(); // node4.ToString(); // System.out.print(node4.leftType); // heroTree.DelNode(2); //测试 //\t\tSystem.out.println(\"前序遍历\"); // 1,2,3,5,4 // heroTree.preOrder(); // // //测试 //\t\tSystem.out.println(\"中序遍历\"); //\t\theroTree.midOrder(); // 2,1,5,3,4 // //\t\tSystem.out.println(\"后序遍历\"); // heroTree.postOrder(); // 2,5,4,3,1 // HeroTreeNode node = heroTree.PostSearch(5); // if(node!=null) // { // node.ToString(); // }else { // System.out.println(\"target node is null\"); // } } } class HeroTree{ HeroTreeNode root; public void setRoot(HeroTreeNode root) { this.root=root; } public void preOrder() { if(root!=null) { root.PreOrder(); } } public void midOrder() { if(root!=null) { root.MiddleOrder(); } } public void postOrder() { if(root!=null) { root.PostOrder(); } } // public HeroTreeNode PreSearch(int id) { if(root!=null) { return root.PreSearch(id); } return null; } public HeroTreeNode MidSearch(int id) { if(root!=null) { return root.MidSearch(id); } return null; } public HeroTreeNode PostSearch(int id) { if(root!=null) { return root.PostSearch(id); } return null; } //删除节点 /** * 1.如果是root则置空 * 2.判断左子节点是否是目标 * 3.判断右子节点是否是目标 * 4.1-3不满足，则递归左子节点 * 5.1-4不满足，则递归右子节点 * @param id 待删除节点 */ public void DelNode(int id) { if(root==null) { return; } DelNode(root,id); } //删除节点 void DelNode(HeroTreeNode node,int id) { if(node.id==id) { node=null; return; }else if(node.left!=null &amp;&amp; node.left.id==id) { node.left=null; return; }else if(node.right!=null&amp;&amp;node.right.id==id) { node.right=null; return; } if(node.left!=null) { DelNode(node.left,id); } if(node.right!=null) { DelNode(node.right,id); } } } class HeroTreeNode{ public int id; public String name; //节点类型 public int leftType = 0; public int rightType =0 ; //左子节点 HeroTreeNode left; //右子几点 HeroTreeNode right; public void setLeft(HeroTreeNode node) {left=node;} public void setRight(HeroTreeNode node) { right=node; } public HeroTreeNode(int id,String name) { this.id=id; this.name=name; } public void ToString() { System.out.println(\"id:\"+id+\" name:\"+name); } /** * 前序遍历 根节点 左节点 右节点 */ public void PreOrder() { this.ToString(); if(left!=null) { left.PreOrder(); } if(right!=null) { right.PreOrder(); } } /** * 中序遍历 左节点 根节点 右节点 */ public void MiddleOrder() { if(left!=null) { left.MiddleOrder(); } this.ToString(); if(right!=null) { right.MiddleOrder(); } } /** * 后序遍历 左节点 右节点 根节点 */ public void PostOrder() { if(left!=null) { left.PostOrder(); } if(right!=null) { right.PostOrder(); } this.ToString(); } public HeroTreeNode PreSearch(int id) { System.out.println(\"PreSearch\"); if(this.id==id) { return this; } HeroTreeNode node=null; if(left!=null) { node = left.PreSearch(id); } if(node!=null) { return node; } if(right!=null) { node= right.PreSearch(id); } return node; } public HeroTreeNode MidSearch(int id) { System.out.println(\"MidSearch\"); HeroTreeNode node=null; if(left!=null) { node = left.MidSearch(id); } if(node!=null) { return node; } if(this.id==id) { return this; } if(right!=null) { node= right.MidSearch(id); } return node; } public HeroTreeNode PostSearch(int id) { System.out.println(\"PostSearch\"); HeroTreeNode node=null; if(left!=null) { node = left.PostSearch(id); } if(node!=null) { return node; } if(right!=null) { node= right.PostSearch(id); } if(node!=null) { return node; } if(this.id==id) { return this; } return null; } } //中序线索化二叉树 class ThreadedBinaryTree extends HeroTree { HeroTreeNode pre=null; public void Threaded() { Threaded(root); } public void Threaded(HeroTreeNode node) { if(node==null) { return; } Threaded(node.left); //线索化前驱节点 if(node.left==null) { node.left=pre; //指定type node.leftType=1; } if(pre!=null &amp;&amp; pre.right==null) { pre.right=node; pre.rightType=1; } pre=node; Threaded(node.right); } public void ThreadedList() { HeroTreeNode node = root; while(node != null) { //循环的找到leftType == 1的结点，第一个找到就是8结点 //后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化 //处理后的有效结点 while(node.leftType == 0) { node = node.left; } //打印当前这个结点 node.ToString(); //如果当前结点的右指针指向的是后继结点,就一直输出 while(node.rightType == 1) { //获取到当前结点的后继结点 node = node.right; node.ToString(); } //替换这个遍历的结点 node = node.right; } } } " }, { "title": "哈希表", "url": "/posts/datastructure6/", "categories": "数据结构与算法", "tags": "hashmap", "date": "2020-06-17 11:16:00 +0800", "content": "哈希表 根据关键码值（key value）而直接进行访问的数据结构 它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度， 这个映射函数叫做散列函数，存放记录的数组叫做散列表。 常见的哈希表结构 数组+链表 数组+二叉树 哈希表可以同时管理多条链表 package com.learn.hash; import java.util.Scanner; public class HashTab { public static void main(String[] args) { //创建哈希表 HashTable hashTab = new HashTable(7); //写一个简单的菜单 String key = \"\"; Scanner scanner = new Scanner(System.in); while(true) { System.out.println(\"add: 添加雇员\"); System.out.println(\"list: 显示雇员\"); System.out.println(\"find: 查找雇员\"); System.out.println(\"exit: 退出系统\"); key = scanner.next(); switch (key) { case \"add\": System.out.println(\"输入id\"); int id = scanner.nextInt(); System.out.println(\"输入名字\"); String name = scanner.next(); //创建 雇员 Emp emp = new Emp(id, name); hashTab.Add(emp); break; case \"list\": hashTab.List(); break; case \"find\": System.out.println(\"请输入要查找的id\"); id = scanner.nextInt(); //hashTab.findEmpById(id); break; case \"exit\": scanner.close(); System.exit(0); default: break; } } } } class HashTable{ EmpLinkedList[] empLinkedListArray; private int size; public HashTable(int size) { empLinkedListArray =new EmpLinkedList[size]; for(int i=0;i&lt;size;i++) { EmpLinkedList list =new EmpLinkedList(); empLinkedListArray[i]=list; } this.size=size; } public void Add(Emp value) { EmpLinkedList list = empLinkedListArray[HashFun(value.id)]; list.Add(value); } //散列函数 public int HashFun(int id) { return id%size; } public void List() { for(int i=0;i&lt;empLinkedListArray.length;i++) { empLinkedListArray[i].List(); } } } class Emp{ public int id; public String name; public Emp(int id,String name) { this.id=id; this.name=name; } public void ToString() { System.out.println(\"id:\"+id+\" name:\"+name); } public Emp next; } class EmpLinkedList { public Emp head; public EmpLinkedList() { head=new Emp(0,null); } public void Add(Emp value) { Emp temp = head; while(temp.next!=null) { temp = temp.next; } temp.next=value; } //list 所有元素 public void List() { Emp temp=head.next; while (temp!=null) { temp.ToString(); temp=temp.next; } } } " }, { "title": "排序算法", "url": "/posts/datastucture5/", "categories": "数据结构与算法", "tags": "sort, java", "date": "2020-06-11 11:16:00 +0800", "content": "排序 1.内部排序 将需要处理的所有数据都加载到内部存储器中进行排序 2.外部排序法 数据量过大，无法全部加载到内存 内部排序 插入排序 直接插入排序 希尔排序 选择排序 简单排序 堆排序 交换排序 冒泡排序 快速排序 归并排序 技术排序 冒泡排序 int[] arr= new int[]{2,5,8,0}; int temp =0; int count = arr.length-1; for (int j=1;j&lt;=count;j++) { for (int i = 0; i &lt; arr.length - j; i++) { if (arr[i] &gt; arr[i + 1]) { temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } } } for (var val:arr ) { System.out.println(val); } 进行优化，如果排序已经在完成，则不在继续 int[] arr= new int[]{2,5,8,0}; int temp =0; int count = arr.length-1; boolean flag=false; for (int j=1;j&lt;=count;j++) { //优化 某一次已经完成排序了，则不在进行排序 flag=false; for (int i = 0; i &lt; arr.length - j; i++) { if (arr[i] &gt; arr[i + 1]) { flag=true; temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; } } if(!flag){ break; } } for (var val:arr ) { System.out.println(val); } 选择排序 第一次从 arr[0]-arr[n-1]选取最小值与 arr[0]交换，第二次从 arr[1]-arr[n-1]选取最小值和 arr[1]交换，通过 n-1 次，获取到有序的队列 for(int i=0;i&lt;arr.length;i++) { for(int j=i;j&lt;arr.length;j++) { if(arr[i]&gt;arr[j]) { int temp =arr[i]; arr[i] = arr[j]; arr[j]=temp; } } } 插入排序 把 n 个带排序元素看成一个有序表和无需表，开始有序表只有一个元素，无序表包含 n-1 个元素，排序过程中每次去无序表中取一个元素，向有序表中寻找合适位置插入 //插入排序实现 public static void Sort(int[] arr) { int val =0; //记录插入的位置 boolean flag =false; int index =0; //外层遍历有序列表 for(int i=1;i&lt;arr.length;i++) { val =arr[i]; //初始插入位置 index=i-1; //内层遍历有序列表，寻找插入位置 while (index&gt;=0&amp;&amp;val&gt;arr[index]) { arr[index+1]=arr[index]; index--; } arr[index+1]=val; } } 希尔排序 缩小增量排序 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序，随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止，希尔排序对直接插入进行了优化。 //移位法 public static void InsertSort2(int[] arr) { for(int gap=arr.length/2;gap&gt;0;gap/=2) { for(int i=gap;i&lt;arr.length;i++) { int index = i; int val = arr[i]; // if(arr[i]&lt;arr[index-gap]) { while (index - gap &gt;= 0 &amp;&amp; val &lt; arr[index-gap]) { arr[index] = arr[index - gap]; index -= gap; } //} arr[index]=val; // for(int j=i-gap;j&gt;=0;j-=gap) // { // if(arr[j]&gt;arr[j+gap]) // { // temp=arr[j]; // arr[j]=arr[gap+j]; // arr[gap+j]=temp; // } // } } } } 快速排序 快速排序是对冒泡排序的改进，采用分治的思想 //快速排序 public void QuickSort(int[] arr) { QuickSort(arr,0,arr.length-1); } //快速排序 public void QuickSort(int[] arr,int left,int right) { int pivot = partion(arr,left,right); if(left&lt;right) { QuickSort(arr, left, pivot - 1); QuickSort(arr, pivot + 1, right); } } public int partion(int arr[],int left,int right) { int key =arr[left]; while(left&lt;right) { while (left &lt; right &amp;&amp; arr[right] &gt;= key) { right--; } arr[left] = arr[right]; while (left &lt; right &amp;&amp; arr[left] &lt;= key) { left++; } arr[right]=arr[left]; } arr[left]=key; return left; } 排序速度 堆排序 堆：是具有以下性质的完全二叉树，每个节点的值都大于或等于其左右孩子节点的值，称为大顶堆，反之则是小顶堆。 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为 O(nlogn),它也是不稳定排序，一般升序采用大顶堆，降序采用小顶堆 堆排序思想：将待排序的序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根节点，将它与堆数组的末尾元素进行交换，此时末尾元素就是最大值，然后将剩余的 n-1 个序列重新构造成一个堆，这样就会得到 n 个元素中的次大值，如此反复就能得到一个有序序列。 //编写一个堆排序的方法 public static void heapSort(int arr[]) { int temp = 0; System.out.println(\"堆排序!!\"); //\t\t//分步完成 //\t\tadjustHeap(arr, 1, arr.length); //\t\tSystem.out.println(\"第一次\" + Arrays.toString(arr)); // 4, 9, 8, 5, 6 // //\t\tadjustHeap(arr, 0, arr.length); //\t\tSystem.out.println(\"第2次\" + Arrays.toString(arr)); // 9,6,8,5,4 //完成我们最终代码 //将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆 for(int i = arr.length / 2 -1; i &gt;=0; i--) { adjustHeap(arr, i, arr.length); } \t\t/* \t\t * 2).将堆顶元素与末尾元素交换，将最大元素\"沉\"到数组末端; 　　\t\t\t3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 \t\t */ for(int j = arr.length-1;j &gt;0; j--) { //交换 temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); } //System.out.println(\"数组=\" + Arrays.toString(arr)); } //将一个数组(二叉树), 调整成一个大顶堆 /** * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆 * 举例 int arr[] = {4, 6, 8, 5, 9}; =&gt; i = 1 =&gt; adjustHeap =&gt; 得到 {4, 9, 8, 5, 6} * 如果我们再次调用 adjustHeap 传入的是 i = 0 =&gt; 得到 {4, 9, 8, 5, 6} =&gt; {9,6,8,5, 4} * @param arr 待调整的数组 * @param i 表示非叶子结点在数组中索引 * @param lenght 表示对多少个元素继续调整， length 是在逐渐的减少 */ public static void adjustHeap(int arr[], int i, int lenght) { int temp = arr[i];//先取出当前元素的值，保存在临时变量 //开始调整 //说明 //1. k = i * 2 + 1 k 是 i结点的左子结点 for(int k = i * 2 + 1; k &lt; lenght; k = k * 2 + 1) { if(k+1 &lt; lenght &amp;&amp; arr[k] &lt; arr[k+1]) { //说明左子结点的值小于右子结点的值 k++; // k 指向右子结点 } if(arr[k] &gt; temp) { //如果子结点大于父结点 arr[i] = arr[k]; //把较大的值赋给当前结点 i = k; //!!! i 指向 k,继续循环比较 } else { break;//! } } //当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部) arr[i] = temp;//将temp值放到调整后的位置 } } " }, { "title": "递归", "url": "/posts/datastructure4/", "categories": "数据结构与算法", "tags": "recursion, java", "date": "2020-06-05 10:36:00 +0800", "content": "递归 -自己调用自己的函数 使用场景 8 皇后，汉诺塔，阶乘，迷宫 快排，归并，二分，分治 使用栈解决的问题-&gt;递归代码比较简洁 使用递归需要遵守的问题 执行一个方法时，就创建一个新的受保护的独立空间（栈空间） 方法的局部变量是独立的，不会相互影响 每个递归定义至少必须有一个条件，满足时递归不再进行，而是返回值退出 遵守谁调用，就将结果返回谁，方法执行完毕或者返回时，该方法也就执行完毕 如果方法中，用到引用类型的变量，则会共享 迷宫回溯 1.成功条件 是终点可以走的通 即状态 2 2.中间有个分支如果出现走不通，即开始回溯，分支即判断 false，所有分支都判断为 false 则该点 即为 3 3.递归至终点，并且可以走通，回溯完成当前路径，则是行的通的路径 package com.learn.recursion; //迷宫回溯 public class Maze { public static void main(String[] args) { //数组标记 0 可走节点 ，1 障碍物， 2 走的通的节点 ，3 走不通的节点 var map = CreateMaze(6,7); int sizeX=map.length; int sizeY=map[0].length; //设置障碍 map[2][1]=1; map[2][2]=1; //开始走出迷宫 GoMaze(map,1,1); for(int i=0;i&lt;sizeX;i++) { for (int j = 0; j &lt; sizeY; j++) { System.out.print(map[i][j]+\" \"); } System.out.println(); } } //创建迷宫 public static int[][] CreateMaze(int sizeX,int sizeY) { int[][] map= new int[sizeX][sizeY]; for(int i=0;i&lt;sizeX;i++) for(int j=0;j&lt;sizeY;j++) { if(i==0||i==sizeX-1||j==0||j==sizeY-1) { map[i][j]=1; }else{ map[i][j]=0; } } return map; } //走出迷宫 //策略 下-&gt;右-&gt;上-&gt;左 /* *x,y开始节点 map迷宫 */ public static boolean GoMaze(int[][] map,int sx,int sy) { for(int i=0;i&lt;6;i++) { for (int j = 0; j &lt; 7; j++) { System.out.print(map[i][j]+\" \"); } System.out.println(); } System.out.println(\"-----------------------------------------\"); //终止循环 if(map[4][5]==2) { return true; }else { if(map[sx][sy]==0) { map[sx][sy]=2; if(GoMaze(map,sx+1,sy)) { return true; }else if(GoMaze(map,sx,sy+1)) { return true; }else if(GoMaze(map,sx-1,sy)) { return true; }else if(GoMaze(map,sx,sy-1)) { return true; } map[sx][sy]=3; return false; }else { return false; } } } } 8 皇后问题算法（回溯算法） 思路 第一个皇后放在第一行第一列 第二个皇后放在第二行第一列，判断是否 ok，如果不 ok 则继续往第二列第三列放 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后放在第一个列时的正确解将全部得到 后续依次将第一个皇后放在第二列，第三列。。。 这里用一维数组表示棋盘 e.g arr[] ={1,1},下表表示 index+1 行，对应的值表示 value+1 列 实现 package com.learn.recursion; //8皇后问题 public class Queen { public static void main(String[] args) { Queen8 queen8=new Queen8(); queen8.StarPut(); } } class Queen8{ //皇后数量 int queen_num=8; int[] arr=new int[queen_num]; public void StarPut() { PutQueen(0); } //放入棋子 public void PutQueen(int n) { //n==8 即第九行的棋子，前面8个符合8皇后规则 if(n==queen_num) { //递归完成，打印当前的棋子 Log(); return; } for(int i=0;i&lt;queen_num;i++) { //把棋子放在第n+1行的第i+1列 arr[n]=i; //如果符合 8皇后规则 if(Check(n)) { //则继续放下一行 PutQueen(n+1); } } } //判断当前放入的列是否符合规则 public boolean Check(int n) { for(int i=0;i&lt;n;i++) { //arr[i]==arr[n] 列值相等 //Math.abs(arr[i]-arr[n]在对角线上 if(arr[i]==arr[n]||Math.abs(n-i)==Math.abs(arr[i]-arr[n])) { return false; } } return true; } //输出值 public void Log() { for(int i=0;i&lt;queen_num;i++) { System.out.print(arr[i]+\" \"); } //h换行 System.out.println(); } } " }, { "title": "栈", "url": "/posts/datastructure3/", "categories": "数据结构与算法", "tags": "stack, java", "date": "2020-06-05 10:36:00 +0800", "content": "栈 先入后出的有序列表 （FILO-First In Last Out） 栈是限制线性表中元素的插入和删除 只能在线性表一段进行的特殊线性表，允许插入和删除的一端称为栈顶，另一端为栈底 最先放入栈中元素在栈底，最后放入的元素在栈顶，删除则是最后放入的先删除，最先放入的最后删除。 栈涉及到的应用场景 子程序调用：在跳往子程序前，会先将下个指令的地址存放到堆栈中，子程序执行完毕后，从堆栈取出指令地址，回到之前程序 处理递归调用：和子程序的调用类似，只是出了存储下一个指令的地址外，也将参数，区域变量等数据存入堆栈 表达式的转换 [中缀表达式转后缀表达式]与求值 二叉树遍历 图形深度优先搜索算法（depth-first） 栈实现的计算器 package com.learn.stack; ///计算表达式 public class Caculator { public static void main(String[] args) { String exp = \"3+2*6-5\"; int index =0; Stack numStack = new Stack(10); Stack expStack =new Stack(10); for(int i=0;i&lt;exp.length();i++) { char c = exp.substring(i,i+1).charAt(0); //数栈 符号栈 if(IsOper(c)) { if(expStack.IsEmpty()) { expStack.Push(c); }else if(OperPriority(expStack.Peek()) &lt;=OperPriority(c)) { expStack.Push(c); }else { int value =Oper(numStack,expStack); numStack.Push(value); expStack.Push(c); } }else{ //char 转 int (ascii) numStack.Push(c-48); } } //遍历完成后进行运算 while(true) { if(expStack.IsEmpty()) break; int value = Oper(numStack,expStack); System.out.println(\"value=\"+value); numStack.Push( value); } System.out.printf(\"The result of expression %s is %d\",exp,numStack.Peek()); } //是否为运算符 public static boolean IsOper(int oper) { if(oper=='*'||oper=='/'||oper=='+'||oper=='-') { return true; } return false; } //运算符优先级 public static int OperPriority(int oper) { if(oper=='*'||oper=='/') { return 2; }else if (oper=='+'||oper=='-') { return 1; } return 0; } //运算规则 public static int Oper(Stack numStack,Stack expStack) { int num1 = numStack.Pop(); int num2 = numStack.Pop(); int exp =expStack.Pop(); int value=0; //num2 先入栈 运算时从左至右，num2在前 switch (exp) { case '*': value=num2*num1; break; case '/': value=num2/num1; break; case '+': value=num2+num1; break; case '-': value=num2-num1; break; } return value; } } //数组实现栈 class Stack { //最大栈 private int maxSize; //指示当前栈顶位置 int top = -1; int[] stack; public Stack(int maxSize) { this.maxSize = maxSize; stack = new int[maxSize]; } //栈是否已满 public boolean IsFull() { return maxSize == top + 1; } //栈是否是空的 public boolean IsEmpty() { return top == -1; } //出栈 public int Pop() { if (IsEmpty()) { throw new RuntimeException(\"The stack is Empty\"); } int val = stack[top]; top--; return val; } //压栈 public void Push(int value) { if (IsFull()) { System.out.println(\"the stack is full push fail\"); return; } top++; stack[top] = value; } //查询栈顶信息 public int Peek() { if(IsEmpty()) { throw new RuntimeException(\"empty stack\"); } return stack[top]; } //遍历栈 public void Show() { if (IsEmpty()) { return; } for (int i = top; i &gt;= 0; i--) { System.out.printf(\"stack[%d]=%d\\n\", i, stack[i]); } } } " }, { "title": "链表", "url": "/posts/datastructure2/", "categories": "数据结构与算法", "tags": "linkedlist, java", "date": "2020-06-03 10:36:00 +0800", "content": "链表 链表是以节点方式存储 每个节点包含 data，next 域指向下一个节点 链表的各个节点不一定是连续存储 链表根据需求，可以带头结点也可以不带 尾部插入 package com.learn.linkedlist; public class SingleLinkedListDemo { public static void main(String[] args){ SingleLinkedList linkedList = new SingleLinkedList(); for (int i=1;i&lt;=10;i++) { HeroNode node = new HeroNode(i,\"nick\"+i); linkedList.Add(node); } linkedList.List(); } } class HeroNode{ int no; String nickName; HeroNode next; public HeroNode(int no,String nickName) { this.no=no; this.nickName=nickName; } public void ToString() { System.out.print(\"no=\"+no+\" nickName=\"+nickName+\" \"); } } class SingleLinkedList{ //头结点 固定，不可更改 HeroNode head=new HeroNode(0,null); //添加节点 public void Add(HeroNode node) { HeroNode tmp = head; while (true) { if(tmp.next==null) { tmp.next=node; break; } tmp=tmp.next; } } //显示所有的节点 public void List() { HeroNode tmp=head; while(true) { if(tmp==null) { break; } tmp.ToString(); tmp=tmp.next; } } } 删除节点 只需要将目标节点的上一节点的 next 指向目标节点的 next，即可删除目标节点 //删除目标节点 public void Delete(int no) { HeroNode tmp = head.next; while(true) { if(tmp==null || tmp.next==null) { break; }else if(tmp.next.no==no) { tmp.next=tmp.next.next; break; } //后移 tmp=tmp.next; } } 获取有效节点个数 public int GetLength() { HeroNode cur =head.next; int length=0; while(cur!=null) { length++; cur=cur.next; } return length; } 获取倒数第 K 个节点 相当于获取有效节点个数后，减去 k 后即正序的节点 public HeroNode getReverseNode(int index) { int size =GetLength(); if(index&gt;size || index&lt;0) { return null; } int reverse_index=size-index; HeroNode tar =head.next; while(true) { if(tar==null) { break; } reverse_index--; if(reverse_index==0) { break; } tar=tar.next; } return tar; } 单链表反转 简单面试题 思路： 新增头节点 遍历旧链表所有节点 每次遍历出的节点，都往新链表的头部插入 将原来链表头结点，指向新链表的头结点 public void Reverse() { HeroNode reverseHead= new HeroNode(0,null); HeroNode tmp = head.next; while (tmp!=null) { HeroNode next_tmp= tmp.next; tmp.next = reverseHead.next; reverseHead.next=tmp; tmp=next_tmp; } head.next=reverseHead.next; } 双向链表 双向链表是单链表扩展出来的结构，很多操作相同。 例如获取长度，查找元素。由于多了一个指向前驱元素的指针，在添加和删除时，向对于单链表会增加对前驱指针的操作。 与单向链表对比 单项链表，查找方向只能是一个方向，双向链表可以向前或者向后查找 单项链表不能自我删除，需要辅助接点，而双向链表，则可以自我删除（单向链表 删除时总是需要一个辅助节点，这个节点是待删除节点的前一个节点） 多存储了一个指针，内存消耗增加。 环形链表 创建 借助辅助指针 first ，记录第一个节点，只有一个节点时，自己指向自己，形成闭环 cur 记录最后一次添加的节点，cur 指向新增节点，新增节点 next 指向 first //添加节点 public void Add(CNode cNode) { if(first==null) { first = cNode; first.next=first; } //将最后一个添加的节点后继指向新节点 if(cur != null) { cur.next=cNode; } //形成闭环 cNode.next=first; //记录节点 cur=cNode; } 遍历环形链表 public void List() { //空表 if(first==null) { return; } CNode tmp = first; while (true) { tmp.ToString(); if(tmp.next==first) { break; } tmp=tmp.next; } } 约瑟夫问题 helper 类似于单链表删除节点时辅助节点，first 指向需要删除节点，helper 用于删除和判断循环结束条件 /** * 约瑟夫问题 * @param k 起始位置 * @param m 间隔 */ public void JosePhu(int k,int m) { //helper始终first的前一个元素 CNode helper=first; while (true) { //定位helper //只有一个元素时first == helper if(helper.next==first) { break; } helper=helper.next; } //定位helper和first初始位置，从第k个开始,需要移动k-1次 for(int i=1;i&lt;=k-1;i++) { helper=helper.next; first=first.next; } //开始做出队处理，直到只剩下一个元素 while(true) { if(helper==first) { helper.ToString(); break; } for(int j=1;j&lt;=m-1;j++) { helper=helper.next; first=first.next; } first.ToString(); first = first.next; helper.next=first; } } " }, { "title": "稀疏数组与队列", "url": "/posts/datastructure1/", "categories": "数据结构与算法", "tags": "sparsearray, queue", "date": "2020-06-01 17:36:00 +0800", "content": "参考资料：https://space.bilibili.com/302417610?spm_id_from=333.788.b_765f7570696e666f.2 线性结构与非线性结构 线性结构 线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系 线性结构有两种不同的存储结构 顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息 线性结构常见的有 一维数组 队列 链表 栈 非线性结构 多维数组（包括二维），广义表，树 ，图 稀疏数组 当一个数组中大部分元素是 0，或者相同的值，可以使用稀疏数组来保存 处理方法：记录数组一共有几行几列，有多少个不同的值 把具有不同值得元素的行列及值记录在一个小规模数组中（稀疏数组），从而缩小程序的规模. 队列 队列 队列是个有序列表，可以用数组或者链表显示 遵循先入先出 （栈是先入后出），即存是加在队列尾部，取从数据头部 数组实现队列 front 随着数据输出改变，rear 随着数据输入改变 数组实现队列 当前实现的队列是不能复用的，数组再使用一次后，不能重复添加 using UnityEngine; namespace DataStructure { public class ArrayQueue { int max_size; int rear=-1; //指向数据输入前一位 int front = -1;//指向数据输入后一位 GameObject[] arr;//实现用的数组 //Consturctor public ArrayQueue(int size) { max_size = size; arr= new GameObject[size]; } public bool IsEmpty() { if(front==rear) { return true; } return false; } public bool IsFull() { return max_size&lt;=front+1; } public bool Add(GameObject go) { if(IsFull()) { Debug.LogError(\"Queue is Full\"); return false; } rear++; //超过上限 if(rear&gt;=arr.Length) { return false; } arr[rear]=go; return true; } public GameObject Get() { if(IsEmpty()) { Debug.LogError(\"Queue is Empty\"); return null; } front++; return arr[front]; } public GameObject GetTop() { if(IsEmpty()) { Debug.LogError(\"Queue is Empty\"); return null; } return arr[front+1]; } } } 数组模拟环形队列 当队列为空时 front==rear，当队列满时，保留一个元素空间，也就是队列满时，数组中还有一个空闲单元 1.判断队列空 front==rear 2.判断队列满 (rear+1)%maxsize=front 3.队列有效长度（rear-front+maxsize）%maxsize " }, { "title": "shader 2d 影子", "url": "/posts/shader26/", "categories": "unity", "tags": "shader, 例子", "date": "2020-05-29 10:36:00 +0800", "content": "shader 简单应用 2d 影子 uv 翻转 v 后,采样目标纹理,舍弃透明部分，非透明部分按设定颜色输出。 Shader \"Custom/ImageEffect/Shadow2d\" { Properties { _MainTex (\"Texture\", 2D) = \"white\" {} _ShadowColor(\"ShadowColor\",Color)=(1,1,1,1) } SubShader { Cull Off ZWrite Off ZTest Always Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; }; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv =float2(v.uv.x,1-v.uv.y); return o; } sampler2D _MainTex; fixed4 _ShadowColor; fixed4 frag (v2f i) : SV_Target { fixed4 col = tex2D(_MainTex, i.uv); clip(col.a-0.1); return _ShadowColor; } ENDCG } } } " }, { "title": "设计模式 - 命令模式", "url": "/posts/designpattern1/", "categories": "设计模式", "tags": "命令模式", "date": "2020-05-28 09:36:00 +0800", "content": "命令模式 UML 图 作用 较容易的实现命令队列 需要的时候可以方便记入日志 接收请求的地方决定是否要接收日志 实现请求的撤销和重做 方便增加新的具体命令类 缺点 大量实例化命令 实现 /// &lt;summary&gt; /// 声明执行操作的接口 /// &lt;/summary&gt; abstract public class Command { //命令接收者 protected CubeReciever reciever; abstract public bool Excute(); abstract public bool Undo(); } //子类 ConcreteCommand using UnityEngine; public class MoveCommand:Command { Vector2 dir; public MoveCommand( CubeReciever reciever,Vector2 dir) { base.reciever=reciever; this.dir=dir; } public override bool Excute(){ if(reciever==null || dir ==null) { return false; } reciever.CubeAction(dir); return true; } public override bool Undo(){ if(reciever==null || dir==null) { return false; } reciever.CubeAction(-dir); return true; } } using UnityEngine; public class CubeReciever { public GameObject go; public CubeReciever(GameObject go) { this.go= go; } public void CubeAction(Vector2 dir){ go.transform.localPosition+=new Vector3(dir.x,dir.y,0); } } using System.Collections; using System.Collections.Generic; using UnityEngine; public class PlayInvoker : MonoBehaviour { int command_pos = -1; //命令队列 public List&lt;MoveCommand&gt; commands = new List&lt;MoveCommand&gt; (); public GameObject btn_up; public GameObject btn_down; public GameObject btn_undo; public GameObject btn_redo; private CubeReciever reciever; public GameObject reciever_go; void Awake () { reciever = new CubeReciever (reciever_go); } public void Click (GameObject go) { if (go.Equals (btn_up)) { Vector2 up = new Vector2 (0, 1); Move (up); } else if (go.Equals (btn_down)) { Vector2 down = new Vector2 (0, -1); Move (down); } else if (go.Equals (btn_undo)) { Undo (); } else if (go.Equals (btn_redo)) { Redo (); } } public void Move (Vector2 dir) { MoveCommand command = new MoveCommand (reciever, dir); bool suc = command.Excute (); if (suc) { commands.Add (command); command_pos = commands.Count; } } //实现请求的撤销和重做 public void Undo () { int tar_pos = command_pos - 1; if (tar_pos &gt;= 0 &amp;&amp; tar_pos &lt; commands.Count) { MoveCommand command = commands[tar_pos]; if (command.Undo ()) { command_pos --; } } } //实现请求的撤销和重做 public void Redo () { if(command_pos&lt;commands.Count){ MoveCommand command = commands[command_pos]; if(command.Excute ()) { command_pos++; } } } } " }, { "title": "非真实感渲染（Non-Photorealistic Rendering）", "url": "/posts/shader25/", "categories": "unity", "tags": "shader", "date": "2020-05-18 10:36:00 +0800", "content": "卡通风格渲染 渲染轮廓线 方法 基于观察角度和表面法线的轮廓线渲染 ，视角方向和表面法线点乘结果来得到轮廓线。这种方法简单迅速可以在一个 pass 中就得到渲染结果，但时局限性很大，很多模型得不到满意的描边效果 过程式几何轮廓线渲染，使用两个 pass，一个渲染正面，一个渲染背面，并让轮廓可见。优点快速有效，适用于大部分表面平滑模型，不适合类似于正方体这样平整模型 基于图像处理的轮廓线渲染 ，例如使用 sobel 算子的边缘检测，缺点是无法检测深度和法线变化很小的轮廓线，例如桌上的一张纸 基于轮廓边检测的轮廓线渲染，上面的方法无法控制轮廓线的渲染风格。用于精确检测轮廓边并控制渲染风格 \\(( \\vec{n_0} \\cdot \\vec v&gt;0) \\neq (\\vec{n_1} \\cdot \\vecv&gt;0)\\) n0 n1 分别表示这条边相邻两个三角面皮的法线，v 是视角到该变任意顶点的方向 顶点扩张 在视角空间下把顶点沿法线向往外扩张一段距离，以此来让背部轮廓线可见。但是如果直接对顶点进行扩张，对于一些内凹模型，就会发生背面面片遮挡正面面片的情况 为了尽量避免这种情况，在扩张背面顶点之前，先对顶点法线的 z 分量进行一定处理，使他们等于一个定值，然后把法线归一化后进行扩张。 viewNormal.z=-0.5; viewNormal = normalize(viewNormal); viewPos = viewPos +viewNormal*_Outline; 添加高光 卡通风格渲染中的高光往往是一块分界明显的纯色区域，对于卡通渲染需要的高光反射光照模型，我们会 normalDir 和 halfdir 的点乘结果和一个阈值比较，若小于则高光反射系数 返回 0，否则返回 1。 \\[\\mathtt{c}_{specular}=(\\mathtt{c}_{light}\\cdot\\mathtt{m}_{specular})max(0,\\vec n\\cdot\\vec h)^{m_{gloss}}\\] 实现 \tProperties { \t\t_Color (\"Color Tint\", Color) = (1, 1, 1, 1) \t\t_MainTex (\"Main Tex\", 2D) = \"white\" {} \t\t_Ramp (\"Ramp Texture\", 2D) = \"white\" {} \t\t_Outline (\"Outline\", Range(0, 1)) = 0.1 \t\t_OutlineColor (\"Outline Color\", Color) = (0, 0, 0, 1) \t\t_Specular (\"Specular\", Color) = (1, 1, 1, 1) \t\t_SpecularScale (\"Specular Scale\", Range(0, 0.1)) = 0.01 \t} SubShader { \t\tTags { \"RenderType\"=\"Opaque\" \"Queue\"=\"Geometry\"} \t\tPass { \t\t\tNAME \"OUTLINE\" \t\t\t//剔除前面，只渲染背面 \t\t\tCull Front \t\t\tCGPROGRAM \t\t\t#pragma vertex vert \t\t\t#pragma fragment frag \t\t\t#include \"UnityCG.cginc\" \t\t\tfloat _Outline; \t\t\tfixed4 _OutlineColor; \t\t\tstruct a2v { \t\t\t\tfloat4 vertex : POSITION; \t\t\t\tfloat3 normal : NORMAL; \t\t\t}; \t\t\tstruct v2f { \t\t\t float4 pos : SV_POSITION; \t\t\t}; \t\t\tv2f vert (a2v v) { \t\t\t\tv2f o; \t\t\t\t//视角空间下顶点 \t\t\t\tfloat4 pos = mul(UNITY_MATRIX_MV, v.vertex); \t\t\t\t//法线 \t\t\t\tfloat3 normal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal); \t\t\t\t//扩展前指定 z 的值 \t\t\t\tnormal.z = -0.5; \t\t\t\t//延法线方向扩展 顶点 \t\t\t\tpos = pos + float4(normalize(normal), 0) * _Outline; \t\t\t\t//顶点变换到裁剪空间 \t\t\t\to.pos = mul(UNITY_MATRIX_P, pos); \t\t\t\treturn o; \t\t\t} \t\t\tfloat4 frag(v2f i) : SV_Target { \t\t\t\t//背面颜色指定为轮廓颜色 \t\t\t\treturn float4(_OutlineColor.rgb, 1); \t\t\t} \t\t\tENDCG \t\t} \t\tPass { \t\t\tTags { \"LightMode\"=\"ForwardBase\" } \t\t\t//背面已经在上一pass着色 \t\t\tCull Back \t\t\tCGPROGRAM \t\t\t#pragma vertex vert \t\t\t#pragma fragment frag \t\t\t#pragma multi_compile_fwdbase \t\t\t#include \"UnityCG.cginc\" \t\t\t#include \"Lighting.cginc\" \t\t\t#include \"AutoLight.cginc\" \t\t\t#include \"UnityShaderVariables.cginc\" \t\t\tfixed4 _Color; \t\t\tsampler2D _MainTex; \t\t\tfloat4 _MainTex_ST; \t\t\t//渐变纹理 \t\t\tsampler2D _Ramp; \t\t\tfixed4 _Specular; \t\t\tfixed _SpecularScale; \t\t\tstruct a2v { \t\t\t\tfloat4 vertex : POSITION; \t\t\t\tfloat3 normal : NORMAL; \t\t\t\tfloat4 texcoord : TEXCOORD0; \t\t\t\tfloat4 tangent : TANGENT; \t\t\t}; \t\t\tstruct v2f { \t\t\t\tfloat4 pos : POSITION; \t\t\t\tfloat2 uv : TEXCOORD0; \t\t\t\tfloat3 worldNormal : TEXCOORD1; \t\t\t\tfloat3 worldPos : TEXCOORD2; \t\t\t\tSHADOW_COORDS(3) \t\t\t}; \t\t\tv2f vert (a2v v) { \t\t\t\tv2f o; \t\t\t\to.pos = UnityObjectToClipPos( v.vertex); \t\t\t\to.uv = TRANSFORM_TEX (v.texcoord, _MainTex); \t\t\t\to.worldNormal = UnityObjectToWorldNormal(v.normal); \t\t\t\to.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; \t\t\t\tTRANSFER_SHADOW(o); \t\t\t\treturn o; \t\t\t} \t\t\tfloat4 frag(v2f i) : SV_Target { \t\t\t\tfixed3 worldNormal = normalize(i.worldNormal); \t\t\t\tfixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); \t\t\t\tfixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPos)); \t\t\t\tfixed3 worldHalfDir = normalize(worldLightDir + worldViewDir); \t\t\t\tfixed4 c = tex2D (_MainTex, i.uv); \t\t\t\tfixed3 albedo = c.rgb * _Color.rgb; \t\t\t\tfixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo; \t\t\t\tUNITY_LIGHT_ATTENUATION(atten, i, i.worldPos); \t\t\t\tfixed diff = dot(worldNormal, worldLightDir); \t\t\t\tdiff = (diff * 0.5 + 0.5) * atten; \t\t\t\tfixed3 diffuse = _LightColor0.rgb * albedo * tex2D(_Ramp, float2(diff, diff)).rgb; \t\t\t\tfixed spec = dot(worldNormal, worldHalfDir); \t\t\t\t//邻像素之间近似导数值 \t\t\t\tfixed w = fwidth(spec) * 2.0; \t\t\t\tfixed3 specular = _Specular.rgb * lerp(0, 1, smoothstep(-w, w, spec + _SpecularScale - 1)) * step(0.0001, _SpecularScale); \t\t\t\treturn fixed4(ambient + diffuse + specular, 1.0); \t\t\t} \t\t\tENDCG \t\t} \t} \tFallBack \"Diffuse\" " }, { "title": "Unity Dots", "url": "/posts/shader24/", "categories": "unity", "tags": "dots, ecs", "date": "2020-05-18 10:36:00 +0800", "content": "什么是 DOTS 充分利用多核处理器，多线程处理让游戏运行速度更快，更高效，DOTS（面向数据的技术堆栈）是以下 3 个系统的集合 Job Systems 任务系统 用于高效运行多线程代码 Entity Component System（ECS）实体组件系统 用于默认编写高新能代码 Burst Compiler burst 编译器 用于生成高度优化的本地代码，Unity 使用 Burst 编译器可以使 C#代码运行效率高于 c++ Job Systems 和 ECS 可以独立使用，组合在一起才能发挥最大优势。 C# job systems 在 job systems 之前，Unity 内部是多线程处理，但是外部代码必须在主线程上。 c# 虽然支持 thread 但是 Unity 中只能处理数据，例如网络消息，下载，但是不能在 Tread 中调用 Unity API 有了 Job System 可以充分利用多线程，例如在多线程中处理 Transform 旋转，缩放，平移。 Unity 没有直接将 Tread 开放出来，这样可以避免 Tread 滥用，开发者可以放心使用 Job Systems 而不用太关心线程安全，锁 Job System 最好配合 burst 编译器，这样可以生成本地高效代码。 Job System 中的数据类型，只能是值类型（float,int,bool）,enum,struct 和其他类型的指针 Job System 不能使用引用类型，例如 T[] Job 中可以使用 NativeArray代替 T[] HPC# High Performance C# C# class 类型数据的数据内存分配在堆上，程序员无法主动释放，必须等到.NET 进行垃圾回收才会释放。 IL2CPP 虽然将 IL 转成 c++代码，实际上还是模拟了.Net 垃圾回收机制，效率并没有等同与 c++ HPC# 就是 NativeArrary ，NativeHashmap 可替代数组[] 数据类型 包括值类型（float，uint，bool...） NativeArray 可以在 c#层分配 c++中对象，可以主动释放，不需要进行 c#的垃圾回收 Job System 使用的就是 NateiveArray IJOBPARALLELFOR 并行 IJOB 是一个一个开线程任务，因为数据是顺序执行的，所以它可以保证数据的正确性 使用 IJOBPARALLELFOR 线程是并行执行的，因此数据执行不是顺序执行的，每一个 JOB 数据不能完全依赖上一个 JOB 执行后的结果 “ReadOnly” 意味着数据是只读的，不需要加锁 如果不声明默认数据是 Read/Write，数据一旦改写，Job 一定要等它 Unity 已经为我们做好着些，不需要我们再写加解锁逻辑 Unity.MathEMatics 提供矢量类型，可以直接映射到 SIMD 寄存器 有了 SIMD,CPU 可以一次计算 unity 之前的 math 类 默认不支持 simd 启动 BurstComile Struct 上加上 BurstCmoplie 标签 Struct 必须继承 IJob,IJobParallelfor，否则无效 ECS 旧版本的一些总结 设计模式-组件模式 脚本数据在内存中是不连续的 脚本中没必要的数据也提供了，每个 GameObject 都包含了 Transform，这些额外的数据也会占用内存 脚本和脚本是偶尔关系，会出现相互调用 脚本属于引用类型，也就是全局声明的所有变量都会占用堆内存，会产生 GC 脚本是非常重量的产物，手机上挂脚本会额外占用 0.01s 脚本不支持热更新 Entity Entity 非常轻量，它就是一个变量 ID，用 int 保存 Entity 可以根据自己需求绑定组件，比如只有位置则只绑定 Position 相同组件会连续排列在内存中，Cache 命中增加，system 遍历速度增加 Component 组件是一个简单的数据存储，它时 struct 值类型，并且实现 IComponentData 接口，它不能写方法，没有任何行为，比如 position，rotation struct 中建议使用 float3 代替 vector3，quaternion 代替 Quaternion，原因就是 Unity.MathEMatics ArcheType 原型 Cache 命中增加就得益于 ArcheType ArcheType 是一个容器，并且 Unity 规定每一个大小都是 16kb，不够就再开一个，始终保持内存连续性 System System 只关心 Component 组件，它不关心这个 Component 属于哪个 Entity System 系统中定义它所关心的组件，组件都是连续保存在 ArcheType 中的，所以查找速度非常快 System 在 Update 中可以同意更新自己关心的组件 ISharedComponentData IComponentData 是结构类型，如果大量结构体中，保存的数据一样，那么在内存中也会产生多分 ISharedComponentData 是共享组件，典型的例子是场景中可能还有很多物体渲染的 mesh 和材质是相同的，如果 IComponentData 是浪费 ISharedComponentData 组件需要实现 IEquatable接口，用于判断两个组件是否相等 World World 包含 EntityManager，ComponentSystmes，ArcheTypes EntityManager 包含这个世界里所有的的 Entity，ComponentSystems 则包含世界里所有的组件，ArcheTyps 包含世界里所有的原型 ECS 默认提供了一个世界，我们也可以自己创建 世界与世界不互通，每一个世界都是唯一的，多个世界可以同时并存 World world =new World(“MyWorld”) ECS+JOB+BURST ECS 里的 Component 已经具有超高的 Cache 命中率，性能比传统脚本快很多 ComponentSystem 只能运行在主线程 每一个 ComponentSystem 只能等上一个运行完才能运行自己的 ECS 要配合 job 才能让性能起飞 JOBCOMPONENTSYSTEM JobComponentSystem 继承于 ComponentSystem JobComponentSystem 的 update 和 ComponentSystem 一样都是执行完毕一个在执行下一个 区别 JobComponentSystem 的 update 可以很快就返回，将复杂的计算丢给 JOB 去做 通过 Readonly 将 job 标记为是否只读，只读的话 job 是完全可以并行的 如果 job 中某一个数据发生更改，那么这块数据这不能和访问这块数据的其他 job 并行 Dots 实践 使用 ComponentDataProxy 可以把一个 struc 绑定在游戏对象上 场景导出 ECS PackageManager 添加 Hybrid 组件 Hybrid 的 Scene 组件可以把场景批量转换成 ECS 组件 prefab 导出 ECS 保存 Prefab，通过 GameObjectConaversionUtility.ConvertGameObjectHierarchy 直接将 prefab 转成 ECS 对象 prefab 只能是普通的 mesh，如果带骨骼动画不能转成 ECS ECS 渲染 ECS 自身是不包含渲染的，但是游戏的渲染和 entity 是密切绑定的 原理大致是通过 ECS 在 JOB 中先准备渲染的数据，然后通过 Gpu instancing 一次渲染，中间不产生 GameObject Gpu instancing 是不带裁剪，并且每帧在 update 里调用，这样会产生额外开销，即使物体不发生位置旋转变化也会强制刷新 建议使用 CommanderBuffer 来渲染 GPU instancing，这样只有物体属性发生改变时强制刷新 使用 BatchRenderGroup 代替 Graphics.DrawMeshInstanced 和 CommandBuffer.DrawMeshInstanced BatchRenderGroup 需要提供每个渲染物体的包围盒区域用户 job 中判断是否在视野范围内 BatchRenderGroup 内都会调自动 GPU Instancing 前提是开启 gpu instancing，并且没有 1023 个数量限制 " }, { "title": "shader入门基础-屏幕后处理效果", "url": "/posts/shader23/", "categories": "unity", "tags": "shader", "date": "2020-05-14 10:00:00 +0800", "content": "Unity 中实现屏幕后处理效果 在摄像机中添加一个用于屏幕后处理的脚本，在这个脚本中，我们会实现 OnRenderImage 函数来获取当前屏幕的渲染纹理。然后在调用 Graphics.Blit 函数使用 特定的 Unity Shader 来对当前图像进行处理，再把返回的渲染纹理显示到屏幕上。 边缘检测 卷积 这里本人并不清楚卷积的意义，参考了 CSDN @LianYueBiao 的博客 原文参考链接 图像卷积 using UnityEngine; using System.Collections; public class EdgeDetection : PostEffectsBase { \tpublic Shader edgeDetectShader; \tprivate Material edgeDetectMaterial = null; \tpublic Material material { \t\tget { \t\t\tedgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial); \t\t\treturn edgeDetectMaterial; \t\t} \t} \t[Range(0.0f, 1.0f)] \tpublic float edgesOnly = 0.0f; \tpublic Color edgeColor = Color.black; \tpublic Color backgroundColor = Color.white; \tvoid OnRenderImage (RenderTexture src, RenderTexture dest) { \t\tif (material != null) { \t\t\tmaterial.SetFloat(\"_EdgeOnly\", edgesOnly); \t\t\tmaterial.SetColor(\"_EdgeColor\", edgeColor); \t\t\tmaterial.SetColor(\"_BackgroundColor\", backgroundColor); \t\t\tGraphics.Blit(src, dest, material); \t\t} else { \t\t\tGraphics.Blit(src, dest); \t\t} \t} } Properties { \t\t_MainTex (\"Base (RGB)\", 2D) = \"white\" {} \t\t_EdgeOnly (\"Edge Only\", Float) = 1.0 \t\t_EdgeColor (\"Edge Color\", Color) = (0, 0, 0, 1) \t\t_BackgroundColor (\"Background Color\", Color) = (1, 1, 1, 1) \t} \tSubShader { \t\tPass { \t\t\tZTest Always Cull Off ZWrite Off \t\t\t//Blend One OneMinusSrcAlpha \t\t\tCGPROGRAM \t\t\t#include \"UnityCG.cginc\" \t\t\t#pragma vertex vert \t\t\t#pragma fragment fragSobel \t\t\tsampler2D _MainTex; \t\t\t//xxx_TexelSize是Unity为我们提供访问xxx纹理对应的每个纹素大小。 \t\t\t//例如一张512X512大小的纹理，则该值为1/512 \t\t\t//卷积需要对相邻区域内的纹理进行采样，因此我们需要利用_MainTex_TexelSize来计算各个相邻区域的纹理坐标。 \t\t\tuniform half4 _MainTex_TexelSize; \t\t\tfixed _EdgeOnly; \t\t\tfixed4 _EdgeColor; \t\t\tfixed4 _BackgroundColor; \t\t\tstruct v2f { \t\t\t\tfloat4 pos : SV_POSITION; \t\t\t\thalf2 uv[9] : TEXCOORD0; \t\t\t}; \t\t\tv2f vert(appdata_img v) { \t\t\t\tv2f o; \t\t\t\to.pos = UnityObjectToClipPos(v.vertex); \t\t\t\thalf2 uv = v.texcoord; \t\t\t\t//Sobel算子采样时对应的9个领域纹理坐标 \t\t\t\to.uv[0] = uv + _MainTex_TexelSize.xy * half2(-1, -1); \t\t\t\to.uv[1] = uv + _MainTex_TexelSize.xy * half2(0, -1); \t\t\t\to.uv[2] = uv + _MainTex_TexelSize.xy * half2(1, -1); \t\t\t\to.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1, 0); \t\t\t\to.uv[4] = uv + _MainTex_TexelSize.xy * half2(0, 0); \t\t\t\to.uv[5] = uv + _MainTex_TexelSize.xy * half2(1, 0); \t\t\t\to.uv[6] = uv + _MainTex_TexelSize.xy * half2(-1, 1); \t\t\t\to.uv[7] = uv + _MainTex_TexelSize.xy * half2(0, 1); \t\t\t\to.uv[8] = uv + _MainTex_TexelSize.xy * half2(1, 1); \t\t\t\treturn o; \t\t\t} \t\t\t//计算亮度值 \t\t\tfixed luminance(fixed4 color) { \t\t\t\treturn 0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b; \t\t\t} \t\t\t//sobel 算子 滤波？ \t\t\t//计算梯度值 \t\t\thalf Sobel(v2f i) { \t\t\t\t// const half Gx[9] = {-1, 0, 1, \t\t\t\t// \t\t\t\t\t\t-1, 0, 1, \t\t\t\t// \t\t\t\t\t\t-1, 0, 1}; \t\t\t\t// const half Gy[9] = {-1, -1, -1, \t\t\t\t// \t\t\t\t\t\t0, 0, 0, \t\t\t\t// \t\t\t\t\t\t1, 1, 1}; \t\t\t\tconst half Gx[9] = {-1, 0, 1, \t\t\t\t\t\t\t\t\t\t-2, 0, 2, \t\t\t\t\t\t\t\t\t\t-1, 0, 1}; \t\t\t\tconst half Gy[9] = {-1, -2, -1, \t\t\t\t\t\t\t\t\t\t0, 0, 0, \t\t\t\t\t\t\t\t\t\t1, 2, 1}; \t\t\t\thalf texColor; \t\t\t\thalf edgeX = 0; \t\t\t\thalf edgeY = 0; \t\t\t\tfor (int it = 0; it &lt; 9; it++) { \t\t\t\t\ttexColor = luminance(tex2D(_MainTex, i.uv[it])); \t\t\t\t\tedgeX += texColor * Gx[it]; \t\t\t\t\tedgeY += texColor * Gy[it]; \t\t\t\t} \t\t\t\thalf edge = 1 - abs(edgeX) - abs(edgeY); \t\t\t\treturn edge;//返回梯度值 \t\t\t} \t\t\tfixed4 fragSobel(v2f i) : SV_Target { \t\t\t\thalf edge = Sobel(i); \t\t\t\tfixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[4]), edge); \t\t\t\tfixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge); \t\t\t\treturn lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly); \t\t\t} \t\t\tENDCG \t\t} \t} \tFallBack Off 高斯模糊 高斯是一个正方形大小的滤波核，其中每个元素的计算都是基于下面的高斯方程。 \\(\\sigma\\) 是标准方差，一般取值 1，x,y 分贝对应了当前位置到卷积核的中心的距离。高斯核的维度越高，模糊的程度越大。使用一个 NXN 的高斯核对图像进行卷积滤波，需要 NXNXWXH 次采样，其中 W H 分别对应了图像的宽和高。当 N 增大时，采样次数会急剧增大。我们可以这个二维 高斯函数拆成两个一维高斯函数。我们可以使用两个一维的的高斯核先后对图像进行滤波。 高斯模糊需要调用两个 Pass,第一个 pass 使用竖直方向一维高斯核进行滤波就，第二个 pass 使用水平方向一维高斯核进行滤波。 using UnityEngine; using System.Collections; public class GaussianBlur : PostEffectsBase { \tpublic Shader gaussianBlurShader; \tprivate Material gaussianBlurMaterial = null; \tpublic Material material { \t\tget { \t\t\tgaussianBlurMaterial = CheckShaderAndCreateMaterial(gaussianBlurShader, gaussianBlurMaterial); \t\t\treturn gaussianBlurMaterial; \t\t} \t} \t// Blur iterations - larger number means more blur. \t[Range(0, 4)] \tpublic int iterations = 3; \t// Blur spread for each iteration - larger value means more blur \t[Range(0.2f, 3.0f)] \tpublic float blurSpread = 0.6f; \t[Range(1, 8)] \tpublic int downSample = 2; \t/// 1st edition: just apply blur //\tvoid OnRenderImage(RenderTexture src, RenderTexture dest) { //\t\tif (material != null) { //\t\t\tint rtW = src.width; //\t\t\tint rtH = src.height; //\t\t\tRenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0); // //\t\t\t// Render the vertical pass //\t\t\tGraphics.Blit(src, buffer, material, 0); //\t\t\t// Render the horizontal pass //\t\t\tGraphics.Blit(buffer, dest, material, 1); // //\t\t\tRenderTexture.ReleaseTemporary(buffer); //\t\t} else { //\t\t\tGraphics.Blit(src, dest); //\t\t} //\t} \t/// 2nd edition: scale the render texture //\tvoid OnRenderImage (RenderTexture src, RenderTexture dest) { //\t\tif (material != null) { //\t\t\tint rtW = src.width/downSample; //\t\t\tint rtH = src.height/downSample; //\t\t\tRenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0); //\t\t\tbuffer.filterMode = FilterMode.Bilinear; // //\t\t\t// Render the vertical pass //\t\t\tGraphics.Blit(src, buffer, material, 0); //\t\t\t// Render the horizontal pass //\t\t\tGraphics.Blit(buffer, dest, material, 1); // //\t\t\tRenderTexture.ReleaseTemporary(buffer); //\t\t} else { //\t\t\tGraphics.Blit(src, dest); //\t\t} //\t} \t/// 3rd edition: use iterations for larger blur \tvoid OnRenderImage (RenderTexture src, RenderTexture dest) { \t\tif (material != null) { \t\t\t//降采样，采样是原来的 1/downSample ss \t\t\tint rtW = src.width/downSample; \t\t\tint rtH = src.height/downSample; \t\t\tRenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0); \t\t\tbuffer0.filterMode = FilterMode.Bilinear; \t\t\tGraphics.Blit(src, buffer0); \t\t\tfor (int i = 0; i &lt; iterations; i++) { \t\t\t\tmaterial.SetFloat(\"_BlurSize\", 1.0f + i * blurSpread); \t\t\t\t//分配一块屏幕大小缓冲区 \t\t\t\tRenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0); \t\t\t\t// Render the vertical pass \t\t\t\tGraphics.Blit(buffer0, buffer1, material, 0); \t\t\t\t//释放缓冲 \t\t\t\tRenderTexture.ReleaseTemporary(buffer0); \t\t\t\tbuffer0 = buffer1; \t\t\t\tbuffer1 = RenderTexture.GetTemporary(rtW, rtH, 0); \t\t\t\t// Render the horizontal pass \t\t\t\tGraphics.Blit(buffer0, buffer1, material, 1); \t\t\t\tRenderTexture.ReleaseTemporary(buffer0); \t\t\t\tbuffer0 = buffer1; \t\t\t} \t\t\tGraphics.Blit(buffer0, dest); \t\t\tRenderTexture.ReleaseTemporary(buffer0); \t\t} else { \t\t\tGraphics.Blit(src, dest); \t\t} \t} } Properties { \t\t_MainTex (\"Base (RGB)\", 2D) = \"white\" {} \t\t_BlurSize (\"Blur Size\", Float) = 1.0 \t} \tSubShader { \t\tCGINCLUDE \t\t#include \"UnityCG.cginc\" \t\tsampler2D _MainTex; \t\thalf4 _MainTex_TexelSize; \t\tfloat _BlurSize; \t\tstruct v2f { \t\t\tfloat4 pos : SV_POSITION; \t\t\thalf2 uv[5]: TEXCOORD0; \t\t}; \t\tv2f vertBlurVertical(appdata_img v) { \t\t\tv2f o; \t\t\to.pos = UnityObjectToClipPos(v.vertex); \t\t\thalf2 uv = v.texcoord; \t\t\to.uv[0] = uv; \t\t\t//偏移后的uv \t\t\to.uv[1] = uv + float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize; \t\t\to.uv[2] = uv - float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize; \t\t\to.uv[3] = uv + float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize; \t\t\to.uv[4] = uv - float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize; \t\t\treturn o; \t\t} \t\tv2f vertBlurHorizontal(appdata_img v) { \t\t\tv2f o; \t\t\to.pos = UnityObjectToClipPos(v.vertex); \t\t\thalf2 uv = v.texcoord; \t\t\to.uv[0] = uv; \t\t\to.uv[1] = uv + float2(_MainTex_TexelSize.x * 1.0, 0.0) * _BlurSize; \t\t\to.uv[2] = uv - float2(_MainTex_TexelSize.x * 1.0, 0.0) * _BlurSize; \t\t\to.uv[3] = uv + float2(_MainTex_TexelSize.x * 2.0, 0.0) * _BlurSize; \t\t\to.uv[4] = uv - float2(_MainTex_TexelSize.x * 2.0, 0.0) * _BlurSize; \t\t\treturn o; \t\t} \t\tfixed4 fragBlur(v2f i) : SV_Target { \t\t\tfloat weight[3] = {0.4026, 0.2442, 0.0545}; \t\t\tfixed3 sum = tex2D(_MainTex, i.uv[0]).rgb * weight[0]; \t\t\tfor (int it = 1; it &lt; 3; it++) { \t\t\t\tsum += tex2D(_MainTex, i.uv[it*2-1]).rgb * weight[it]; \t\t\t\tsum += tex2D(_MainTex, i.uv[it*2]).rgb * weight[it]; \t\t\t} \t\t\treturn fixed4(sum, 1.0); \t\t} \t\tENDCG \t\tZTest Always Cull Off ZWrite Off \t\tPass { \t\t\tNAME \"GAUSSIAN_BLUR_VERTICAL\" \t\t\tCGPROGRAM \t\t\t#pragma vertex vertBlurVertical \t\t\t#pragma fragment fragBlur \t\t\tENDCG \t\t} \t\tPass { \t\t\tNAME \"GAUSSIAN_BLUR_HORIZONTAL\" \t\t\tCGPROGRAM \t\t\t#pragma vertex vertBlurHorizontal \t\t\t#pragma fragment fragBlur \t\t\tENDCG \t\t} \t} \tFallBack \"Diffuse\" 调整屏幕亮度，饱和度，对比度 基本概念 不清楚屏幕亮度，饱和度，对比度的定义,这里参考了 csdn 博客，大家可以直接参考 @feilong_csdn【数字图像处理系列二】基本概念：亮度、对比度、饱和度、锐化、分辨率 实现 屏幕后处理效果基类 using UnityEngine; using System.Collections; [ExecuteInEditMode] [RequireComponent (typeof(Camera))] public class PostEffectsBase : MonoBehaviour { \t// Called when start \tprotected void CheckResources() { \t\tbool isSupported = CheckSupport(); \t\tif (isSupported == false) { \t\t\tNotSupported(); \t\t} \t} \t// Called in CheckResources to check support on this platform \tprotected bool CheckSupport() { \t\tif (SystemInfo.supportsImageEffects == false || SystemInfo.supportsRenderTextures == false) { \t\t\tDebug.LogWarning(\"This platform does not support image effects or render textures.\"); \t\t\treturn false; \t\t} \t\treturn true; \t} \t// Called when the platform doesn't support this effect \tprotected void NotSupported() { \t\tenabled = false; \t} \tprotected void Start() { \t\tCheckResources(); \t} \t// 创建material 这里如果不传入material 将会创建一个material 的实例 \tprotected Material CheckShaderAndCreateMaterial(Shader shader, Material material) { \t\tif (shader == null) { \t\t\treturn null; \t\t} \t\tif (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader) \t\t\treturn material; \t\tif (!shader.isSupported) { \t\t\treturn null; \t\t} \t\telse { \t\t\tmaterial = new Material(shader); \t\t\tmaterial.hideFlags = HideFlags.DontSave; \t\t\tif (material) \t\t\t{ \t\t\t\t//返回创建的material \t\t\t\treturn material; \t\t\t} \t\t\telse \t\t\t\treturn null; \t\t} \t} } 亮度，对比度，饱和度的实现 using UnityEngine; using System.Collections; public class BrightnessSaturationAndContrast : PostEffectsBase { \tpublic Shader briSatConShader; \t//可以省略Properties中的属性声明，Properties中声明的属性仅仅为了显示在材质面板中 \t//对于屏幕特效来说，材质都是临时创建的，这些参数我们会从脚本中直接传递 \tprivate Material briSatConMaterial; \tpublic Material material { \t\tget { \t\t\tbriSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial); \t\t\treturn briSatConMaterial; \t\t} \t} \t[Range(0.0f, 3.0f)] \tpublic float brightness = 1.0f; \t[Range(0.0f, 3.0f)] \tpublic float saturation = 1.0f; \t[Range(0.0f, 3.0f)] \tpublic float contrast = 1.0f; \t//渲染图像时，检查材质是否可用 \tvoid OnRenderImage(RenderTexture src, RenderTexture dest) { \t\tif (material != null) { \t\t\tmaterial.SetFloat(\"_Brightness\", brightness); \t\t\tmaterial.SetFloat(\"_Saturation\", saturation); \t\t\tmaterial.SetFloat(\"_Contrast\", contrast); \t\t\t//Graphics.Blit 将把第一个参数传递给名为_MainTex的属性，因此必须声明一个_MainTex的纹理属性。 \t\t\tGraphics.Blit(src, dest, material); \t\t} else { \t\t\tGraphics.Blit(src, dest); \t\t} \t} } Properties { \t\t_MainTex (\"Base (RGB)\", 2D) = \"white\" {} \t\t_Brightness (\"Brightness\", Float) = 1 \t\t_Saturation(\"Saturation\", Float) = 1 \t\t_Contrast(\"Contrast\", Float) = 1 \t} \tSubShader { \t\tPass { \t\t\tZTest Always Cull Off ZWrite Off \t\t\tCGPROGRAM \t\t\t#pragma vertex vert \t\t\t#pragma fragment frag \t\t\t#include \"UnityCG.cginc\" \t\t\tsampler2D _MainTex; \t\t\thalf _Brightness; \t\t\thalf _Saturation; \t\t\thalf _Contrast; \t\t\t// struct appdata_img \t\t\t// { \t\t\t// \tfloat4 vertex : POSITION; \t\t\t// \thalf2 texcoord : TEXCOORD0; \t\t\t// \tUNITY_VERTEX_INPUT_INSTANCE_ID \t\t\t// }; \t\t\tstruct v2f { \t\t\t\tfloat4 pos : SV_POSITION; \t\t\t\thalf2 uv: TEXCOORD0; \t\t\t}; \t\t\tv2f vert(appdata_img v) { \t\t\t\tv2f o; \t\t\t\to.pos = UnityObjectToClipPos(v.vertex); \t\t\t\to.uv = v.texcoord; \t\t\t\treturn o; \t\t\t} \t\t\tfixed4 frag(v2f i) : SV_Target { \t\t\t\tfixed4 renderTex = tex2D(_MainTex, i.uv); \t\t\t\t// Apply brightness \t\t\t\tfixed3 finalColor = renderTex.rgb * _Brightness; \t\t\t\t// Apply saturation \t\t\t\t//计算亮度值 通过对每个颜色分量乘以一个特定的系数再相加得到当前像素亮度值 \t\t\t\tfixed luminance = 0.2125 * renderTex.r + 0.7154 * renderTex.g + 0.0721 * renderTex.b; \t\t\t\t//饱和度为0的颜色值，使用_Saturation对上一步得到的颜色之间进行插值，从而得到希望的饱和度颜色 \t\t\t\tfixed3 luminanceColor = fixed3(luminance, luminance, luminance); \t\t\t\tfinalColor = lerp(luminanceColor, finalColor, _Saturation); \t\t\t\t// Apply contrast \t\t\t\tfixed3 avgColor = fixed3(0.5, 0.5, 0.5); \t\t\t\t//对比度 \t\t\t\tfinalColor = lerp(avgColor, finalColor, _Contrast); \t\t\t\treturn fixed4(finalColor, renderTex.a); \t\t\t} \t\t\tENDCG \t\t} \t} \tFallback Off " }, { "title": "shader入门基础-内置变量，标签，函数，光照模型", "url": "/posts/shader22/", "categories": "unity", "tags": "shader", "date": "2020-05-12 10:36:00 +0800", "content": "变量 Unity 内置的变换矩阵 函数 光照模型 漫反射 公式 \\(\\mathtt{c}_{diffuse}=(\\mathtt{c}_{light}\\cdot \\mathtt{m}_{diffuse})max(0,\\vec n \\cdot \\vec l)\\) $\\vec n$ 是表面法线，$\\vec l$ 指向光源的单位矢量，$m_{diffuse}$ 材质漫反射颜色，$c_{light}$ 是光源颜色。 高光反射 phong 模型 公式$$ \\mathtt{c}{specular}=(\\mathtt{c}{light}\\cdot\\mathtt{m}{specular})max(0,\\vec v\\cdot\\vec r)^{m{gloss}} \\[$m_{gloss}$是材质的光泽度（gloss）,也被称为反光度（shininess）,它用于控制高光区域的亮点有多大，$m_{gloss}$越大，亮点越小。 $m_{specular}$是材质高光反射颜色，它用于控制该材质对于高光反射的强度和颜色。$c_{light}$则是光源的颜色和强度。 $\\vec r$是反射方向，反射可以通过计算获得 $\\vec r=2(\\vec n\\cdot\\vec l)\\vec n-\\vec l$ #### Blinn模型 公式\\] \\mathtt{c}{specular}=(\\mathtt{c}{light}\\cdot\\mathtt{m}{specular})max(0,\\vec n\\cdot\\vec h)^{m{gloss}} \\(Blinn 基本思想是 避免计算反射方向$\\vec r$,引入新的矢量 $\\vec h$。\\)\\vec h=\\frac{\\vec v+\\vec l}{|\\vec v+\\vec l|}$$ 半兰伯特模型 公式 \\(\\mathtt{c}_{diffuse}=(\\mathtt{c}_{light}\\cdot \\mathtt{m}_{diffuse})(\\alpha(0,\\vec n \\cdot \\vec l)+\\beta)\\) 半兰伯特模型没有使用max操作来防止$\\vec n$和$\\vec l$和的点积为负值，而是进行了$\\alpha$倍的缩放和再加上一个$\\beta$的偏移。 在绝大多数情况下，$\\alpha$和$\\beta$的值均为0.5。一般公式为 \\(\\mathtt{c}_{diffuse}=(\\mathtt{c}_{light}\\cdot \\mathtt{m}_{diffuse})(0.5(0,\\vec n \\cdot \\vec l)+0.5)\\) 指令 常见的渲染状态设置选项 状态名称 设置指令 解释 Cull Cull Back Front Off 设置剔除模式:剔除背面/正面/关闭 ZTest ZTest Less Greater/LEqula/GEqual/Equal/NotEqual/Always 设置深度测试 ZWrite ZWrite On/Off 开启/关闭深度写入 Blend Blend SrcFactor DstFactor 开启并设置混合模式 用于SubShader则会对所有Pass生效，用于特定Pass则对特定Pass生效。 透明度混合 Tags SubShader的标签类型 Pass的标签类型 Unity提前定影的5个渲染队列 $$ " }, { "title": "shader入门基础-动画", "url": "/posts/shader21/", "categories": "unity", "tags": "shader", "date": "2020-05-12 10:36:00 +0800", "content": "Unity 内置时间变量 名称 类型 描述 _Time float4 t 是自然该场景加载开始所经过的时间，(t/20,t,2t,3t) _SinTime float4 t 是时间的正弦值，(t/8,t/4,t/2,t) _CosTime float4 t 是时间的余弦值，(t/8,t/4,t/2,t) unity_DeltaTime float4 dt 是时间增量，(dt,1/dt,smoothDt,1/smoothDt) 纹理动画 Shader \"Practice/SequenceAnim\" { Properties { _MainTex (\"Texture\", 2D) = \"white\" {} _RowCount(\"行数\",int)=4 _ColCount(\"列数\",int)=4 _Speed(\"播放速度\",Range(0,100))=1.0 } SubShader { // No culling or depth Tags {\"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"true\" \"RenderType\"=\"Transparent\"} Pass { Tags {\"LightModel\"=\"ForwardBase\"} Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" sampler2D _MainTex; float4 _MainTex_ST; float _Speed; half _RowCount; half _ColCount; struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; }; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv,_MainTex) ; return o; } fixed4 frag (v2f i) : SV_Target { float length = _Speed*_Time.y; half curRow = floor(length/_ColCount); half curCol = floor(length-curRow*_ColCount); half2 uv =float2(i.uv.x/_ColCount,i.uv.y/_RowCount); uv.x+= curCol/_ColCount; uv.y-= curRow/_RowCount; fixed4 col =tex2D(_MainTex,uv); return col; } ENDCG } } } 滚动的背景 Shader \"Practice/BgAnim\" { Properties { _FirstBG (\"FirstBG\", 2D) = \"white\" {} _SecondBG (\"FirstBG\", 2D) = \"white\" {} _ScrollX(\"_ScrollX\",float) = 1 _ScrollX2(\"_ScrollX2\",float)=1.1 } SubShader { // No culling or depth Cull Off ZWrite Off ZTest Always Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" sampler2D _FirstBG; sampler2D _SecondBG; fixed4 _FirstBG_ST; fixed4 _SecondBG_ST; float _ScrollX2; float _ScrollX; struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; struct v2f { float4 uv : TEXCOORD0; float4 vertex : SV_POSITION; }; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv.xy =TRANSFORM_TEX(v.uv,_FirstBG); o.uv.zw = TRANSFORM_TEX(v.uv,_SecondBG); return o; } fixed4 frag (v2f i) : SV_Target { float2 uv_offset = frac(float2(_ScrollX,0.0)*_Time.y); float2 uv_offset2 = frac(float2(_ScrollX2,0.0)*_Time.y); fixed4 col = tex2D(_FirstBG, i.uv.xy+uv_offset); fixed4 col2 =tex2D(_SecondBG,i.uv.zw+uv_offset2); fixed4 final_col=lerp(col,col2,col2.a); return final_col; } ENDCG } } } 顶点动画 DisableBatching: 批处理会合并所有相关的模型，而这些模型各自的模型空间会丢失。我们需要在物体的模型空间下对顶点位置进行偏移，因此需要取消 批处理操作。 Properties { \t\t_MainTex (\"Main Tex\", 2D) = \"white\" {} \t\t_Color (\"Color Tint\", Color) = (1, 1, 1, 1) \t\t_Magnitude (\"Distortion Magnitude\", Float) = 1 \t\t_Frequency (\"Distortion Frequency\", Float) = 1 \t\t_InvWaveLength (\"Distortion Inverse Wave Length\", Float) = 10 \t\t_Speed (\"Speed\", Float) = 0.5 \t} \tSubShader { \t\t// Need to disable batching because of the vertex animation \t\tTags {\"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"Transparent\" \"DisableBatching\"=\"True\"} \t\tPass { \t\t\tTags { \"LightMode\"=\"ForwardBase\" } \t\t\tZWrite Off \t\t\tBlend SrcAlpha OneMinusSrcAlpha \t\t\tCull Off \t\t\tCGPROGRAM \t\t\t#pragma vertex vert \t\t\t#pragma fragment frag \t\t\t#include \"UnityCG.cginc\" \t\t\tsampler2D _MainTex; \t\t\tfloat4 _MainTex_ST; \t\t\tfixed4 _Color; \t\t\tfloat _Magnitude; \t\t\tfloat _Frequency; \t\t\tfloat _InvWaveLength; \t\t\tfloat _Speed; \t\t\tstruct a2v { \t\t\t\tfloat4 vertex : POSITION; \t\t\t\tfloat4 texcoord : TEXCOORD0; \t\t\t}; \t\t\tstruct v2f { \t\t\t\tfloat4 pos : SV_POSITION; \t\t\t\tfloat2 uv : TEXCOORD0; \t\t\t}; \t\t\tv2f vert(a2v v) { \t\t\t\tv2f o; \t\t\t\tfloat4 offset; \t\t\t\toffset.yzw = float3(0.0, 0.0, 0.0); \t\t\t\toffset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude; \t\t\t\to.pos = UnityObjectToClipPos(v.vertex + offset); \t\t\t\to.uv = TRANSFORM_TEX(v.texcoord, _MainTex); \t\t\t\to.uv += float2(0.0, _Time.y * _Speed); \t\t\t\treturn o; \t\t\t} \t\t\tfixed4 frag(v2f i) : SV_Target { \t\t\t\tfixed4 c = tex2D(_MainTex, i.uv); \t\t\t\tc.rgb *= _Color.rgb; \t\t\t\treturn c; \t\t\t} \t\t\tENDCG \t\t} \t} \tFallBack \"Transparent/VertexLit\" 广告牌技术 根据视角方向来旋转一个被纹理着色的多边形，使得多边形看起来好像总是面对摄像机。广告牌技术的本质是构建旋转矩阵。 为了避免使用模型空间的中心作为锚点，我们可以利用顶点颜色存储每个顶点到锚点的距离值。 Shader \"Practice/BillBoard\" { Properties { \t\t_MainTex (\"Main Tex\", 2D) = \"white\" {} \t\t_Color (\"Color Tint\", Color) = (1, 1, 1, 1) \t\t_VerticalBillboarding (\"Vertical Restraints\", Range(0, 1)) = 1 \t} \tSubShader { \t\t// 关闭批处理，批处理会导致模型各自的模型空间丢失 \t\tTags {\"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"Transparent\" \"DisableBatching\"=\"True\"} \t\tPass { \t\t\tTags { \"LightMode\"=\"ForwardBase\" } \t\t\tZWrite Off \t\t\tBlend SrcAlpha OneMinusSrcAlpha //关闭剔除让广告牌每个面都能显示 \t\t\tCull Off \t\t\tCGPROGRAM \t\t\t#pragma vertex vert \t\t\t#pragma fragment frag \t\t\t#include \"Lighting.cginc\" \t\t\tsampler2D _MainTex; \t\t\tfloat4 _MainTex_ST; \t\t\tfixed4 _Color; \t\t\tfixed _VerticalBillboarding; \t\t\tstruct a2v { \t\t\t\tfloat4 vertex : POSITION; \t\t\t\tfloat4 texcoord : TEXCOORD0; \t\t\t}; \t\t\tstruct v2f { \t\t\t\tfloat4 pos : SV_POSITION; \t\t\t\tfloat2 uv : TEXCOORD0; \t\t\t}; \t\t\tv2f vert (a2v v) { \t\t\t\tv2f o; \t\t\t\t//模型空间位置原点 \t\t\t\tfloat3 center = float3(0, 0, 0); //将摄像机位置转换到模型空间坐标 \t\t\t\tfloat3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, 1)); \t\t\t\t// 摄像机指向原点的方向作为法线方向 \t\t\t\tfloat3 normalDir = viewer - center; //_VerticalBillboarding == 1 我们使用摄像机指向原点的方向作为法线方向 //_VerticalBillboarding == 0 则固定方向作为法线方向 \t\t\t\tnormalDir.y =normalDir.y * _VerticalBillboarding; \t\t\t\tnormalDir = normalize(normalDir); \t\t\t\t// 获取up方向 \t\t\t\tfloat3 upDir = abs(normalDir.y) &gt; 0.999 ? float3(0, 0, 1) : float3(0, 1, 0); //叉积后获取指向右方的向量 \t\t\t\tfloat3 rightDir = normalize(cross(upDir, normalDir)); \t\t\t\tupDir = normalize(cross(normalDir, rightDir)); \t\t\t\t// 使用3个正焦急矢量做相对于锚点旋转 \t\t\t\tfloat3 centerOffs = v.vertex.xyz - center; \t\t\t\tfloat3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z; \t\t\t\to.pos = UnityObjectToClipPos(float4(localPos, 1)); \t\t\t\to.uv = TRANSFORM_TEX(v.texcoord,_MainTex); \t\t\t\treturn o; \t\t\t} \t\t\tfixed4 frag (v2f i) : SV_Target { \t\t\t\tfixed4 c = tex2D (_MainTex, i.uv); \t\t\t\tc.rgb *= _Color.rgb; \t\t\t\treturn c; \t\t\t} \t\t\tENDCG \t\t} \t} \tFallBack \"Transparent/VertexLit\" } 对包含顶点动画的物体添加阴影 \t\tPass { //阴影投射pass \t\t\tTags { \"LightMode\" = \"ShadowCaster\" } \t\t\tCGPROGRAM \t\t\t#pragma vertex vert \t\t\t#pragma fragment frag \t\t\t#pragma multi_compile_shadowcaster \t\t\t#include \"UnityCG.cginc\" \t\t\tfloat _Magnitude; \t\t\tfloat _Frequency; \t\t\tfloat _InvWaveLength; \t\t\tfloat _Speed; \t\t\tstruct v2f { \t\t\t V2F_SHADOW_CASTER; \t\t\t}; \t\t\tv2f vert(appdata_base v) { \t\t\t\tv2f o; \t\t\t\tfloat4 offset; \t\t\t\toffset.yzw = float3(0.0, 0.0, 0.0); \t\t\t\toffset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude; \t\t\t\tv.vertex = v.vertex + offset; \t\t\t\tTRANSFER_SHADOW_CASTER_NORMALOFFSET(o) \t\t\t\treturn o; \t\t\t} \t\t\tfixed4 frag(v2f i) : SV_Target { \t\t\t SHADOW_CASTER_FRAGMENT(i) \t\t\t} \t\t\tENDCG \t\t} " }, { "title": "shader入门基础-复杂光照二", "url": "/posts/shader20/", "categories": "unity", "tags": "shader", "date": "2020-05-08 15:36:00 +0800", "content": "光照衰减 Unity 使用一张纹理作为查找表来在片原着色器中计算逐像素光照的衰减。 优点 计算衰减不依赖数学公式的复杂性，只需要使用一个参数做纹理采样。 缺点 需要预处理得到采样纹理，而且纹理的大小也会影响到衰减的精度。 不直观，不方便，一旦把数据存储到查找表中，无法使用其他数学公式计算衰减。 用于光照衰减的纹理 Unity 在内部使用了一张名为_LightTexture0 的纹理来计算光照衰减，如果对该光源使用了 cookie，则对应_LightTextureB0,通常我们只关心_LightTexture0 对角线上的纹理颜色值，（0，0）表示与光源重合位置的衰减值，（1，1）点表明了光源空间中所关心距离最远的点的衰减。 顶点在光源空间中的坐标，参数是顶点在世界空间中的坐标。 float3 lightCoord=mul(_LightMatrix0,float4(i.worldPosition,1)).xyz fixed atten = tex2D(_LightTexture0,dot(lightCoord,lightCoord).rr).UNITY_ATTEN_CHANNEL 阴影 实时渲染中，最常使用的是一种名为 Shadow Map 的技术。把摄像机的位置放在光源重合位置上，阴影便是摄像机看不到的地方，在前向渲染中，如果 场景中最重要的平行光开启了阴影，Unity 就会为该光源计算它的阴影映射纹理（shadowmap），shandowmap 本质是一张深度图，记录了该光源的位置出发 能看到场景中距离它最近的表面位置（深度信息）。Unity 会将 LightModel 设置为 ShadowCaster 的 Pass 专门用来更新光源的阴影映射纹理。 让物体投射阴影 Pass { Name \"ShadowCaster\" Tags { \"LightMode\" = \"ShadowCaster\" } CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma target 2.0 #pragma multi_compile_shadowcaster #pragma multi_compile_instancing // allow instanced shadow pass for most of the shaders #include \"UnityCG.cginc\" struct v2f { V2F_SHADOW_CASTER; UNITY_VERTEX_OUTPUT_STEREO }; v2f vert( appdata_base v ) { v2f o; UNITY_SETUP_INSTANCE_ID(v); UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o); TRANSFER_SHADOW_CASTER_NORMALOFFSET(o) return o; } float4 frag( v2f i ) : SV_Target { SHADOW_CASTER_FRAGMENT(i) } ENDCG 让物体接收阴影 Cast Shadows 设置为 On,该物体就会加入到光源的阴影映射纹理的计算中，从而让其他物体在对阴影映射纹理采样时可以得到该物体的相关信息。 Recieve Shadows则可以选择是否让物体接受来自其他物体的阴影。 SHADOW_COORDS 在顶点着色器的输出结构体 v2f 中添加，该宏用于声明一个用于对阴影纹理采样的坐标。该宏的参数需要是下一个可用的插值寄存器的索引值。 TRANSFER_SHADOW 在顶点着色器返回之前添加，用于在顶点着色器中计算上一步中声明的阴影纹理坐标。 SHADOW_ATTENUATION 在片元着色器中计算阴影值。 UNITY_LIGHT_ATTENUATION 该宏用于计算光照衰减和阴影的宏， 第一个参数 atten，宏会声明，我们不需要声明，第二个参数是结构体 v2f，第三个参数是世界空间的坐标。 //传递shadow coordinates fixed shadow = SHADOW_ATTENUATION(i) 注意 这些宏中会使用上下文变量来进行相关计算，例如 TRANSFER_SHADOW 会使用 v.vertex 或 a.pos 来计算坐标，因此为了能够让这些宏正确工作，我们需要保证自定义 的变量名和这些宏中使用的变量名匹配。我们需要保证 a2v 结构体的顶点坐标变量名必须是 vertex，顶点着色器的输入结构体必 a2v 必须命名为 v，且 v2f 中的顶点位置变量必须命名为 pos。 对于大多数不透明物体来说，把 Fallback 设为 VertexLit 就可以得到正确的阴影。对于使用了透明度测试的物体，要得到正确的阴影效果，我们会把 Fallback 设置 为 Transparent/Cutout/VertexLit。 实践 // Upgrade NOTE: replaced '_Object2World' with 'unity_ObjectToWorld' Shader \"Practice/AlphaTest\" { Properties { _MainTex (\"Texture\", 2D) = \"white\" {} _Color(\"Color Tint\",Color) = (1,1,1,1) _Cutoff(\"Alpha Cutoff\",Range(0,1))=0.5 } SubShader { //RenderType 可以让unity把这个shader归入到提“TransparentCutout” //\"IgnoreProjector\"=\"True\" 不受投影器影响 //渲染序列设置为 AlphaTest Tags { \"Queue\"=\"AlphaTest\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"TransparentCutout\" } Pass { //LightModel 是 pass标签的一种，正确定义LightModel 才能正确得到unity的内置光照变量 Tags {\"LightModel\"=\"ForwardBase\"} CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" //包含内置变量的 _LightColor0 #include \"Lighting.cginc\" #include \"AutoLight.cginc\" //C_diffuse = (C_light·m_diffuse)max(0,N·L) //漫反射计算公式 //都在unity 世界坐标计算，需要知道顶点在世界的位置，顶点法线，顶点视角位置 struct appdata { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord :TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; float4 pos : SV_POSITION; float3 worldNormal:NORMAL; float3 worldPos:TEXCOORD2; //下一个插值寄存器 3 SHADOW_COORDS(3) }; sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; fixed _Cutoff; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); //把顶点坐标转换到世界坐标，为后续取 L做准备 o.worldPos = mul(unity_ObjectToWorld,v.vertex); //把法线转换到 世界空间中 o.worldNormal = UnityObjectToWorldNormal(v.normal); //纹理映射坐标，该顶点在纹理中对应的2D坐标 o.uv=v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; TRANSFER_SHADOW(o); return o; } fixed4 frag (v2f i) : SV_Target { //逐像素 光照 //C_diffuse = (C_light·m_diffuse)max(0,N·L) //获取公式中的各个变量，m_diffuse =此时材质面板给定的_Color*顶点的color fixed4 col; fixed4 texColor = tex2D(_MainTex,i.uv); fixed3 N = normalize(i.worldNormal); //UnityWorldSpaceLightDir输入世界空间中的坐标点，WorldSpaceLightDir 输入模型空间中的坐标顶点 fixed3 L = normalize(UnityWorldSpaceLightDir(i.worldPos)); clip(texColor.a-_Cutoff); //equal to //if(m_diffuse.a-_Cutoff)&lt;0{ //discard; //} //计算漫反射部分 fixed3 c_light = _LightColor0.rgb; fixed3 m_diffuse =texColor.rgb*_Color.rgb; fixed3 c_diffuse = c_light*m_diffuse*max(0,dot(N,L)); //计算环境光产生的影响,环境光反射的也会受材质本身颜色影响 fixed3 ambient = m_diffuse*UNITY_LIGHTMODEL_AMBIENT.rgb; //计算光照衰减和阴影 UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos); //环境光和漫反射光 col = fixed4(ambient+c_diffuse*atten,1.0); return col; } ENDCG } } FallBack \"Transparent/Cutout/VertexLit\" } " }, { "title": "shader入门基础-高级纹理", "url": "/posts/shader19/", "categories": "unity", "tags": "shader", "date": "2020-05-07 16:36:00 +0800", "content": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解 立方体纹理(Cubemap) 立方体纹理一共包含了 6 张图像，这些图像对应了一个立方体的 6 个面，立方体纹理的名称也由此而来。立方体纹理是环境映射(Environment Mapping)的一种实现方法。 天空盒 shader 使用 Skybox/6 Sided,需要 6 张纹理 纹理的 wrap mode 设置为 Clamp，以防止在接缝处出现不匹配的现象 保证渲染场景的摄像机的 Camera 组件 Clear Flags 被设置为 Skybox 天空盒设置如图 反射 //反射 Shader \"Practice/Reflection\" { \tProperties { \t\t_Color (\"Color Tint\", Color) = (1, 1, 1, 1) \t\t_ReflectColor (\"Reflection Color\", Color) = (1, 1, 1, 1) \t\t_ReflectAmount (\"Reflect Amount\", Range(0, 1)) = 1 \t\t//立方体纹理进行采样 \t\t_Cubemap (\"Reflection Cubemap\", Cube) = \"_Skybox\" {} \t} \tSubShader { \t\tTags { \"RenderType\"=\"Opaque\" \"Queue\"=\"Geometry\"} \t\tPass { \t\t\tTags { \"LightMode\"=\"ForwardBase\" } \t\t\tCGPROGRAM \t\t\t#pragma multi_compile_fwdbase \t\t\t#pragma vertex vert \t\t\t#pragma fragment frag \t\t\t#include \"Lighting.cginc\" \t\t\t#include \"AutoLight.cginc\" \t\t\tfixed4 _Color; \t\t\tfixed4 _ReflectColor; \t\t\tfixed _ReflectAmount; \t\t\tsamplerCUBE _Cubemap; \t\t\tstruct a2v { \t\t\t\t//使用阴影计算的宏，必须用vertex \t\t\t\tfloat4 vertex : POSITION; \t\t\t\tfloat3 normal : NORMAL; \t\t\t}; \t\t\tstruct v2f { \t\t\t\t//使用阴影计算的宏，必须用pos \t\t\t\tfloat4 pos : SV_POSITION; \t\t\t\tfloat3 worldPos : TEXCOORD0; \t\t\t\tfixed3 worldNormal : TEXCOORD1; \t\t\t\tfixed3 worldViewDir : TEXCOORD2; \t\t\t\tfixed3 worldRefl : TEXCOORD3; \t\t\t\tSHADOW_COORDS(4) \t\t\t}; \t\t\tv2f vert(a2v v) { \t\t\t\tv2f o; \t\t\t\to.pos = UnityObjectToClipPos(v.vertex); \t\t\t\to.worldNormal = UnityObjectToWorldNormal(v.normal); \t\t\t\to.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; \t\t\t\to.worldViewDir = UnityWorldSpaceViewDir(o.worldPos); \t\t\t\t// 计算 反射方向 \t\t\t\to.worldRefl = reflect(-o.worldViewDir, o.worldNormal); \t\t\t\tTRANSFER_SHADOW(o); \t\t\t\treturn o; \t\t\t} \t\t\tfixed4 frag(v2f i) : SV_Target { \t\t\t\tfixed3 worldNormal = normalize(i.worldNormal); \t\t\t\tfixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); \t\t\t\tfixed3 worldViewDir = normalize(i.worldViewDir); \t\t\t\t//环境光 \t\t\t\tfixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; \t\t\t\t////C_diffuse = (C_light·m_diffuse)max(0,N·L) //漫反射计算公式 \t\t\t\tfixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0, dot(worldNormal, worldLightDir)); \t\t\t\t//texCUBE 对立方体纹理进行采样 \t\t\t\tfixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb; \t\t\t\tUNITY_LIGHT_ATTENUATION(atten, i, i.worldPos); \t\t\t\t// Mix the diffuse color with the reflected color \t\t\t\t//混合漫反射和反射颜色等价于 \t\t\t\t//float lerp(float a, float b, float w) { \t\t\t\t//return a(1-w) + b * w; \t\t\t\t//} \t\t\t\t//混合后 阴影值与漫反射和反射颜色值相乘 \t\t\t\tfixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten; \t\t\t\treturn fixed4(color, 1.0); \t\t\t} \t\t\tENDCG \t\t} \t} \tFallBack \"Reflective/VertexLit\" } 折射 斯涅耳定律 \\(\\eta_1sin\\theta_1=\\eta_2sin\\theta_2\\) \\(\\eta_1和\\eta_2\\) 是兩個介質的折射率。 refract 第一个参数是入射光线的方向，它必须是归一化后的矢量；第二个参数是表面法线，法线方向同样需要是归一化后的，第三个参数是入射光线 所在介质的折射率和折射光线所在介质的折射率之间的比值。 //折射 Shader \"Practice/Refract\" { Properties { _Color (\"Color Tint\", Color) = (1,1,1,1) _RefractColor(\"折射顏色\",Color)=(1,1,1,1) _RefractAmount(\"折射程度\",Range(0,1))=1 //入射光線所在介質的折射率和折射光線所在介質的折射率之間的比值 _RefractRatio(\"折射率比值\",Range(0.1,1))=0.5 //环境映射的立方体纹理 _Cubemap(\"环境映射\",Cube)=\"_Skybox\"{} } SubShader { // No culling or depth Tags{\"RenderType\"=\"Opaque\" \"Queue\"=\"Geometry\"} Pass { Tags{\"LightModel\"=\"ForwardBase\"} CGPROGRAM #pragma multi_compile_fwdbase #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" \t\t\t#include \"AutoLight.cginc\" fixed4 _Color; \t\t\tfixed4 _RefractColor; \t\t\tfloat _RefractAmount; \t\t\tfixed _RefractRatio; \t\t\tsamplerCUBE _Cubemap; \t\t\tstruct a2v { \t\t\t\tfloat4 vertex : POSITION; \t\t\t\tfloat3 normal : NORMAL; \t\t\t}; \t\t\tstruct v2f { \t\t\t\tfloat4 pos : SV_POSITION; \t\t\t\tfloat3 worldPos : TEXCOORD0; \t\t\t\tfixed3 worldNormal : TEXCOORD1; \t\t\t\tfixed3 worldViewDir : TEXCOORD2; \t\t\t\tfixed3 worldRefr : TEXCOORD3; \t\t\t\tSHADOW_COORDS(4) \t\t\t}; \t\t\tv2f vert(a2v v) { \t\t\t\tv2f o; \t\t\t\to.pos = UnityObjectToClipPos(v.vertex); \t\t\t\to.worldNormal = UnityObjectToWorldNormal(v.normal); \t\t\t\to.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; \t\t\t\to.worldViewDir = UnityWorldSpaceViewDir(o.worldPos); \t\t\t\t//第一个参数是入射光线的方向，它必须是归一化后的矢量；第二个参数是表面法线，法线方向同样需要是归一化后的，第三个参数是入射光线 //所在介质的折射率和折射光线所在介质的折射率之间的比值。 \t\t\t\to.worldRefr = refract(-normalize(o.worldViewDir), normalize(o.worldNormal), _RefractRatio); \t\t\t\tTRANSFER_SHADOW(o); \t\t\t\treturn o; \t\t\t} \t\t\tfixed4 frag(v2f i) : SV_Target { \t\t\t\tfixed3 worldNormal = normalize(i.worldNormal); \t\t\t\tfixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); \t\t\t\tfixed3 worldViewDir = normalize(i.worldViewDir); \t\t\t\tfixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; \t\t\t\tfixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0, dot(worldNormal, worldLightDir)); \t\t\t\t// Use the refract dir in world space to access the cubemap \t\t\t\tfixed3 refraction = texCUBE(_Cubemap, i.worldRefr).rgb * _RefractColor.rgb; \t\t\t\tUNITY_LIGHT_ATTENUATION(atten, i, i.worldPos); \t\t\t\t// Mix the diffuse color with the refract color \t\t\t\tfixed3 color = ambient + lerp(diffuse, refraction, _RefractAmount) * atten; \t\t\t\treturn fixed4(color, 1.0); \t\t\t} \t\t\tENDCG \t\t} \t} \tFallBack \"Reflective/VertexLit\" } 菲涅尔反射 菲涅尔反射描述了一种光学现象，即当光线照射到物体表面上是，一部分发生反射，一部分进入物体内部，发生折射或散射。 菲涅尔近等式： \\(F_{schlick(\\vec v,\\vec n)} = F_0+(1-F_0)*(1-\\vec v \\cdot \\vec n)^5\\) 渲染纹理 渲染目标纹理(Render Target Texture,RTT) GPU 允许把整个三维场景渲染到一个中间缓冲中。 多重渲染目标纹理(Multiple Render Target,MRT) GPU 允许我们把场景同事渲染到多个渲染目标纹理中，而不再需要为每个渲染目标纹理单独渲染完整的场景。 这里实现渲染目标纹理，把摄像机的渲染结果输出到一张图片中 //渲染目标物理 Shader \"Practice/RTT\" { Properties { _MainTex (\"Texture\", 2D) = \"white\" {} } SubShader { Tags {\"RenderType\"=\"Opaque\" \"Queue\"=\"Geometry\"} Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag \t\t\t#include \"UnityCG.cginc\" sampler2D _MainTex; float4 _MainTex_ST; struct a2v { float4 vertex:POSITION; float3 texcoord:TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; float4 pos : SV_POSITION; }; v2f vert (a2v v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.texcoord,_MainTex); return o; } fixed4 frag (v2f i) : SV_Target { fixed4 col = tex2D(_MainTex, i.uv); return col; } ENDCG } } } GrabPass 一种特殊的 Pass 来获取屏幕图像的目的。通常使用 GrabPass 来实现诸如玻璃等透明材质的模拟，与使用简单透明混合不同，使用 GrabPass 可以让我们对该物体后面的图像进行更浮渣的处理，例如使用法线来模拟折射效果，而不再是简单的和原屏幕颜色进行混合。 Grab 支持的两种形式： 直接使用 GrabPass{}，然后在后续的 Pass 中直接使用_GrabTexture 来访问屏幕图像。但是，当场景中有多个物体都使用了这样的形式抓取屏幕是，这种 方法的性能消耗比较大，因为对于每一个使用它的物体，Unity 都会为他单独进行一次昂贵的屏幕抓取操作。但这种方法可以让每个物体得到不同的屏幕图像，这取决于它们的渲染队列及渲染它们当时当前屏幕缓冲中的颜色。 使用 GrabPass{“TextureName”},Unity 只会在每一帧时为第一个使用名为 TextureName 的纹理的物体执行一次抓取屏幕的操作，而这个纹理同样可以在其他 Pass 中被访问。这种消耗更小。 Shader \"Practice/GlassRefraction\" { \tProperties { \t\t//该玻璃材质纹理 \t\t_MainTex (\"Main Tex\", 2D) = \"white\" {} \t\t//该玻璃法线纹理 \t\t_BumpMap (\"Normal Map\", 2D) = \"bump\" {} \t\t//模拟反射所用的环境纹理 \t\t_Cubemap (\"Environment Cubemap\", Cube) = \"_Skybox\" {} \t\t//用于控制模拟折射时图像的扭曲程度 \t\t_Distortion (\"Distortion\", Range(0, 100)) = 10 \t\t//用于控制折射程度，0则不会发生折射，只有反射，1则只有反射没有折射 \t\t_RefractAmount (\"Refract Amount\", Range(0.0, 1.0)) = 1.0 \t} \tSubShader { \t\t// 保证不透明物体先进行渲染. \t\tTags { \"Queue\"=\"Transparent\" \"RenderType\"=\"Opaque\" } \t\tGrabPass { \"_RefractionTex\" } \t\tPass { \t\t\tCGPROGRAM \t\t\t#pragma vertex vert \t\t\t#pragma fragment frag \t\t\t#include \"UnityCG.cginc\" \t\t\tsampler2D _MainTex; \t\t\tfloat4 _MainTex_ST; \t\t\tsampler2D _BumpMap; \t\t\tfloat4 _BumpMap_ST; \t\t\tsamplerCUBE _Cubemap; \t\t\tfloat _Distortion; \t\t\tfixed _RefractAmount; \t\t\t//GrabPass指定的纹理名称 \t\t\tsampler2D _RefractionTex; \t\t\t//纹理纹素大小 \t\t\tfloat4 _RefractionTex_TexelSize; \t\t\tstruct a2v { \t\t\t\tfloat4 vertex : POSITION; \t\t\t\tfloat3 normal : NORMAL; \t\t\t\tfloat4 tangent : TANGENT; \t\t\t\tfloat2 texcoord: TEXCOORD0; \t\t\t}; \t\t\tstruct v2f { \t\t\t\tfloat4 pos : SV_POSITION; \t\t\t\tfloat4 scrPos : TEXCOORD0; \t\t\t\tfloat4 uv : TEXCOORD1; \t\t\t\tfloat4 TtoW0 : TEXCOORD2; \t\t\t float4 TtoW1 : TEXCOORD3; \t\t\t float4 TtoW2 : TEXCOORD4; \t\t\t}; \t\t\tv2f vert (a2v v) { \t\t\t\tv2f o; \t\t\t\to.pos = UnityObjectToClipPos(v.vertex); \t\t\t\to.scrPos = ComputeGrabScreenPos(o.pos); \t\t\t\to.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex); \t\t\t\to.uv.zw = TRANSFORM_TEX(v.texcoord, _BumpMap); \t\t\t\tfloat3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; \t\t\t\tfixed3 worldNormal = UnityObjectToWorldNormal(v.normal); \t\t\t\tfixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz); \t\t\t\tfixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; \t\t\t\to.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x); \t\t\t\to.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y); \t\t\t\to.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z); \t\t\t\treturn o; \t\t\t} \t\t\tfixed4 frag (v2f i) : SV_Target { \t\t\t\tfloat3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w); \t\t\t\tfixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos)); \t\t\t\t// Get the normal in tangent space \t\t\t\tfixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw)); \t\t\t\t// Compute the offset in tangent space \t\t\t\tfloat2 offset = bump.xy * _Distortion * _RefractionTex_TexelSize.xy; \t\t\t\ti.scrPos.xy = offset * i.scrPos.z + i.scrPos.xy; \t\t\t\tfixed3 refrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb; \t\t\t\t// Convert the normal to world space \t\t\t\tbump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump))); \t\t\t\tfixed3 reflDir = reflect(-worldViewDir, bump); \t\t\t\tfixed4 texColor = tex2D(_MainTex, i.uv.xy); \t\t\t\tfixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb; \t\t\t\tfixed3 finalColor = reflCol * (1 - _RefractAmount) + refrCol * _RefractAmount; \t\t\t\treturn fixed4(finalColor, 1); \t\t\t} \t\t\tENDCG \t\t} \t} \tFallBack \"Diffuse\" } " }, { "title": "shader入门基础-更复杂光照", "url": "/posts/shader17/", "categories": "unity", "tags": "shader", "date": "2020-05-07 11:36:00 +0800", "content": "渲染路径 前向渲染路径(Forward Rendering Path) 延迟渲染路径(Defferred Rendering Path) 顶点照明渲染路径(Vertex Lit Rendering Path) 通过设置 Pass 的 LightMode 标签实现 Pass{ Tags {\"LightMode\"=\"ForwardBase\"} } LightMode 标签支持的渲染路径设置选项 标签名 描述 Always 不管使用哪种渲染路径，该 Pass 总是会被渲染，但不会计算任何光照 ForwardBase 用于前向渲染，该 pass 会计算环境光，最重要的平行光，逐顶点/SH 光源和 Lightmaps ForwardAdd 用于前向渲染，该 pass 会计算额外的逐像素光源，每个 pass 对应一个光源 Deferred 用于延迟渲染，该 pass 会渲染 G 缓冲 G-buffer ShadowCaster 把物体的深度信息渲染到阴影映射纹理（shadowmap）或一张深度纹理中 PrepassBase 用于遗留的延迟渲染，该 pass 会渲染法线和高光反射的指数部分 PrepassFinal 用于遗留的延迟渲染，该 pass 通过合并纹理、光照和自发光来渲染得到最后的颜色 Vertex、VertexLMRGBM 和 VertexLM 用于遗留的顶点照明渲染 前向渲染路径的原理 Pass{ for (each primitive in this model){ for (each fragment covered by this primitive) { if (failed in depth test) { //如果没有通过深度测试，则该片元时不可见 discard; } else{ //如果片元可见就记性光照机选 float4 color = Shading(materialinfo,pos,normal,lightDir,viewDir); //更新帧缓冲 writeFrameBuffer(fragment,color); } } } } 对于每个逐像素光源，我们都需要进行上面一次完整的渲染流程。如果一个物体在多个逐像素光源的影响区域内，那么该物体就需要执行多个 Pass， 每个 Pass 计算一个逐像素光源的光照结果，然后在帧缓冲中把这些光照结果混合起来得到最终的颜色值。假设场景中有个 N 个物体，每个物体受 M 个光源的 影响，那么要渲染整个场景一共需要 N*M 个 pass。 Unity 中的前向渲染 前向渲染路径有 3 种光照处理方式： 逐顶点处理 逐像素处理 球谐函数（Spherical Harmonics,SH） unity 会根据场景中各个光源的设置以及这些光源对物体影响程度，对这些光源进行一个重要度排序。 其中，一定数目光源按逐像素方式处理，最多 4 个光源会按逐顶点方式处理，剩下按 SH 方式处理。 Unity 排序规则 场景中最亮的平行光总是按逐像素处理 渲染模式被设置成 Not Important 的光源，会按逐顶点或者 SH 处理。 渲染模式被设置成 Important 的光源，会按照逐像素处理。 如果根据以上规则得到的逐像素官员数量小于 Quality Setting 中的逐像素光源数量，会有更多的光源以逐像素的方式进项渲染。 前向渲染的两种 Pass 延迟渲染原理 Pass 1 { //第一个pass不进行真正的光照计算 //仅仅把光照计算需要的信心存储到G缓冲中 for(each primitive in this model) { for(each fragment covered by this privitive) { if(failed in depth test) { //如果没有通过深度测试，说明该片元是不可见 discard; }else{ //如果该片元可见 //就把需要的信息存储到G缓冲中 writeGBuffer(materialInfo,pos,normal); } } } } Pass 2{ //利用G缓冲中的信息进行真正的光照计算 for(each pixel in the screen) { if(the pixel is valid) { //如果该像素是有效地 //读取它对应的G缓冲中的信息 readGBuffer(pixel,materialInfo,pos,normal); //根据读取到的信息进行光照计算 float4 color = Shading(materialInfo,pos,normal,lightDir,viewDir); //更新帧缓冲 writeFrameBuffer(pixel,color); } } } 延迟渲染使用的 Pass 数目通常就是两个，延迟渲染的效率不依赖于场景的复杂度，而是和我们使用的屏幕空间的大小有关。 Unity 中的延迟渲染 延迟渲染路径适合场景中光源数量较多、使用前向渲染路径会造成性能瓶颈的情况下使用，延迟渲染中的每个光源都可以按逐像素的方式进行处理。 延迟渲染缺点： 不支持真正的抗锯齿(anti-aliasing)功能 不能处理半透明物体（延迟渲染需要深度写入） 对显卡有一定要求 Unity 中使用延迟渲染路径，需要提供两个 Pass。 第一个 Pass 用于渲染 G 缓冲，在该 Pass 中将物体漫反射、高光反射、颜色、平滑度、法线、自发光和深度等信息渲染到屏幕空间的 G 缓冲区，因此，延迟渲染路径的效率不依赖与场景是否复杂，而是屏幕的分辨率高低。对于每个物体来说，这个 Pass 仅会执行一次。 第二个 Pass 用于计算真正的光照模型。这个 Pass 使用上一个 Pass 中渲染的数据来计算最终的光照颜色，再存储到帧缓冲中。 默认的 G 缓冲区包括以下渲染纹理(Render Texture): RT0：ARGB，RGB 通道存储漫反射颜色，A 通道未使用 RT1：ARGB，RGB 通道存储高光反射颜色，A 通道存储高光反射的指数部分（Gloss） RT2：ARGB，RGB 通道存储法线，A 通道未使用 RT3：ARGB，存储自发光+lightmap+反射探针 深度缓冲和模板缓冲 光源类型 常用的光源属性有光源的位置，方向，颜色，强度，衰减。 平行光 没有位置，只有方向，不会衰减。 点光源 球形，球心处光照强度最强，球体边界处最弱，衰减值可以由一个函数定义。 聚光灯 锥形 面光源 " }, { "title": "shader案例-LOGO 闪光", "url": "/posts/shader16/", "categories": "unity", "tags": "shader", "date": "2020-04-30 11:36:00 +0800", "content": "LOGO 闪光 //Logo 闪光shader Shader \"Practice/FlashTestMat\" { Properties { _MainTex (\"Texture\", 2D) = \"white\" {} //间隔 _Interval(\"Interval\",float) = 5.0 _BrightNess(\"BrightNess\",float)=10000000 _BrightWidth(\"BrightWidth\",Range(0,0.5))=0.1 } SubShader { // No culling or depth Cull Off ZWrite Off // Blend SrcAlpha OneMinusSrcAlpha Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" sampler2D _MainTex; float4 _MainTex_ST; float _Interval; float _BrightNess; float _BrightWidth; struct appdata { float4 vertex : POSITION; float4 texcoord : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; }; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; return o; } //闪光 //可以在这里丰富闪光的形状，其他逻辑等 fixed4 blinn(float2 uv) { //当前时间段 fixed delta = fmod(_Time.y,_Interval); float dis =saturate(_BrightWidth- abs(uv.x+0.5-delta)); float cur_brightness=_BrightNess*dis; fixed3 rgb = fixed3(1,1,1)*cur_brightness; return fixed4(rgb,1); } fixed4 frag (v2f i) : SV_Target { fixed4 col = tex2D(_MainTex, i.uv); //透明不闪光 clip(col.a-0.1); fixed4 brighness = blinn(i.uv); col = col+brighness; return col; } ENDCG } } Fallback \"UI/Default\" } 增加调试参数 为了策划方便调试，这里丰富下 shader 的参数，让光柱进行一定的偏移，给定闪光频率。 //Logo 闪光shader Shader \"Practice/FlashTestMat\" { Properties { _MainTex (\"Texture\", 2D) = \"white\" {} //冷却 _Cold(\"Cold\",Range(0,3.0)) = 1.0 //完成闪烁时间 _FinishTime(\"FinishTime\",Range(1.0,4.0))=2.0 //光亮度 _BrightNess(\"BrightNess\",float)=100 //光柱宽度 _BrightWidth(\"BrightWidth\",Range(0,0.5))=0.1 //偏移速率 _Rad(\"Rad\",Range(0,3.14))=1.0 //偏移弧度 } SubShader { // No culling or depth Cull Off ZWrite Off // Blend SrcAlpha OneMinusSrcAlpha Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" sampler2D _MainTex; float4 _MainTex_ST; float _FinishTime; float _BrightNess; float _BrightWidth; float _Rad; float _Cold; struct appdata { float4 vertex : POSITION; float4 texcoord : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; }; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; return o; } //闪光 fixed4 blinn(float2 uv) { //当前时间段 fixed delta = _Time.y/(_FinishTime+_Cold); delta =delta - floor(delta); delta = delta*(_FinishTime+_Cold)/_FinishTime; //根据y轴做一定的偏移s fixed _offset_x=uv.y*tan(_Rad); float dis =saturate(_BrightWidth- abs(uv.x+0.5+_offset_x-delta)); float cur_brightness=_BrightNess*dis; fixed3 rgb = fixed3(1,1,1)*cur_brightness; return fixed4(rgb,1); } fixed4 frag (v2f i) : SV_Target { fixed4 col = tex2D(_MainTex, i.uv); //透明不闪光 clip(col.a-0.1); fixed4 brighness = blinn(i.uv); col = col+brighness; return col; } ENDCG } } Fallback \"UI/Default\" } " }, { "title": "shader入门基础-透明效果四", "url": "/posts/shader15/", "categories": "unity", "tags": "shader", "date": "2020-04-30 10:36:00 +0800", "content": "开启深度写入的透明效果 由于关闭深度写入可能造成错误排序 解决方案:使用两个 pass 来渲染模型 第一个 pass 开启深度写入，但不输出颜色，目的仅仅是把该模型深度值写入到深度缓冲中。 第二个 pass 进行正常的透明度混合，由于上一个 pass 已经得到了逐像素的正确深度信息，该 pass 就可以额按照像素级别 的深度排序结果进行透明渲染。 缺点：多使用一个 pass 会对性能造成一定的影响。 ColorMask: ColorMask RGB |A|0| 其他任何 R,G,B,A 的组合，ColorMask 会指定渲染结果的输出通道，而不是通常的 RGBA 四个通道都被写入。 可选参数为 RGBA 的任意组合以及 0，参数为 0 时，那么不会写入任何通道，但是会做一次深度测试，并将深度值写入深度缓冲区。这就是我们这个 pass 需要的，先做一次深度写入 Shader \"Practice/AlphaBlendZWrite\" { Properties { _MainTex (\"Texture\", 2D) = \"white\" {} _Color(\"Color Tint\",Color) = (1,1,1,1) _AlphaScale(\"Alpha Cutoff\",Range(0,1))=0.5 } SubShader { //RenderType 可以让unity把这个shader提前归入到“Transparent”组中 //\"IgnoreProjector\"=\"True\" 不受投影器影响 //透明度混合使用的是 渲染序列是Transparent Tags { \"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"Transparent\" } Pass { ZWrite On // ColorMask 0 的时候不输出任何颜色通道，只会做一次深度测试，并写入到深度缓存中 ColorMask 0 } Pass { //LightModel 是 pass标签的一种，正确定义LightModel 才能正确得到unity的内置光照变量 Tags {\"LightModel\"=\"ForwardBase\"} //关闭深度写入 ZWrite Off //开启混合，等价于下列公式 // O_rgb= srcAlpha*S_rgb+(1-srcAlpha)*D_rgb //O_a=srcAlpha*S_a+(1-srcAlpha)*D_a //这里可以合并rgb 和a，标量和矢量相乘 //O_rgba = srcAlpha*S_rgba+(1-srcAlpha)*D_rgba Blend srcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" //包含内置变量的 _LightColor0 #include \"Lighting.cginc\" //C_diffuse = (C_light·m_diffuse)max(0,N·L) //漫反射计算公式 //都在unity 世界坐标计算，需要知道顶点在世界的位置，顶点法线，顶点视角位置 struct appdata { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord :TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD1; float4 pos : SV_POSITION; float3 worldNormal:NORMAL; float3 worldPos:TEXCOORD2; }; sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; fixed _AlphaScale; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); //把顶点坐标转换到世界坐标，为后续取 L做准备 o.worldPos = mul(unity_ObjectToWorld,v.vertex); //把法线转换到 世界空间中 o.worldNormal = UnityObjectToWorldNormal(v.normal); //纹理映射坐标，该顶点在纹理中对应的2D坐标 o.uv=v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; return o; } fixed4 frag (v2f i) : SV_Target { //逐像素 光照 //C_diffuse = (C_light·m_diffuse)max(0,N·L) //获取公式中的各个变量，m_diffuse =此时材质面板给定的_Color*顶点的color fixed4 col; fixed4 texColor = tex2D(_MainTex,i.uv); fixed3 N = normalize(i.worldNormal); //UnityWorldSpaceLightDir输入世界空间中的坐标点，WorldSpaceLightDir 输入模型空间中的坐标顶点 fixed3 L = normalize(UnityWorldSpaceLightDir(i.worldPos)); //clip(texColor.a-_AlphaScale); //equal to //if(m_diffuse.a-_AlphaScale)&lt;0{ //discard; //} //计算漫反射部分 fixed3 c_light = _LightColor0.rgb; fixed3 m_diffuse =texColor.rgb*_Color.rgb; fixed3 c_diffuse = c_light*m_diffuse*max(0,dot(N,L)); //计算环境光产生的影响,环境光反射的也会受材质本身颜色影响 fixed3 ambient = m_diffuse*UNITY_LIGHTMODEL_AMBIENT.rgb; //环境光和漫反射光 //只有使用Blend命令打开混合后，我们在这里设置透明通道才有意义，否则 //这些透明度不会对片元透明效果有任何影响。 col = fixed4(ambient+c_diffuse,texColor.a*_AlphaScale); return col; } ENDCG } } Fallback \"Transparent/VertexLit\" } 两个 pass，解决排序后的效果图 双面渲染的透明效果 Culll Cull Back|Front|Off 可以声依永 Cull 指令来控制需要剔除哪个面的渲染图元，默认设置为 Back ，那么那些背对着摄像机的渲染图元就不会被渲染， 设置 Front，朝向摄像机的渲染图元不会被渲染，设置 off 会关闭剔除功能，所有图元都会被渲染，这时需要渲染的图元数目会成倍增加，因此除非是用于特殊效果 ，例如这里的双面渲染的透明效果，通常情况下课不会关闭剔除功能。 透明度测试的双面渲染 只需要在 Pass 的渲染设置中使用 Cull 指令来关闭剔除即可。 Pass { Tags{\"LightModel\"=\"ForwardBase\"} Cull Off } 透明度混合的双面渲染 由于透明度混合会关闭深度写入，想要得到正确的透明效果，渲染顺序是非常重要的，我们需要保证图元从后往前渲染。为此我们选择把 双面渲染的工作分成两个 pass，第一个 Pass 只渲染背面，第二个 Pass 只渲染正面，Unity 会顺序执行 SubShader 中的各个 Pass，因此背面总是在正面之前渲染。 这里偷懒了，直接在原来的 shader 中复制，粘贴 Shader \"Practice/AlphaBlendZWrite\" { Properties { _MainTex (\"Texture\", 2D) = \"white\" {} _Color(\"Color Tint\",Color) = (1,1,1,1) _AlphaScale(\"Alpha Cutoff\",Range(0,1))=0.5 } SubShader { //RenderType 可以让unity把这个shader提前归入到“Transparent”组中 //\"IgnoreProjector\"=\"True\" 不受投影器影响 //透明度混合使用的是 渲染序列是Transparent Tags { \"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"Transparent\" } Pass { //LightModel 是 pass标签的一种，正确定义LightModel 才能正确得到unity的内置光照变量 Tags {\"LightModel\"=\"ForwardBase\"} //第一个Pass只渲染背面，剔除前面 Cull Front //关闭深度写入 ZWrite Off //开启混合，等价于下列公式 // O_rgb= srcAlpha*S_rgb+(1-srcAlpha)*D_rgb //O_a=srcAlpha*S_a+(1-srcAlpha)*D_a //这里可以合并rgb 和a，标量和矢量相乘 //O_rgba = srcAlpha*S_rgba+(1-srcAlpha)*D_rgba Blend srcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" //包含内置变量的 _LightColor0 #include \"Lighting.cginc\" //C_diffuse = (C_light·m_diffuse)max(0,N·L) //漫反射计算公式 //都在unity 世界坐标计算，需要知道顶点在世界的位置，顶点法线，顶点视角位置 struct appdata { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord :TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD1; float4 pos : SV_POSITION; float3 worldNormal:NORMAL; float3 worldPos:TEXCOORD2; }; sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; fixed _AlphaScale; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); //把顶点坐标转换到世界坐标，为后续取 L做准备 o.worldPos = mul(unity_ObjectToWorld,v.vertex); //把法线转换到 世界空间中 o.worldNormal = UnityObjectToWorldNormal(v.normal); //纹理映射坐标，该顶点在纹理中对应的2D坐标 o.uv=v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; return o; } fixed4 frag (v2f i) : SV_Target { //逐像素 光照 //C_diffuse = (C_light·m_diffuse)max(0,N·L) //获取公式中的各个变量，m_diffuse =此时材质面板给定的_Color*顶点的color fixed4 col; fixed4 texColor = tex2D(_MainTex,i.uv); fixed3 N = normalize(i.worldNormal); //UnityWorldSpaceLightDir输入世界空间中的坐标点，WorldSpaceLightDir 输入模型空间中的坐标顶点 fixed3 L = normalize(UnityWorldSpaceLightDir(i.worldPos)); //clip(texColor.a-_AlphaScale); //equal to //if(m_diffuse.a-_AlphaScale)&lt;0{ //discard; //} //计算漫反射部分 fixed3 c_light = _LightColor0.rgb; fixed3 m_diffuse =texColor.rgb*_Color.rgb; fixed3 c_diffuse = c_light*m_diffuse*max(0,dot(N,L)); //计算环境光产生的影响,环境光反射的也会受材质本身颜色影响 fixed3 ambient = m_diffuse*UNITY_LIGHTMODEL_AMBIENT.rgb; //环境光和漫反射光 //只有使用Blend命令打开混合后，我们在这里设置透明通道才有意义，否则 //这些透明度不会对片元透明效果有任何影响。 col = fixed4(ambient+c_diffuse,texColor.a*_AlphaScale); return col; } ENDCG } Pass { //LightModel 是 pass标签的一种，正确定义LightModel 才能正确得到unity的内置光照变量 Tags {\"LightModel\"=\"ForwardBase\"} //第二个Pass只渲染前面，剔除背面 Cull Back //关闭深度写入 ZWrite Off //开启混合，等价于下列公式 // O_rgb= srcAlpha*S_rgb+(1-srcAlpha)*D_rgb //O_a=srcAlpha*S_a+(1-srcAlpha)*D_a //这里可以合并rgb 和a，标量和矢量相乘 //O_rgba = srcAlpha*S_rgba+(1-srcAlpha)*D_rgba Blend srcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" //包含内置变量的 _LightColor0 #include \"Lighting.cginc\" //C_diffuse = (C_light·m_diffuse)max(0,N·L) //漫反射计算公式 //都在unity 世界坐标计算，需要知道顶点在世界的位置，顶点法线，顶点视角位置 struct appdata { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord :TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD1; float4 pos : SV_POSITION; float3 worldNormal:NORMAL; float3 worldPos:TEXCOORD2; }; sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; fixed _AlphaScale; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); //把顶点坐标转换到世界坐标，为后续取 L做准备 o.worldPos = mul(unity_ObjectToWorld,v.vertex); //把法线转换到 世界空间中 o.worldNormal = UnityObjectToWorldNormal(v.normal); //纹理映射坐标，该顶点在纹理中对应的2D坐标 o.uv=v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; return o; } fixed4 frag (v2f i) : SV_Target { //逐像素 光照 //C_diffuse = (C_light·m_diffuse)max(0,N·L) //获取公式中的各个变量，m_diffuse =此时材质面板给定的_Color*顶点的color fixed4 col; fixed4 texColor = tex2D(_MainTex,i.uv); fixed3 N = normalize(i.worldNormal); //UnityWorldSpaceLightDir输入世界空间中的坐标点，WorldSpaceLightDir 输入模型空间中的坐标顶点 fixed3 L = normalize(UnityWorldSpaceLightDir(i.worldPos)); //clip(texColor.a-_AlphaScale); //equal to //if(m_diffuse.a-_AlphaScale)&lt;0{ //discard; //} //计算漫反射部分 fixed3 c_light = _LightColor0.rgb; fixed3 m_diffuse =texColor.rgb*_Color.rgb; fixed3 c_diffuse = c_light*m_diffuse*max(0,dot(N,L)); //计算环境光产生的影响,环境光反射的也会受材质本身颜色影响 fixed3 ambient = m_diffuse*UNITY_LIGHTMODEL_AMBIENT.rgb; //环境光和漫反射光 //只有使用Blend命令打开混合后，我们在这里设置透明通道才有意义，否则 //这些透明度不会对片元透明效果有任何影响。 col = fixed4(ambient+c_diffuse,texColor.a*_AlphaScale); return col; } ENDCG } } Fallback \"Transparent/VertexLit\" } " }, { "title": "shader入门基础-透明效果三", "url": "/posts/shader14/", "categories": "unity", "tags": "shader", "date": "2020-04-29 14:36:00 +0800", "content": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解 透明度混合 这种方法可以得到真正的半透明效果，它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色进行混合，得到新的颜色。 但是透明度混合需要关闭深度写入，这使得我们要非常小心物体的渲染顺序。 混合就和两个操作数有关 源颜色(source color), 目标颜色(destination color)。源颜色 用 S 表示，指由片元着色器产生的颜色值； 目标颜色 D,指的从颜色缓冲中读取到的颜色值。对他们进行混合后得到的输出颜色，用 O表示，它会重新写入到颜色缓冲中。 当我们使用 Blend 命令时，混合会自动开启。 shaderLab 中设置混合因子的命令 命令 描述 Blend SrcFactor DstFactor \\(\\mathtt O_{rgb}=SrcFatcor*\\mathtt S_{rgb}+DstFactor*\\mathtt D_{rgb})\\) Blend SrcFactor DstFactor,SrcFactorA DstFactorA \\(\\mathtt O_{rgb}=SrcFatcor*\\mathtt S_{rgb}+DstFactor*\\mathtt D_{rgb})\\quad \\mathtt O_a = SrcFactorA* \\mathtt S_a+DstFactorA*\\mathtt D_a\\) 透明度混合实践 Shader \"Practice/AlphaBlend\" { Properties { _MainTex (\"Texture\", 2D) = \"white\" {} _Color(\"Color Tint\",Color) = (1,1,1,1) _AlphaScale(\"Alpha Cutoff\",Range(0,1))=0.5 } SubShader { //RenderType 可以让unity把这个shader提前归入到“Transparent”组中 //\"IgnoreProjector\"=\"True\" 不受投影器影响 //透明度混合使用的是 渲染序列是Transparent Tags { \"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"Transparent\" } Pass { //LightModel 是 pass标签的一种，正确定义LightModel 才能正确得到unity的内置光照变量 Tags {\"LightModel\"=\"ForwardBase\"} //关闭深度写入 ZWrite Off //开启混合，等价于下列公式 // O_rgb= srcAlpha*S_rgb+(1-srcAlpha)*D_rgb //O_a=srcAlpha*S_a+(1-srcAlpha)*D_a //这里可以合并rgb 和a，标量和矢量相乘 //O_rgba = srcAlpha*S_rgba+(1-srcAlpha)*D_rgba Blend srcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" //包含内置变量的 _LightColor0 #include \"Lighting.cginc\" //C_diffuse = (C_light·m_diffuse)max(0,N·L) //漫反射计算公式 //都在unity 世界坐标计算，需要知道顶点在世界的位置，顶点法线，顶点视角位置 struct appdata { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord :TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD1; float4 pos : SV_POSITION; float3 worldNormal:NORMAL; float3 worldPos:TEXCOORD2; }; sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; fixed _AlphaScale; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); //把顶点坐标转换到世界坐标，为后续取 L做准备 o.worldPos = mul(unity_ObjectToWorld,v.vertex); //把法线转换到 世界空间中 o.worldNormal = UnityObjectToWorldNormal(v.normal); //纹理映射坐标，该顶点在纹理中对应的2D坐标 o.uv=v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; return o; } fixed4 frag (v2f i) : SV_Target { //逐像素 光照 //C_diffuse = (C_light·m_diffuse)max(0,N·L) //获取公式中的各个变量，m_diffuse =此时材质面板给定的_Color*顶点的color fixed4 col; fixed4 texColor = tex2D(_MainTex,i.uv); fixed3 N = normalize(i.worldNormal); //UnityWorldSpaceLightDir输入世界空间中的坐标点，WorldSpaceLightDir 输入模型空间中的坐标顶点 fixed3 L = normalize(UnityWorldSpaceLightDir(i.worldPos)); //clip(texColor.a-_AlphaScale); //equal to //if(m_diffuse.a-_AlphaScale)&lt;0{ //discard; //} //计算漫反射部分 fixed3 c_light = _LightColor0.rgb; fixed3 m_diffuse =texColor.rgb*_Color.rgb; fixed3 c_diffuse = c_light*m_diffuse*max(0,dot(N,L)); //计算环境光产生的影响,环境光反射的也会受材质本身颜色影响 fixed3 ambient = m_diffuse*UNITY_LIGHTMODEL_AMBIENT.rgb; //环境光和漫反射光 //只有使用Blend命令打开混合后，我们在这里设置透明通道才有意义，否则 //这些透明度不会对片元透明效果有任何影响。 col = fixed4(ambient+c_diffuse,texColor.a*_AlphaScale); return col; } ENDCG } } } 效果如图 //Blend srcAlpha OneMinusSrcAlpha 屏蔽 Blend 命令，可以发现半透明效果消失了。只有使用 Blend 命令打开混合后，这里透明度才会对片元透明效果有任何影响。 " }, { "title": "shader入门基础-透明效果二", "url": "/posts/shader13/", "categories": "unity", "tags": "shader", "date": "2020-04-29 11:36:00 +0800", "content": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解 clip 函数 在片原着色器中使用 clip 函数进行透明度测试，clip 参数可以是标量，也可以是矢量。如果给定的参数的任何一个分量是负数，就会舍弃当前 像素输出的颜色。discard 指令显示剔除片元。 void clip(float 4) { if (any(x&lt;0)) discard; } 透明度测试实践 Shader \"Practice/AlphaTest\" { Properties { _MainTex (\"Texture\", 2D) = \"white\" {} _Color(\"Color Tint\",Color) = (1,1,1,1) _Cutoff(\"Alpha Cutoff\",Range(0,1))=0.5 } SubShader { //RenderType 可以让unity把这个shader归入到提“TransparentCutout” //\"IgnoreProjector\"=\"True\" 不受投影器影响 //渲染序列设置为 AlphaTest Tags { \"Queue\"=\"AlphaTest\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"TransparentCutout\" } Pass { //LightModel 是 pass标签的一种，正确定义LightModel 才能正确得到unity的内置光照变量 Tags {\"LightModel\"=\"ForwardBase\"} CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" //包含内置变量的 _LightColor0 #include \"Lighting.cginc\" //C_diffuse = (C_light·m_diffuse)max(0,N·L) //漫反射计算公式 //都在unity 世界坐标计算，需要知道顶点在世界的位置，顶点法线，顶点视角位置 struct appdata { float4 vertex : POSITION; float3 normal : NORMAL; float4 texcoord :TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD1; float4 pos : SV_POSITION; float3 worldNormal:NORMAL; float3 worldPos:TEXCOORD2; }; sampler2D _MainTex; float4 _MainTex_ST; fixed4 _Color; fixed _Cutoff; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); //把顶点坐标转换到世界坐标，为后续取 L做准备 o.worldPos = mul(unity_ObjectToWorld,v.vertex); //把法线转换到 世界空间中 o.worldNormal = UnityObjectToWorldNormal(v.normal); //纹理映射坐标，该顶点在纹理中对应的2D坐标 o.uv=v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; return o; } fixed4 frag (v2f i) : SV_Target { //逐像素 光照 //C_diffuse = (C_light·m_diffuse)max(0,N·L) //获取公式中的各个变量，m_diffuse =此时材质面板给定的_Color*顶点的color fixed4 col; fixed4 texColor = tex2D(_MainTex,i.uv); fixed3 N = normalize(i.worldNormal); //UnityWorldSpaceLightDir输入世界空间中的坐标点，WorldSpaceLightDir 输入模型空间中的坐标顶点 fixed3 L = normalize(UnityWorldSpaceLightDir(i.worldPos)); clip(texColor.a-_Cutoff); //equal to //if(m_diffuse.a-_Cutoff)&lt;0{ //discard; //} //计算漫反射部分 fixed3 c_light = _LightColor0.rgb; fixed3 m_diffuse =texColor.rgb*_Color.rgb; fixed3 c_diffuse = c_light*m_diffuse*max(0,dot(N,L)); //计算环境光产生的影响,环境光反射的也会受材质本身颜色影响 fixed3 ambient = m_diffuse*UNITY_LIGHTMODEL_AMBIENT.rgb; //环境光和漫反射光 col = fixed4(ambient+c_diffuse,1.0); return col; } ENDCG } } } 效果图 " }, { "title": "shader入门基础-透明效果一", "url": "/posts/shader12/", "categories": "unity", "tags": "shader", "date": "2020-04-28 17:36:00 +0800", "content": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解 透明度测试(Alpha Test) 当片元的透明度小于某个阈值时，对应片元就会被舍弃，被舍弃的片元不会再进行任何处理，不会对颜色缓冲产生任何影响，当片元透明度大于等于这个阈值的 时候，就会按照普通不透明的物体处理方式来处理，进行深度测试，深度写入等。透明度测试无法得到真正的半透明效果。 透明度混合(Alpha Blend) 使用当前片元的透明度作为混合银子，与已经存储在颜色缓冲中的颜色进行混合，得到新的颜色。但是透明度混合需要关闭深度写入，关闭深度写入破坏了深度 缓冲的工作机制，因此渲染渲染顺序将会变得非常重要。透明度混合只关闭了深度写入，没有关闭深度测试，当使用透明度混合渲染一个片元时，还是会比较 它的深度值与当前缓冲中的深度值，如果它的深度值距离摄像机更远，那么就不会再进行混合操作。对于透明度混合来说，深度缓冲时只读的。 深度缓冲(depth buffer,z-buffer) 深度缓冲记录颜色缓冲区中相对应像素点在 3D 世界中距离摄像机的远近，通过深度缓冲，我们可以进行深度测试，从而确定遮挡关系。有了深度缓冲后，渲染顺序 就不那么重要了，可以根据深度渲染物体。上面提及的透明度混合的时候会关闭深度写入，因此关闭深度写入时，渲染顺序会确定物体渲染的先后顺序，关闭后， 渲染顺序会变得非常重要。 深度测试(ZTest) 深度写入(ZWrite) 如果开启了看深度测试，GPU 会把该片元的深度值和已经存在于深度缓冲区中的深度值进行比较。如果该片元通过了深度测试，开发者可以指定是否用这个片元 的深度值覆盖掉原有的深度值，这个是通过开启/关闭深度写入来做到。 这里回顾之前渲染流水线的知识，可以加深理解，这部分的操作都在渲染流水线的逐片元操作中。通过流程图可以理解，这部分的工作流程和再流水线中的作用。 逐片元在流水线最后，这里会合并输出。 逐片元操作 深度写入和深度测试工作流程图 混合流程工作流程图 渲染顺序的排序 渲染引擎一般会对物体进行顺序。 先渲染所有不透明物体，并开启它们的深度测试和深度写入。 把半透明物体按它们距离摄像机的远近进行排序，然后按照从后往前的顺序渲染这些半透明物体，并开启它们的深度测试，但关闭深度写入。 渲染队列 Unity 为了解决渲染顺序问提供了渲染队列（render queue），用 SubShader 的 Queue 标签决定我们模型将归于哪个渲染队列。 透明度测试 SubShader{ \tTags{\"Queue\"=\"AlphaTest\"} \tPass{ \t} } 透明度混合 SubShader{ \tTags{\"Queue\"=\"Transparent\"} \tPass{ \t\tZwrite Off \t} } " }, { "title": "shader入门基础-渐变纹理，遮罩纹理", "url": "/posts/shader11/", "categories": "unity", "tags": "shader", "date": "2020-04-27 17:36:00 +0800", "content": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解 渐变纹理 学习如何使用渐变纹理来控制漫反射光照。 Shader \"Practice/RampTex\" { Properties { _RampTex (\"Texture\", 2D) = \"white\" {} _Color(\"Color Tint\",Color) =(1,1,1,1) _Specular (\"Specular\", Color) = (1, 1, 1, 1) \t\t_Gloss (\"Gloss\", Range(8.0, 256)) = 20 } SubShader { Tags { \"LightModel\"=\"Forward\" } Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" fixed4 _Color; \t\t\tsampler2D _RampTex; \t\t\tfloat4 _RampTex_ST; \t\t\tfixed4 _Specular; \t\t\tfloat _Gloss; \t\t\tstruct a2v { \t\t\t\tfloat4 vertex : POSITION; \t\t\t\tfloat3 normal : NORMAL; \t\t\t\tfloat4 texcoord : TEXCOORD0; \t\t\t}; \t\t\tstruct v2f { \t\t\t\tfloat4 pos : SV_POSITION; \t\t\t\tfloat3 worldNormal : TEXCOORD0; \t\t\t\tfloat3 worldPos : TEXCOORD1; \t\t\t\tfloat2 uv : TEXCOORD2; \t\t\t}; \t\t\tv2f vert(a2v v) { \t\t\t\tv2f o; \t\t\t\to.pos = UnityObjectToClipPos(v.vertex); \t\t\t\to.worldNormal = UnityObjectToWorldNormal(v.normal); //把法线方向从模型空间转换到世界空间中 \t\t\t\to.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;//把顶点坐标从模型空间转换到世界空间中 \t\t\t\to.uv = TRANSFORM_TEX(v.texcoord, _RampTex);//把材质纹理映射到uv坐标上 \t\t\t\treturn o; \t\t\t} \t\t\tfixed4 frag(v2f i) : SV_Target { \t\t\t\tfixed3 worldNormal = normalize(i.worldNormal); \t\t\t\tfixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); \t\t\t\tfixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; //使用halfLambert 构建一个一维纹理坐标，并用这个纹理坐标对渐变纹理_RampTex进行采样 //因为_RampTex实际就是一个一维纹理，它在纵轴方向上颜色不变，因此u,v都采用了halfLambert \t\t\t\tfixed halfLambert = 0.5 * dot(worldNormal, worldLightDir) + 0.5; \t\t\t\tfixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb; \t\t\t\tfixed3 diffuse = _LightColor0.rgb * diffuseColor; \t\t\t\tfixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos)); \t\t\t\tfixed3 halfDir = normalize(worldLightDir + viewDir); \t\t\t\tfixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); \t\t\t\treturn fixed4(ambient + diffuse + specular, 1.0); \t\t\t} \t\t\tENDCG \t\t} \t} \tFallBack \"Specular\" } 遮罩纹理 遮罩允许我们可以保护某些区域，使他们免于某些修改。 使用遮罩纹理流程一般是：通过采样得到遮罩纹理的纹素值，然后使用其中某个通道的值来与某种表面属性进行相乘，这样，当该通道 值为 0 时，可以保护表面不收该属性的影响。使用遮罩纹理可以让美术人员可以更加精准的控制模型表面的各种性质。 Shader \"Practice/MaskTex\" { Properties{ _Color(\"Color Tint\",Color)=(1,1,1,1) _MainTex(\"MainTex\",2D)=\"white\"{} _BumpMap(\"BumpMap\",2D)=\"bump\"{} //法线贴图 _BumpScale(\"Bump Scale\",float)=1 //高光反射遮罩纹理 _SpecularMask(\"Specular Mask\",2D)=\"white\" {} //遮罩影响程度 _SpecularScale (\"Specular Scale\",float)=1.0 //高光颜色 _Specular(\"Specular\",Color)=(1,1,1,1) //光泽度，光点大小 _Gloss(\"Gloss\",float)=1.0 } SubShader{ Pass{ //前向渲染 Tags {\"LightModel\" = \"ForwardBase\"} CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" //对应Properties 类型和名字匹配的变量 fixed4 _Color; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _BumpMap; float4 _BumpMap_ST; float _BumpScale; sampler2D _SpecularMask; float4 _SpecularMask_ST; float _SpecularScale; fixed4 _Specular; float _Gloss; struct a2v { float4 vertex:POSITION; //法线向量是float3 float3 normal:NORMAL; //切线由于需要w分量确定副切线方向，所以切线虽然是向量，但是也需要用float4 float4 tangent:TANGENT; //模型第一组纹理坐标 float4 texcoord:TEXCOORD0; }; struct v2f { float4 uv:TEXCOORD0; //视角方向 float3 viewDir:TEXCOORD1; //光照方向 float3 lightDir:TEXCOORD2; //顶点 float4 pos:SV_POSITION; }; v2f vert(a2v v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); o.uv.xy= v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; TANGENT_SPACE_ROTATION; //获取到光照方向，转换到切线坐标空间 o.lightDir =mul(rotation,ObjSpaceLightDir(v.vertex)).xyz; //获取到视角方向，从模型空间转换到切线空间 o.viewDir = mul(rotation,ObjSpaceViewDir(v.vertex)).xyz; return o; } fixed4 frag(v2f i):SV_TARGET { fixed3 tangentLightDir = normalize(i.lightDir); fixed3 tangentViewDir = normalize(i.viewDir); //像素反映射到法线 fixed3 tangentNormal =UnpackNormal(tex2D(_BumpMap,i.uv)); // tangentNormal.xy*=_BumpScale; tangentNormal.z = sqrt(1.0-saturate(dot(tangentNormal.xy,tangentNormal.xy))); fixed3 albedo =tex2D(_MainTex,i.uv).rgb*_Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz*albedo; fixed3 diffuse = _LightColor0.rgb*albedo*max(0,dot(tangentNormal,tangentLightDir)); fixed3 halfDir = normalize(tangentLightDir+tangentViewDir); fixed specularMask = tex2D(_SpecularMask,i.uv).r*_SpecularScale; fixed3 specular = _LightColor0.rgb*_Specular.rgb*pow(max(0,dot(tangentNormal,halfDir)),_Gloss)*specularMask; return fixed4(ambient+diffuse+specular,1.0); } ENDCG } } } 有遮罩 无高光遮罩 这里我们使用 r 分量计算掩码之，用得到的掩码值和_SpecularScale 相乘，r=0 的地方将不会受高光影响。 " }, { "title": "shader入门基础-凹凸映射", "url": "/posts/shader10/", "categories": "unity", "tags": "shader", "date": "2020-04-27 15:36:00 +0800", "content": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解 凹凸映射 使用一张纹理来修改模型表面的法线，为模型提供更多细节。 使用法线纹理进行凹凸映射 法线方向的分量范围在[-1,1],像素分量范围为[0,1],法线到像素的映射 $pixel = \\frac{normal+1}{2}$. 我们在 shader 中对法线纹理采样后，需要进行反映射 $normal=pixel\\ast 2-1$。 模型空间的法线纹理(object-space normal map) 定义：模型空间中的表面法线存储在一张纹理中。 优点： 实现简单，直观。 纹理坐标缝合处和尖锐的边角部分，课件突变较少，可以提供平滑的边界。 切线空间的法线纹理(tangent-space normal map) 定义: 模型定点的切线空间来存储法线，对于模型的每个定点，它都有一个属于自己的切线空间，这个切线空间的原点就是该顶点本身， 而 z 轴是顶点的法线方向（n）,x 轴是顶点的切线方向（t）,而 y 轴可由法线和切线叉积而得，也被称为副切线。 优点: 自由度高。模型空间下的法线纹理记录的是绝对法线信息，仅可用于创建它时的那个模型。切线空间下的纹理记录的是相对法线信息， 意味着，把纹理应用到完全不同的网格上，也可以得到合理结果。 可进行 UV 动画。我们可以移动一个纹理的 UV 坐标来实现凹凸移动的效果，但使用模型空间下的法线纹理得到完全错误的结果。这种 UV 动画在水 或者火山熔岩。 可以重用法线纹理。 可压缩。 在切线空间下计算光照模型 实现：在片元着色器中通过纹理采样得到切线空间的法线，然后在于切线空间下的视角方向，光照方向等进行计算。 需要在顶点着色器中把视角方向，光照方向从来模型空间变换到切线空间中。即我们需要知道的从模型空间到切线空间的变换 矩阵。这个变换矩阵的逆矩阵，在顶点着色器中按切线（x 轴），副切线（y 轴），法线（z 轴）的顺序按列排列。在 UnityCG.cginc 中 定义了 TANGENT_SPACE_ROTATION 实现 _BumpMap,使用”bump”作为它的默认值。”bump”是 Unity 内置法线纹理，当没有提供任何法线纹理时，bump 对应模型自带法线信息。 _BmupScale 控制凹凸程度，0 则意味该法线纹理不会对光照产生任何影响。 tangent.w 分量决定切线空间中的第三个坐标轴-副切线的方向性。 法线纹理中存储的是把法线经过映射后得到的像素值，因此需要把他们反映射出来。 Shader \"Practice/NormalMapTagSpace\" { Properties { _Color(\"Color Tint\",Color) = (1,1,1,1)// 漫反射颜色 _MainTex (\"Main Tex\", 2D) = \"white\" {}//贴图 _BumpMap(\"Bump Map\",2D) = \"bump\" {}//法线贴图 _BumpScale(\"Bump Scale\",float) = 1.0//凹凸程度 _Specular(\"Specular\",Color)= (1,1,1,1)//高光颜色 _Gloss(\"Gloss\",Range(8,256)) = 20 //光泽度 } SubShader { Pass{ Tags { \"LightModel\" = \"ForwardBase\" } CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"Lighting.cginc\" fixed4 _Color; sampler2D _MainTex; sampler2D _BumpMap;//法线纹理 float4 _MainTex_ST; float4 _BumpMap_ST;//法线纹理属性 fixed4 _Specular; float _Gloss; float _BumpScale;//凹凸程度 struct a2v{ float4 vertex:POSITION; //模型顶点信息 float3 normal:NORMAL;//法线 float4 tangent:TANGENT;//切线 float4 texcoord:TEXCOORD0;//纹理 }; struct v2f { float4 pos:SV_POSITION; float4 uv:TEXCOORD0;//纹理映射坐标 float3 lightDir:TEXCOORD1;//光线 float3 viewDir:TEXCOORD2;//视线 }; v2f vert(a2v i){ v2f o; o.pos = UnityObjectToClipPos(i.vertex); //减少插值寄存器的 xy存储_MainTex的纹理坐标 ，zw存储_BumpMap坐标 o.uv.xy =i.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw; o.uv.zw = i.texcoord.xy*_BumpMap_ST.xy+_BumpMap_ST.zw; //计算副切线 float3 binormal = cross(normalize(i.normal),normalize(i.tangent.xyz))*i.tangent.w; float3x3 rotation = float3x3(i.tangent.xyz,binormal,i.normal); //获取到顶点坐标的光线防线后，把光线方向从模型空间转换到切线空间 o.lightDir = mul(rotation,ObjSpaceLightDir(i.vertex)).xyz; o.lightDir = mul(rotation,ObjSpaceViewDir(i.vertex)).xyz; return o; } fixed4 frag(v2f i):SV_TARGET { fixed3 tangentLightDir = normalize(i.lightDir); fixed3 tangentViewDir = normalize(i.viewDir); fixed4 packedNormal = tex2D(_BumpMap,i.uv.zw); fixed3 tangentNormal; tangentNormal = UnpackNormal(packedNormal); tangentNormal.xy *= _BumpScale; tangentNormal.z = sqrt(1.0-saturate(dot(tangentNormal,tangentViewDir))); fixed3 albedo = tex2D(_MainTex,i.uv).rgb*_Color.rgb; fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz*albedo; fixed3 diffuse = _LightColor0.rgb*albedo*max(0,dot(tangentNormal,tangentLightDir)); fixed3 halfDir = normalize(tangentLightDir+tangentViewDir); fixed3 specular = _LightColor0.rgb*_Specular.rgb*pow(max(0,dot(tangentNormal,halfDir)),_Gloss); return fixed4(ambient+diffuse+specular,1.0); } ENDCG } } Fallback \"Diffuse\" } 切线空间下计算的 凹凸映射 " }, { "title": "shader入门基础-基础纹理", "url": "/posts/shader9/", "categories": "unity", "tags": "shader", "date": "2020-04-27 14:10:00 +0800", "content": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解 光照模型实践,使用单张纹理代替漫反射颜色 高光公式 \\[\\mathtt{c}_{specular}=(\\mathtt{c}_{light}\\cdot\\mathtt{m}_{specular})max(0,\\vec n\\cdot\\vec h)^{m_{gloss}} \\qquad \\vec h=\\frac{\\vec v+\\vec l}{|\\vec v+\\vec l|}\\] 漫反射公式\\(\\mathtt{c}_{diffuse}=(\\mathtt{c}_{light}\\cdot \\mathtt{m}_{diffuse})max(0,\\vec n \\cdot \\vec l)\\) 根据公式 我们需要取到$\\vec n$ 表面法线，$\\vec l$ 指向光源的单位矢量，$m_{diffuse}$ 材质漫反射颜色,$m_{specular}$ 材质高光颜色，$c_{light}$ 是光源颜色 _MainTex_ST:在 Unity 中，我们需要使用纹理名_ST 的方式来声明某个纹理的属性。其中 ST 是缩放(scale)和平移(translation)的缩写。_MainTex_ST 可以让我们得到该纹理的缩放和平移值，_MainTex_ST.xy 存储的是缩放值，而_MainTex_ST.zw 存储的是偏移值。在顶点着色器中，我们使用纹理的属性值_MainTex_ST 来对 顶点的纹理坐标进行变换，得到最终的纹理。在 UnityCG.cginc 中有预定义 #define TRANSFORM_TEX(tex,name) (tex.xy*name##_ST.xy+name##_ST.zw)。 Shader \"Practice/SingleTex\" { Properties { _MainTex (\"Texture\", 2D) = \"white\" {} _Color(\"Color Tint\",Color)= (1,1,1,1) //漫反射颜色 _Gloss(\"Gloss\",Range(8.0,256)) = 20 //光泽度,光泽度越高反光面积越大 _Specular(\"Specular\",Color) = (1,1,1,1) //高光颜色 } SubShader { Tags { \"LightMode\"=\"ForwardBase\" } Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" #include \"Lighting.cginc\" struct appdata { float4 vertex : POSITION; float4 normal : NORMAL; float2 texcoord : TEXCOORD0; }; struct v2f { float4 pos : SV_POSITION; float3 worldNormal : TEXCOORD0; float3 worldPos : TEXCOORD1; float2 uv : TEXCOORD2; }; sampler2D _MainTex; float4 _MainTex_ST; half _Gloss; fixed4 _Specular; fixed4 _Color; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.vertex); //转换到裁剪空间 o.worldNormal = UnityObjectToWorldNormal(v.normal); o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;//转换到世界空间 o.uv = _MainTex_ST.xy*v.texcoord.xy+_MainTex_ST.zw; // ==&gt; o.uv = TRANSFORM_TEX(v.texcoord,_MainTex); 等价于上面的转换 return o; } fixed4 frag (v2f i) : SV_Target { fixed4 col; //C_diffuse = (C_light·M_diffuse)max(0,N·L) fixed3 worldNormal = normalize(i.worldNormal); //归一化后的世界坐标 fixed3 wolrdLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); //光线 fixed3 albedo = tex2D(_MainTex,i.uv).rgb*_Color.rgb; //取样当前纹理映射坐标的颜色 * 漫反射颜色 &lt;==&gt; 反射的颜色 fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz*albedo; //环境光*反射光 //C_diffuse = (C_light·m_diffuse)max(0,N·L) //漫反射计算公式 这里m_diffuse用的是纹理颜色 fixed3 diffuse = _LightColor0.rgb*albedo*saturate(dot(worldNormal,wolrdLightDir)); //WolrdSpaceViewDir 输入的是模型空间中顶点 fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));//输入的是世界空间的顶点坐标 //H=(V+L)/|V+L| fixed3 halfDir = normalize(wolrdLightDir+viewDir); //C_specular = (C_light*m_specular)pow(max(0,N·H),m_gloss) fixed3 specular = _LightColor0.rgb*_Specular.rgb*pow(saturate(dot(worldNormal,halfDir)),_Gloss); col = fixed4(ambient+diffuse+specular,1.0); return col; } ENDCG } } } 使用单张纹理效果图 " }, { "title": "shader入门基础-光照模型总结", "url": "/posts/shader8/", "categories": "unity", "tags": "shader", "date": "2020-04-27 10:10:00 +0800", "content": "本文内容主要参考 《Unity shader 入门精要》一书，旨在总结所学知识与加深个人理解，为了表示方便，与书中公式略有差别。 漫反射 漫反射光照符合 兰伯特定律：反射光线强度与法线表面和光源方向的夹角的余弦值成正比。 公式 \\(\\mathtt{c}_{diffuse}=(\\mathtt{c}_{light}\\cdot \\mathtt{m}_{diffuse})max(0,\\vec n \\cdot \\vec l)\\) $\\vec n$ 是表面法线，$\\vec l$ 指向光源的单位矢量，$m_{diffuse}$ 材质漫反射颜色，$c_{light}$ 是光源颜色。 高光反射 phong 模型 这里的高光反射是经验模型，并不完全符合真实世界的高光反射现象，它可用于计算沿完全镜面反射方向被反射的光线，这可以让物体 看起来有光泽。 公式$$ \\mathtt{c}{specular}=(\\mathtt{c}{light}\\cdot\\mathtt{m}{specular})max(0,\\vec v\\cdot\\vec r)^{m{gloss}} \\[$m_{gloss}$是材质的光泽度（gloss）,也被称为反光度（shininess）,它用于控制高光区域的亮点有多大，$m_{gloss}$越大，亮点越小。 $m_{specular}$是材质高光反射颜色，它用于控制该材质对于高光反射的强度和颜色。$c_{light}$则是光源的颜色和强度。 $\\vec r$是反射方向，反射可以通过计算获得 $\\vec r=2(\\vec n\\cdot\\vec l)\\vec n-\\vec l$ #### Blinn模型 公式\\] \\mathtt{c}{specular}=(\\mathtt{c}{light}\\cdot\\mathtt{m}{specular})max(0,\\vec n\\cdot\\vec h)^{m{gloss}} \\(Blinn 基本思想是 避免计算反射方向$\\vec r$,引入新的矢量 $\\vec h$。\\)\\vec h=\\frac{\\vec v+\\vec l}{|\\vec v+\\vec l|}$$ 半兰伯特模型 公式 \\(\\mathtt{c}_{diffuse}=(\\mathtt{c}_{light}\\cdot \\mathtt{m}_{diffuse})(\\alpha(0,\\vec n \\cdot \\vec l)+\\beta)\\) 半兰伯特模型没有使用max操作来防止$\\vec n$和$\\vec l$和的点积为负值，而是进行了$\\alpha$倍的缩放和再加上一个$\\beta$的偏移。 在绝大多数情况下，$\\alpha$和$\\beta$的值均为0.5。一般公式为 \\(\\mathtt{c}_{diffuse}=(\\mathtt{c}_{light}\\cdot \\mathtt{m}_{diffuse})(0.5(0,\\vec n \\cdot \\vec l)+0.5)\\) 逐像素与逐顶点 根据计算在不同函数中的实现，可以分为逐像素光照和逐顶点光照。在片元着色器。由于顶点数目往往小于像素数目，因此逐顶点光照的计算量往往 小于逐像素光照。但是由于逐顶点光照依赖线性插值来得到像素光照，因此光照模型中有非线性的计算时，逐顶点光照会有问题。 由于逐顶点光照会在渲染图元内部对顶点颜色进行插值，这会导致渲染图元内部颜色总是暗语顶点最高颜色值。 $$ " }, { "title": "NGUILabel走马灯", "url": "/posts/NGUILabel/", "categories": "unity", "tags": "NGUI", "date": "2020-02-14 00:00:00 +0800", "content": " content 需求 在项目接近尾声的时候，由于本地化的差异，导致很多 ui 超过了显示框，这时候运营方提出 需要在部分地方加上滚动，当文字超过显示的框的时候，自动滚动。由于项目已经接近尾声，所以务必 改动要小。在不改变 UI 结构，以及方便策划快速更改的情况下，开发的组件。 实现 设置如图 using System; using System.Collections; using System.Collections.Generic; using UnityEngine; /// &lt;summary&gt; /// 文字走马灯效果 /// &lt;/summary&gt; [RequireComponent(typeof(UIPanel))] [RequireComponent(typeof(UILabel))] public class ScrollLabelNew : MonoBehaviour { private UIPanel panel; private UILabel label; Vector2 panel_offset; private Vector3 start_pos; public float speedx; public float offset; float mtime; public float stop_time; private void Awake() { panel = GetComponent&lt;UIPanel&gt;(); label = GetComponent&lt;UILabel&gt;(); panel_offset = panel.clipOffset; start_pos = label.transform.localPosition; } private void OnEnable() { int max_depth = 0; foreach (UIPanel panel in transform.GetComponentsInParent&lt;UIPanel&gt;()) { if (panel.depth &gt; max_depth) { max_depth = panel.depth; } } panel.depth = max_depth+1; } private void Update() { if (panel == null || label == null) { return; } if (speedx &lt; 0) { if (label.worldCorners[3].x &lt; panel.worldCorners[3].x+offset) { if (mtime &gt; 0) { mtime = mtime - Time.deltaTime; return; } mtime = stop_time; label.transform.localPosition = start_pos; panel.clipOffset = panel_offset; } } else { if (label.worldCorners[3].x &gt; panel.worldCorners[3].x+offset) { if (mtime &gt; 0) { mtime = mtime - Time.deltaTime; return; } mtime = stop_time; label.transform.localPosition = start_pos; panel.clipOffset = panel_offset; } } label.transform.localPosition += new Vector3(speedx * Time.deltaTime, 0, 0); panel.clipOffset+=new Vector2(-speedx * Time.deltaTime, 0); } } 效果 " }, { "title": "shader入门基础知识七", "url": "/posts/shader7/", "categories": "unity", "tags": "shader", "date": "2020-01-29 00:00:00 +0800", "content": " content cg 流程控制与循环 在前面的章节中shader 入门基础知识五提到过，cg 不支持 switch ，break,default,goto 等关键字，这里不再尝试，下面对 if else 和 for while 进行尝试。 如图，我们对于模型坐标小于 0 的地方给与红色，大于 0 的地方给与绿色，得到的是渐变从红到绿的颜色。 原因是片元着色器的输入是对着色器输出插值后的结果，因此结果是渐变的。 如图，count=30 的时候我们把颜色赋值成红色，否则绿色，显示红色则说明前面的循环都得到了有效的执行。 这里前面提过 cg 支持 bool，和相关的运算符，三目运算符也是支持的。 " }, { "title": "shader入门基础知识六", "url": "/posts/shader6/", "categories": "unity", "tags": "shader", "date": "2020-01-28 00:00:00 +0800", "content": " content Cg 入门三 swizzle 操作 通过 swizzle 操作，可以将 float2，或者 float2 的分量重新组成其他的 float3，float4。 这个时候 float2 的 x,y 分别是 1，0 新组成的 float4 则是（1，0,0,1）因此是红色。 可以同时使用分量，顺序也是可以打乱的。这里我们使用 float2 的分量，并且 y 在前，x 在后，所以新的 float4 是（0，1，0，0），因此是绿色的。对于 swizzle 操作，向量的分量可以是 xyzw，也可以是 rgba，但是在一次操作中 是不允许使用 xyzw 和 rgba 的。 swizzle 操作也允许相同的分量多次使用，例如全部取 x。这时候对应的 float4 的值是（1,1,0,1） 红色+绿色是黄色，因此如图我们获取到的是黄色。 在矩阵中我们不能直接使用 xyzw，但是通过下标我们可以获取到对应的向量，这时候是可以使用 swizzle 操作的，如图我们使用的全是 x，因此对应的 向量值是（1,1,1,1）是白色。 如上图，数组也是不可以使用分量而是需要通过下标获取的。 " }, { "title": "shader入门基础知识五", "url": "/posts/shader5/", "categories": "unity", "tags": "shader", "date": "2020-01-26 00:00:00 +0800", "content": " content Cg 入门二 C 语言和 Cg 语言的区别联系 前言 这里主要是我个人的理解，大家想要准确的解释，还是建议大家上 nvdia 官网读官方文档 Similar Operations That Must be Expressed Differently There are several changes that force the same operation to be expressed differently in Cg than in C: //cg 和 c 都有，但是表达却不同的地方 A Boolean type, bool, is introduced, with corresponding implications for operators and control constructs.//c 语言中的 bool 类型是非 0 为真，cg 中有 true false Arrays are first‐class types because Cg does not support pointers. //数组是第一等类型，因为 cg 不支持指针 ，这里强调数组相当于基础数据类型，不支持引用传递而是值传递 Functions pass values by value/result, and thus use an out or inout modifier in the formal parameter list to return a parameter. By default, formal parameters are in, but it is acceptable to specify this explicitly. Parameters can also be specified as in out, which is semantically the same as inout. //函数传参通过值传递，因此通过 inout 修饰符返回形参列表中的一个修饰符 Differences from ANSI C Cg was developed based on the ANSI‐C language with the following major additions, deletions, and changes. (This is a summary—more detail is provided later in this document)://基于 c 语言的添加删除更改 Language profiles (described in “Profiles” on page 225) may subset language capabilities in a variety of ways. In particular, language profiles may restrict the use of for and while loops. For example, some profiles may only support loops that can be fully unrolled at compile time. A binding semantic may be associated with a structure tag, a variable, or a structure element to denote that object’s mapping to a specific hardware or API resource. See “Binding Semantics” on page 242.  Reserved keywords goto, break, and continue are not supported. Reserved keywords switch, case, and default are not supported. Labels are not supported either.//保留的关键词，goto,break,continue,switch，case，default 不被支持，Labels 也是不被支持的 Pointers and pointer‐related capabilities (such as the &amp; and -&gt; operators) are not supported.//不支持指针和指针相关,例如 &amp; 和 -&gt; Arrays are supported, but with some limitations on size and dimensionality. Restrictions on the use of computed subscripts are also permitted. Arrays may be designated as packed. The operations allowed on packed arrays may be different from those allowed on unpacked arrays. Predefined packed types are provided for vectors and matrices. It is strongly recommended these predefined types be used.//支持数组，但是有指针和维度的限制 Unsized arrays can be created by declaring an array’s dimension as []. The array’s actual dimension can be set at runtime before a final compilation step.//可以通过将数组的维度声明为[]来创建无大小的数组。数组的实际维度可以在运行时在 final 之前设置 There is a built‐in swizzle operator: .xyzw or .rgba for vectors. This operator allows the components of a vector to be rearranged and also replicated. It also allows the creation of a vector from a scalar. //内置的 swizzle 操作符:.xyzw 或.rgba 用于向量。swizzle 运算符允许向量的分量也可以重新排列 复制。它还允许从标量创建向量 For an lvalue, the swizzle operator allows components of a vector or matrix to be selectively written. There is a similar built‐in swizzle operator for matrices: This operator allows access to individual matrix components and allows the creation of a vector from elements of a matrix. For compatibility with DirectX 8 notation, there is a second form of matrix swizzle, which is described later. Numeric data types are different. Cg’s primary numeric data types are float, half, and fixed. Fragment profiles are required to support all three data types, but may choose to implement half and fixed at float precision. Vertex profiles are required to support half and float, but may choose to implement half at float precision. Vertex profiles may omit support for fixed operations, but must still support definition of fixed variables. Cg allows profiles to omit run‐time support for int. Cg allows profiles to treat double as float.  Many operators support per‐element vector operations. The ?:, ||, &amp;&amp;, !, and comparison operators can be used with bool four‐ vectors to perform four conditional operations simultaneously. The side effects of all operands to the ?:, ||, and &amp;&amp; operators are always executed.//Cg 主要数据类型 fixed,half,float,支持?:（三目运算符）||(或)，&amp;&amp;(且)，!(非)等布尔操作符 Non‐static global variables and parameters to top‐level functions—such as main()—may be designated as uniform. A uniform variable may be read and written within a program, just like any other variable. However, the uniform modifier indicates that the initial value of the variable or parameter is expected to be constant across a large number of invocations of the program. A new set of sampler* types represents handles to texture objects. //sampler 处理采样对象 Functions may have default values for their parameters, as in C++. These defaults are expressed using assignment syntax.//函数可能会有默认参数，这些默认的参数使用赋值语义表示 Function overloading is supported.//支持方法重写 There is no enum or union. //不支持枚举或者联合体  Bit‐field declarations in structures are not allowed.  There are no bit‐field declarations in structures.//不支持位域 Variables may be defined anywhere before they are used, rather than just at the beginning of a scope as in C. (That is, we adopt the C++ rules that govern where variable declarations are allowed.) Variables may not be redeclared within the same scope.// 变量可以声明在使用前的任何地方，不可以重复声明在相同的代码块 Vector constructors, such as the form float4(1,2,3,4), may be used anywhere in an expression.//向量构造器可以在任何表达的地方使用 A struct definition automatically performs a corresponding typedef, as in C++.//结构体自动执行位相应的类型 An interface can be specified to define a set of methods that comprises an abstract interface.//接口可以指定定义一些方法来组成抽象接口 A struct type can be declared as implementing an interface by adding a colon “:” and the name of the interface after the name of the struct.//一个结构体可以通过：实现一个接口  Methods can be defined in the body of a struct definition.//方法可以定义在结构体内部 C++‐style // comments are allowed in addition to C‐style /…/ comments.//注释风格支持 // 和/…/ " }, { "title": "shader入门基础知识四", "url": "/posts/shader4/", "categories": "unity", "tags": "shader", "date": "2020-01-19 00:00:00 +0800", "content": " content Cg 入门 Cg 关键字 in,out,inout in:修辞一个形参只是用于输入，进入函数体时被初始化，且该形参值的改变不会影响实参值，这是典型的值传递方式。 out:修辞一个形参只是用于输出的，进入函数体时并没有被初始化，这种类型的形参一般是一个函数的运行结果； inout:修辞一个形参既用于输入也用于输出，这是典型的引用传递。 out是可以被 return 代替的 创建 shader 创建如图所示 shader,并且创建一个材质，游戏中创建一个 cube，将材质赋给 cube，将得到如下所示的颜色 颜色解释 NDC 是一个长宽高取值范围为[-1,1]的立方体,因此 obj_pos 的分量取值范围也是[-1,1] 颜色取值范围是[0,1],小于 0 的取 0，因此获得下图所示的颜色 shader debug 时用到的假彩色图像技术也是类似如此，通过将数据映射到[0,1]范围作为颜色输出到屏幕上，然后通过屏幕颜色来判断数据是否正确。 " }, { "title": "shader入门基础知识三", "url": "/posts/shader3/", "categories": "unity", "tags": "shader", "date": "2020-01-18 00:00:00 +0800", "content": " content 常用的语义，Cg 中的变量，后续还会有其他的补充 完成第一个实例后 shader 入门基础知识二，一些我们之前还不是很清楚的地方需要扩展。 Cg 代码中与 Properties 关联 前文提过需要使用 Properties 中的代码，需要在 Cg 代码块中声明类型和名称都匹配的变量，这里完善shader 入门基础知识二中的表格，方便之后使用 属性类型 例子 Cg 变量类型 Int _Int(“Int”,Int)=2 float Float _Float(“Float”,Float)=2 float,half,fixed Range _Range(“Range”,Range(1.0,3.0))=2.0 float,half,fixed Color _Color(“Color”,Color)=(1.0,1.0,1.0,1.0) float4,half4,fixed4 Vector _Vector(“Vector”,Vector)=(1.0,1.0,1.0,1.0)) float4,half4,fixed4 2D _2D(“2D”,2D)=””{} sampler2D Cube _Cube(“Cube”,Cube)=”white”{} samplerCube 3D _3D(“3D”,3D)=”white”{} sampler3D float：32 位高精度浮点数。 half：16 位中精度浮点数。范围是[-60000, +60000] fixed：11 位低精度浮点数。范围是[-2.0, 2.0] 根据使用情形，尽量使用低精度的数据类型。例如采样颜色的时候使用 fixed 类型。 顶点着色器输入结构体中常用语义，模型输出到 shader 的数据 语义 描述 NORMAL 顶点法线，通常是 float3 类型 POSITION 模型空间中的顶点位置，通常是 float4 类型 TANGENT 顶点切线，通常是 float4 类型 TEXCOORDn 模型纹理坐标，TEXCOORD0 表示第一组坐标纹理，依次类推，通常是 float2,float4 类型，ShaderModel4 一下版本最多支持 8 个纹理，4 和以上支持 16 个 COLOR 顶点颜色，通常是 fixed4 或 float4 类型 顶点着色器输出结构体中常用语义，并且片元着色器的输入 语义 描述 SV_POSITION 裁剪空间中的顶点坐标，结构体中必须包含一个用该语义修饰的变量。否则将无法得到裁剪空间中的顶点坐标，也就无法把顶点渲染到屏幕上 COLOR0 输出第一组顶点颜色 COLOR1 输出第二组顶点颜色 TEXCOORDn 通常用于输出纹理坐标，不是必须 片元着色器输出时常用语义 语义 描述 SV_Target 输出值将会储存到渲染目标（render target）中 为了让 Shader 能在所有平台下正常工作，需尽可能使用如下语义描述 Shader 的输入输出变量 SV_POSITION：顶点着色器输出的顶点位置 SV_Target：片元着色器的输出颜色 SV 即 system value " }, { "title": "shader入门基础知识二", "url": "/posts/shader2/", "categories": "unity", "tags": "shader", "date": "2020-01-15 00:00:00 +0800", "content": " content 创建我们第一个着色器 着色器模板 Standard Surface Shader 标准表面着色器，模拟现实材质与灯光的关系，书写逻辑更符合普通程序 Unilt Shader 不受光照影响的模板 Shader ,常用于 UI，特效 Image Effect Shader 屏幕后处理定制模板 shader，常见的 Bloom,模糊等效果 Compute Shader 运行在图形显卡上的一段程序，可以直接将 GPU 作为并行处理器，从而使 GPU 不仅具有 3D 渲染能力， 还具有其他的运算能力 编写属性 这里我们先创建一个 Unilt Shader,并且删除 SubShader 的内容，只保留 Properties。 其中Properties 语义包含了一些属性，通过这些属性，我们可以方便的调整材质属性，并且在 shader 中访问这些属性。 Properties语义块的定义如下 Properties { _MainTex (\"Texture\", 2D) = \"white\" {} } 属性名字_MainTex,通常以下划线开始，材质面板现实的名字”Texture”,2D 是当前属性的指定类型， “white” {}是默认值。 那么 shader 中都有哪些属性呢 属性类型 例子 Int _Int(“Int”,Int)=2 Float _Float(“Float”,Float)=2 Range _Range(“Range”,Range(1.0,3.0))=2.0 Color _Color(“Color”,Color)=(1.0,1.0,1.0,1.0) Vector _Vector(“Vector”,Vector)=(1.0,1.0,1.0,1.0)) 2D _2D(“2D”,2D)=””{} Cube _Cube(“Cube”,Cube)=”white”{} 3D _3D(“3D”,3D)=”white”{} 其中 2D,Cube 3D 3 种是纹理类型，了解这些后可以声明一个只有 Properties 的 shader，并在里面声明纹理和颜色属性,创建一个材质命名 HelloMat,将我们创建的 shader， 赋值给材质球，我们来看看效果。 对应的材质球显示 这里我们在材质球中看到了声明的_Texture 属性和_Color 属性,那么我们如何再着色器中访问这些属性呢,更改这些属性并最后反应到材质，模型上呢 接下来完善刚才的 shader,添加如下代码。 编写完成后我们将得到如下效果的材质球 小结 到这里我们完成了我们的第一个 shader，这个例子了解了如何在 cg 代码中引用 Properties 的变量，了解了顶点着色器 和片元着色器，以及变量如何再顶点着色器和片元着色器中传递，如何获取模型的数据，最后片元着色器如何输出等。在下一篇文章中 会总结下 Properties 和 cg 变量的对应，常见的语义等。 " }, { "title": "shader入门基础知识一", "url": "/posts/shader1/", "categories": "unity", "tags": "shader", "date": "2020-01-14 00:00:00 +0800", "content": " content 开始编写着色器前我们需要了解的一些基础知识 什么是渲染管线 gpu 内部处理图形信号相互独立的并行单元，一个渲染管线（流水线）是一序列可以并行和按照固定顺序进行的阶段。 Shader 通用的 shader 是渲染流水线的某些特定阶段，例如顶点着色器阶段(vertex shader)和片元着色器阶段(fragment shader) TODO 渲染流水线 UnityShader Unity 为开发者提供的高层级的渲染抽象层，而所有 UnityShader 都是有 ShaderLab 编写的，ShaderLab 是 unity 提供的编写 Unity Shader 的一种说明性语言， 使用 ShaderLab 后开发者将不需要和许多文件和设置打交道 着色器语言 ShadingLaguage DirectX 的 HLSL（High Level Shading Language） OpenGL 的 GLSL (OpenGL Shading Language) NVIDIA Cg (C for Graphic) 选择哪种语言呢？ 首先 GLSL 是跨平台的，但是 GLSL 得跨平台是由于 OpenGL 没有提供着色器编译器，而是由显卡驱动来完成着色器的编译工作，因此 GLSL 是依赖硬件而非操作系统的，对于 不同的硬件，编译结果会不一致。对于手游或者端游开发，我们依赖的是操作系统级的，而非硬件。 HLSL 是微软控制着色器编译，对于不同硬件，相同编译器编译结果是相同的 CG 根据平台不同，会编译成相应的中间语言，而 cg 是和微软合作的产物，因此语法和 HLSL 相像 在 Unity 中我们可以认为是等价的，因此后续我们使用”Cg/HLSL”来编写我们的着色器 什么是 DirectX,OpenGL DirectX,OpenGL 是图像应用层的编程接口，这些接口用于渲染二维或者三维图像 什么是 DrawCall，为什么 DrawCall 多了会导致帧率下降 DrawCall cpu 调用图像编程接口，以命令 Gpu 进行渲染的操作 eg. DirextX 中的 DrawIndexedPrimitive。 每次调用 DrawCall 前，cpu 需要向 GPU 发送很多内容，包括数据，状态，命令等，在这一阶段 cpu 需要完成很多工作，例如检查渲染状态等。 完成后 gpu 开始渲染，gpu 渲染能力很强，渲染 200 或者 2000 个三角网格通常花费差不多，真正造成帧率下降的原因是 cpu 在 DrawCall 过多 之后，会花费大量时间在准备上述工作和提交 DrawCall 上。 " } ]
